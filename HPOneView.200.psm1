##############################################################################
# HPE OneView PowerShell Library
##############################################################################
##############################################################################
## (C) Copyright 2013-2016 Hewlett Packard Enterprise Development LP 
##############################################################################
<#

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

#>

<#
 Note: This library requires the following installed:
 Microsoft .NET Framework 4.6: http://go.microsoft.com/fwlink/?LinkId=528259
 Windows Management Framework (aka PowerShell) 4: https://www.microsoft.com/en-us/download/details.aspx?id=40855
#>

#Revision History
#------------------------------------------
<#
	Moved to \en-US\about_HPOneView.200.help.txt
#>

#Set HPOneView POSH Library Version
#Increment 3rd string by taking todays day (e.g. 23) and hour in 24hr format (e.g. 14), and adding to the prior value.
[version]$script:ModuleVersion = "2.0.340.0"
$Global:CallStack = Get-PSCallStack
$script:ModuleVerbose = [bool]($Global:CallStack | ? { $_.Command -eq "<ScriptBlock>" }).position.text -match "-verbose"

#Check to see if another module is loaded in the console, but allow Import-Module to process normally if user specifies the same module name
if ($(get-module -name HPOneView*) -and (-not $(get-module -name HPOneView* | % name -eq "HPOneView.200"))) 
{ 

    write-Host "CRITICAL:  Another HP OneView module is already loaded:  "  -ForegroundColor Yellow -BackgroundColor Black 
    Write-Host "  |"  -ForegroundColor Yellow -BackgroundColor Black 
    get-module -name HPOneView* | % { write-host "  |--> $($_.name) ($($_.Version))"  -ForegroundColor Yellow -BackgroundColor Black }
    write-host ""

    [System.String]$Exception                                  = 'InvalidOperationException'
    [System.String]$ErrorId                                    = 'CannotLoadMultipleLibraries'
    [System.Object]$TargetObject                               = 'Import-Module HPOneView.200'
    [System.Management.Automation.ErrorCategory]$ErrorCategory = 'ResourceExists'
    [System.String]$Message                                    = 'Another HP OneView module is already loaded.  The HP OneView PowerShell library does not support loading multiple versions of libraries within the same console.'
    
    $_exception  = New-Object $Exception $Message
    $errorRecord = New-Object Management.Automation.ErrorRecord $_exception, $ErrorID, $ErrorCategory, $TargetObject
    throw $errorRecord

}

#Compile custom C# code when module is loaded.
$CSharpProvider = New-Object Microsoft.CSharp.CSharpCodeProvider
$Compiler = $CSharpProvider.CreateCompiler()
$Params = New-Object System.CodeDom.Compiler.CompilerParameters
$Params.GenerateExecutable = $False
$Params.GenerateInMemory = $True
$Params.IncludeDebugInformation = $False
[Void]$Params.ReferencedAssemblies.Add("System.DLL")
$Source = @"
using System;
using System.Collections;
using System.ComponentModel;
using System.IO;
using System.Net;
using System.Net.Security;
using System.Net.Sockets;
using System.Security.Authentication;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading;
//using System.Management.Automation;
//using System.Management.Automation.PSObject;

public static class EnumExtensions
{

    // This extension method is broken out so you can use a similar pattern with 
    // other MetaData elements in the future. This is your base method for each.
    public static T GetAttribute<T>(this Enum value) where T : Attribute
    {
        var type = value.GetType();
        var memberInfo = type.GetMember(value.ToString());
        var attributes = memberInfo[0].GetCustomAttributes(typeof(T), false);
        return (T)attributes[0];
    }

    // This method creates a specific call to the above method, requesting the
    // Description MetaData attribute.
    public static string ToName(this Enum value)
    {
        var attribute = value.GetAttribute<DescriptionAttribute>();
        return attribute == null ? value.ToString() : attribute.Description;
    }

}

namespace HPOneView
{

    namespace PKI
    {

        public class SslCertificate
        {

            public X509Certificate2 Certificate;
            public string Issuer;
            public string Subject;
            public string SubjectAlternativeNames;
            public bool CertificateIsValid;
            public string ErrorInformation;

        }

    }

    namespace Library
    {

        public class ApiCallException : Exception
        {
            public ApiCallException() : base() { }
            public ApiCallException(string message) : base(message) { }
            public ApiCallException(string message, Exception e) : base(message, e) { }
            private string strExtraInfo;
            public string ExtraErrorInfo
            {
                get
                {
                    return strExtraInfo;
                }
                set
                {
                    strExtraInfo = value;
                }

            }

        }

        public class UpdateConnectionError : Exception
        {

            public UpdateConnectionError() : base() { }
            public UpdateConnectionError(string message) : base(message) { }
            public UpdateConnectionError(string message, Exception e) : base(message, e) { }


            private string strExtraInfo;
            public string ExtraErrorInfo
            {
                get
                {
                    return strExtraInfo;
                }

                set
                {
                    strExtraInfo = value;
                }
            }
        }

        public class TooNew : Exception
        {

            public TooNew() : base() { }
            public TooNew(string message) : base(message) { }
            public TooNew(string message, Exception e) : base(message, e) { }


            private string strExtraInfo;
            public string ExtraErrorInfo
            {
                get
                {
                    return strExtraInfo;
                }

                set
                {
                    strExtraInfo = value;
                }

            }

        }

    }

    namespace Networking
    {

        public enum ResourceTypeVersion
        {
                
            [Description("ethernet-networkV3")]
            EthernetNetwork,

            [Description("fcoe-network")]
            FcoeNetwork,

            [Description("fc-networkV2")]
            FcNetwork

        }
        public enum ResourceCategory
        {

            [Description("ethernet-networks")]
            EthernetNetworks,

            [Description("fc-networks")]
            FcNetworks,

            [Description("fcoe-networks")]
            FcoeNetworks

        }

        public enum EthernetNetworkTypes
        {
            [Description("Tagged")]
            Tagged,

            [Description("Tunnel")]
            Tunnel,

            [Description("Untagged")]
            Untagged

        }

        public enum FcFabricTypes
        {

            [Description("FabricAttach")]
            FabricAttach,

            [Description("DirectAttach")]
            DirectAttach

        }

        public enum EthernetNetworkPurpose
        {

            FaultTolerance,
            General,
            Management,
            VMMigration

        }

        //HPOneView.Networking.Networks.Ethernet
        public class EthernetNetwork
        {

            private string _type = ResourceTypeVersion.EthernetNetwork.ToName();
            private string _fabricUri;
            private string _ethernetNetworkType = EthernetNetworkTypes.Tunnel.ToString();
            private int _vlanId = 1;
            private string _connectionTemplateUri;
            private bool _privateNetwork;
            private string _purpose = EthernetNetworkPurpose.General.ToString();
            private bool _smartLink;
            private string _description;
            private string _name;
            private string _state;
            private string _status;
            private string _category = ResourceCategory.EthernetNetworks.ToName();
            private string _eTag;
            private string _created;
            private string _modified;
            private string _uri;

            public string type
            {

                get { return _type; }
                set
                {

                    if (value != ResourceTypeVersion.EthernetNetwork.ToName())
                    {

                        throw new Exception("Invalid resource type property value '" + value + "'");

                    }

                    else
                    {

                        _type = ResourceTypeVersion.EthernetNetwork.ToName();

                    }

                }

            }
            public string fabricUri
            {

                get { return _fabricUri; }

                set { _fabricUri = value; }

            }
            public string ethernetNetworkType
            {

                get { return _ethernetNetworkType; }

                set { _ethernetNetworkType = value; }

            }
            public int vlanId
            {

                get { return _vlanId; }

                set
                {

                    //if (value == 0 && ethernetNetworkType == EthernetNetworkTypes.Tunnel || value <= 4094 && value >= 1)
                    if (value == 0 && ethernetNetworkType == EthernetNetworkTypes.Tunnel.ToName() || value <= 4094 && value >= 1)
                    {

                        _vlanId = value;

                    }
                    //else if (value > 0 && ethernetNetworkType == EthernetNetworkTypes.Tunnel)
                    else if (value > 0 && ethernetNetworkType == EthernetNetworkTypes.Tunnel.ToName())
                    {

                        throw new Exception("vlanId must be 0 when ethernetNeworkType property is 'Tunnel'.");

                    }
                    else
                    {

                        throw new Exception("vlanId must be between 1 and 4096. " + value + " is outside the allowed range.");

                    }

                }

            }
            public string connectionTemplateUri
            {

                get { return _connectionTemplateUri; }

                set { _connectionTemplateUri = value; }

            }
            public bool privateNetwork
            {

                get { return _privateNetwork; }

                set { _privateNetwork = value; }

            }
            public string purpose
            {

                get { return _purpose; }

                set { _purpose = value; }

            }
            public bool smartLink
            {

                get { return _smartLink; }

                set { _smartLink = value; }

            }
            public string description
            {

                get { return _description; }

                set { _description = value; }

            }
            public string name
            {

                get { return _name; }

                set { _name = value; }

            }
            public string state
            {

                get { return _state; }

                set { _state = value; }

            }
            public string status
            {

                get { return _status; }

                set { _status = value; }

            }
            public string category
            {

                get { return _category; }

                set { _category = value; }

            }
            public string eTag
            {

                get { return _eTag; }

                set { _eTag = value; }

            }
            public string created
            {

                get { return _created; }

                set { _created = value; }

            }
            public string modified
            {

                get { return _modified; }

                set { _modified = value; }

            }
            public string uri
            {

                get { return _uri; }

                set { _uri = value; }

            }

            public static T ConvertValue<T, U>(U value) where U : IConvertible
            {
                return (T)Convert.ChangeType(value, typeof(T));
            }

        }

        //HPOneView.Networking.Networks.FibreChannel
        public class FibreChannelNetwork
        {

            private string _fabricType = FcFabricTypes.FabricAttach.ToName();
            private string _connectionTemplateUri;
            private string _linkStabilityTime;
            private string _managedSanUri;
            private bool _autoLoginRedistribution;
            private string _description;
            private string _name;
            private string _state;
            private string _status;
            private string _category = ResourceCategory.FcNetworks.ToName();
            private string _type = ResourceTypeVersion.FcNetwork.ToName();
            private string _eTag;
            private string _created;
            private string _modified;
            private string _uri;

            public string type
            {

                get { return _type; }
                set
                {

                    if (value != ResourceTypeVersion.FcNetwork.ToName())
                    {

                        throw new Exception("Invalid resource type property value '" + value + "'");

                    }

                    else
                    {

                        _type = ResourceTypeVersion.FcNetwork.ToName();

                    }

                }

            }

            public string fabricType
            {

                get { return _fabricType; }
                set { _fabricType = value; }

            }

            public string connectionTemplateUri
            {

                get { return _connectionTemplateUri; }

                set { _connectionTemplateUri = value; }

            }

            public string linkStabilityTime
            {

                get { return _linkStabilityTime; }

                set { _linkStabilityTime = value; }

            }

            public string managedSanUri
            {

                get { return _managedSanUri; }

                set { _managedSanUri = value; }

            }

            public bool autoLoginRedistribution
            {

                get { return _autoLoginRedistribution; }

                set { _autoLoginRedistribution = value; }

            }

            public string description
            {

                get { return _description; }

                set { _description = value; }

            }

            public string name
            {

                get { return _name; }

                set { _name = value; }

            }

            public string state
            {

                get { return _state; }

                set { _state = value; }

            }

            public string status
            {

                get { return _status; }

                set { _status = value; }

            }

            public string category
            {

                get { return _category; }

                set
                {

                    if (value != ResourceCategory.FcNetworks.ToName())
                    {

                        throw new Exception("Invalid resource category property value '" + value + "'");

                    }

                    else
                    {

                        _category = ResourceCategory.FcNetworks.ToName();

                    }

                }

            }

            public string eTag
            {

                get { return _eTag; }

                set { _eTag = value; }

            }

            public string created
            {

                get { return _created; }

                set { _created = value; }

            }

            public string modified
            {

                get { return _modified; }

                set { _modified = value; }

            }

            public string uri
            {

                get { return _uri; }

                set { _uri = value; }

            }

        }

        //HPOneView.Networking.Networks.FCoE
        public class FCoENetwork
        {

            private string _fabricUri;
            private int _vlanId;
            private string _connectionTemplateUri;
            private string _managedSanUri;
            private string _description;
            private string _name;
            private string _state;
            private string _status;
            private string _category = ResourceCategory.FcoeNetworks.ToName();
            private string _type = ResourceTypeVersion.FcoeNetwork.ToName();
            private string _eTag;
            private string _created;
            private string _modified;
            private string _uri;

            public string fabricUri
            {

                get { return _fabricUri; }

                set { _fabricUri = value; }

            }

            public int vlanId
            {

                get { return _vlanId; }

                set
                {

                    if (value <= 4094 && value > 1)
                    {

                        _vlanId = value;

                    }
                    else
                    {

                        throw new Exception("VLANID must be between 2 and 4094. " + value + " is outside the allowed range.");

                    }

                }

            }

            public string connectionTemplateUri
            {

                get { return _connectionTemplateUri; }

                set { _connectionTemplateUri = value; }

            }

            public string managedSanUri
            {

                get { return _managedSanUri; }

                set { _managedSanUri = value; }

            }

            public string description
            {

                get { return _description; }

                set { _description = value; }

            }

            public string name
            {

                get { return _name; }

                set { _name = value; }

            }

            public string state
            {

                get { return _state; }

                set { _state = value; }

            }

            public string status
            {

                get { return _status; }

                set { _status = value; }

            }

            public string category
            {

                get { return _category; }

                set
                {

                    if (value != ResourceCategory.FcoeNetworks.ToName())
                    {

                        throw new Exception("Invalid resource category property value '" + value + "'.  Expected Category: " + ResourceCategory.FcoeNetworks.ToName());

                    }

                    else
                    {

                        _category = ResourceCategory.FcoeNetworks.ToName();

                    }

                }

            }

            public string type
            {

                get { return _type; }
                set
                {

                    if (value != ResourceTypeVersion.FcoeNetwork.ToName())
                    {

                        throw new Exception("Invalid resource type property value '" + value + "'");

                    }

                    else
                    {

                        _type = ResourceTypeVersion.FcoeNetwork.ToName();

                    }

                }

            }

            public string eTag
            {

                get { return _eTag; }

                set { _eTag = value; }

            }

            public string created
            {

                get { return _created; }

                set { _created = value; }

            }

            public string modified
            {

                get { return _modified; }

                set { _modified = value; }

            }

            public string uri
            {

                get { return _uri; }

                set { _uri = value; }

            }

        }

        namespace QoS
        {

            public class BaseTrafficClass : Hashtable
            {

                private class _qosTrafficClass : Hashtable
                {

                    private int _maxBandwidth = 100;
                    private string _bandwidthShare = "0";
                    private int _egressDot1pValue = 0;
                    private bool _realTime = false;
                    private string _className = "Class";
                    private bool _enabled = false;

                    public int maxBandwidth
                    {
                        get { return _maxBandwidth; }
                        set { _maxBandwidth = value; }
                    }

                    public string bandwidthShare
                    {
                        get { return _bandwidthShare; }
                        set { _bandwidthShare = value; }
                    }

                    public int egressDot1pValue
                    {
                        get { return _egressDot1pValue; }
                        set { _egressDot1pValue = value; }
                    }

                    public bool realTime
                    {
                        get { return _realTime; }
                        set { _realTime = value; }
                    }

                    public string className
                    {
                        get { return _className; }
                        set { _className = value; }
                    }

                    public bool enabled
                    {
                        get { return _enabled; }
                        set { _enabled = value; }
                    }

                }

                private class _qosClassificationMapping : Hashtable
                {

                    private ArrayList _dot1pClassMapping;
                    private ArrayList _dscpClassMapping;

                    public ArrayList dot1pClassMapping //: ArrayList
                    {
                        get { return _dot1pClassMapping; }
                        set { _dot1pClassMapping = value; }
                    }

                    public ArrayList dscpClassMapping
                    {
                        get { return _dscpClassMapping; }
                        set { _dscpClassMapping = value; }
                    }

                }

                public BaseTrafficClass()
                {

                    _qosTrafficClass qosTrafficClass = new _qosTrafficClass();
                    _qosClassificationMapping qosClassificationMapping = new _qosClassificationMapping();

                }

            }

        }

    }

    namespace Appliance
    {

        public class Connection
        {

            private int _connectionId = 1;
            private string _name = null;
            private string _sessionId = null;
            private string _userName = null;
            private string _authLoginDomain = null;
            private bool _sslChecked = false;

            public int ConnectionId
            {

                get { return _connectionId; }
                set
                {

                    _connectionId = value;

                }

            }

            public string Name
            {
                get { return _name; }
                set { _name = value; }

            }

            public string SessionID
            {
                get { return _sessionId; }
                set { _sessionId = value; }
            }

            public string UserName
            {
                get { return _userName; }
                set { _userName = value; }
            }

            public string AuthLoginDomain
            {
                get { return _authLoginDomain; }
                set { _authLoginDomain = value; }
            }

            public bool SslChecked
            {

                get { return _sslChecked; }
                set { _sslChecked = value; }

            }

        }

		public class ConnectionShort
        {

            private int _connectionId = 1;
            private string _name = null;
            public int ConnectionId
            {

                get { return _connectionId; }
                set
                {

                    _connectionId = value;

                }

            }

            public string Name
            {
                get { return _name; }
                set { _name = value; }

            }

        }

		public class LoginMessage
        {

            private string _message = null;
            private bool _acknowledgment = false;
            private ConnectionShort _applianceconnection;


            public string Message
            {
                get { return _message; }
                set { _message = value; }

            }

            public bool Acknowledgment
            {

                get { return _acknowledgment; }
                set { _acknowledgment = value; }

            }

            public ConnectionShort ApplianceConnection
            {

                get { return _applianceconnection; }
                set { _applianceconnection = value; }
            }

            public LoginMessage()
            {

                ApplianceConnection = new ConnectionShort() { ConnectionId = 1, Name = null };

            }

        }

        public class Task
        {

            //"associatedResource": 
            //{
            //    "associationType": "MANAGED_BY",
            //    "resourceCategory": "enclosures",
            //    "resourceName": "enclosure1234",
            //    "resourceUri": "/rest/enclosures/ABCD123"
            //},
            //"associatedTaskUri":"associatedTaskUri",
            //"category":"tasks",
            //"completedSteps":0,
            //"computedPercentComplete":0,
            //"created":"2014-04-08T10:07:35.815Z",
            //"data":null,
            //"eTag":null,
            //"expectedDuration":0,
            //"hidden":false,
            //"modified":"2014-04-08T10:07:35.815Z",
            //"name":"mytask1",
            //"owner":"Administrator",
            //"parentTaskUri":"/rest/tasks/myparenttask",
            //"percentComplete":0,
            //"progressUpdates":[
            // {
            //    "id" : 1,
            //    "statusUpdate" : "Some update message"
            //    "timestamp" : "TIMESTAMP"
            // }
            //],
            //"stateReason":null,
            //"taskErrors":[ 
            // {
            //    data
            //    details         
            //    errorCode
            //
            // }       
            //],
            //"taskOutput":[ ],
            //"taskState":"Interrupted",
            //"taskStatus":"myresults",
            //"taskType":"Appliance",
            //"totalSteps":0,
            //"type":"TaskResourceV2",
            //"uri":"/rest/tasks/FD73016A-827C-4AAC-8527-8469288A38B3",
            //"userInitiated":false            

            private Array _associatedResource = null;
            private string _associatedTaskUri = null;
            private string _category = "tasks";
            private int _completedSteps;
            private int _computedPercentComplete;
            private string _created = null;
            private string _data = null;
            private string _eTag = null;
            private int _expectedDuration;
            private bool _hidden;
            private string _modified;
            private string _name;
            private string _owner;
            private string _parentTaskUri;
            private int _percentComplete;
            private IDictionary _progressUpdates;
            private string _stateReason;
            private IDictionary _taskErrors;
            private string _taskOutput;
            private string _taskState;
            private string _taskStatus;
            private string _taskType;
            private int _totalSteps;
            private string _type = "TaskResourceV2";
            private string _uri;
            private bool _userInitiated;

            private class AssociatedResource //: Hashtable
            {

                public string associationType;
                public string resourceCategory;
                public string resourceName;
                public string resourceUri;

                public AssociatedResource()
                {

                    //return new AssociatedResource;

                }

            }

            //public IDictionary associatedResource
            //{
            //
            //    //get { return _associatedResource; }
            //    //set { _associatedResource = value; }
            //
            //}

            public string associatedTaskUri
            {
                get { return _associatedTaskUri; }
                set { _associatedTaskUri = value; }

            }

            public string category
            {
                get { return _category; }
                set { _category = value; }
            }

            public int completedSteps
            {
                get { return _completedSteps; }
                set { _completedSteps = value; }
            }

            public int computedPercentComplete
            {
                get { return _computedPercentComplete; }
                set { _computedPercentComplete = value; }
            }

            public string created
            {

                get { return _created; }
                set { _created = value; }

            }

            public string data
            {

                get { return _data; }
                set { _data = value; }

            }

            public string eTag
            {

                get { return _eTag; }
                set { _eTag = value; }

            }

        }

        //Exceptions
        public class ResourcePrivledgeException : Exception
        {

            public ResourcePrivledgeException() : base() { }
            public ResourcePrivledgeException(string message) : base(message) { }
            public ResourcePrivledgeException(string message, Exception e) : base(message, e) { }


            private string strExtraInfo;
            public string ExtraErrorInfo
            {
                get
                {
                    return strExtraInfo;
                }

                set
                {
                    strExtraInfo = value;
                }
            }
        }

		public class UploadFileException : Exception
        {

            public UploadFileException() : base() { }
            public UploadFileException(string message) : base(message) { }
            public UploadFileException(string message, Exception e) : base(message, e) { }


            private string strExtraInfo;
            public string ExtraErrorInfo
            {
                get
                {
                    return strExtraInfo;
                }

                set
                {
                    strExtraInfo = value;
                }
            }
        }

        public class PasswordChangeRequired : Exception
        {

            public PasswordChangeRequired() : base() { }
            public PasswordChangeRequired(string message) : base(message) { }
            public PasswordChangeRequired(string message, Exception e) : base(message, e) { }


            private string strExtraInfo;
            public string ExtraErrorInfo
            {
                get
                {
                    return strExtraInfo;
                }

                set
                {
                    strExtraInfo = value;
                }
            }
        }

        public class NetworkConnectionException : Exception
        {

            public NetworkConnectionException() : base() { }
            public NetworkConnectionException(string message) : base(message) { }
            public NetworkConnectionException(string message, Exception e) : base(message, e) { }


            private string strExtraInfo;
            public string ExtraErrorInfo
            {
                get
                {
                    return strExtraInfo;
                }

                set
                {
                    strExtraInfo = value;
                }

            }

        }

        public class NetworkConfigurationException : Exception
        {

            public NetworkConfigurationException() : base() { }
            public NetworkConfigurationException(string message) : base(message) { }
            public NetworkConfigurationException(string message, Exception e) : base(message, e) { }


            private string strExtraInfo;
            public string ExtraErrorInfo
            {
                get
                {
                    return strExtraInfo;
                }

                set
                {
                    strExtraInfo = value;
                }

            }

        }

        public class FirmwareUpdateException : Exception
        {

            public FirmwareUpdateException() : base() { }
            public FirmwareUpdateException(string message) : base(message) { }
            public FirmwareUpdateException(string message, Exception e) : base(message, e) { }

            private string strExtraInfo;
            public string ExtraErrorInfo
            {
                get
                {
                    return strExtraInfo;
                }

                set
                {
                    strExtraInfo = value;
                }

            }

        }

        public class TaskValidationException : Exception
        {

            public TaskValidationException() : base() { }
            public TaskValidationException(string message) : base(message) { }
            public TaskValidationException(string message, Exception e) : base(message, e) { }

            private string strExtraInfo;
            public string ExtraErrorInfo
            {
                get
                {
                    return strExtraInfo;
                }

                set
                {
                    strExtraInfo = value;
                }

            }

        }

		public class TaskResourceException : Exception
        {

            public TaskResourceException() : base() { }
            public TaskResourceException(string message) : base(message) { }
            public TaskResourceException(string message, Exception e) : base(message, e) { }

            private string strExtraInfo;
            public string ExtraErrorInfo
            {
                get
                {
                    return strExtraInfo;
                }

                set
                {
                    strExtraInfo = value;
                }

            }

        }

        public class AuthSessionException : Exception
        {

            public AuthSessionException() : base() { }
            public AuthSessionException(string message) : base(message) { }
            public AuthSessionException(string message, Exception e) : base(message, e) { }

            private string strExtraInfo;
            public string ExtraErrorInfo
            {
                get
                {
                    return strExtraInfo;
                }

                set
                {
                    strExtraInfo = value;
                }

            }

        }

        public class AuthPrivilegeException : Exception
        {

            public AuthPrivilegeException() : base() { }
            public AuthPrivilegeException(string message) : base(message) { }
            public AuthPrivilegeException(string message, Exception e) : base(message, e) { }

            private string strExtraInfo;
            public string ExtraErrorInfo
            {
                get
                {
                    return strExtraInfo;
                }

                set
                {
                    strExtraInfo = value;
                }

            }

        }

        public class PasswordMismatch : Exception
        {

            public PasswordMismatch() : base() { }
            public PasswordMismatch(string message) : base(message) { }
            public PasswordMismatch(string message, Exception e) : base(message, e) { }

            private string strExtraInfo;
            public string ExtraErrorInfo
            {
                get
                {
                    return strExtraInfo;
                }

                set
                {
                    strExtraInfo = value;
                }

            }

        }

        public class UserResourceException : Exception
        {

            public UserResourceException() : base() { }
            public UserResourceException(string message) : base(message) { }
            public UserResourceException(string message, Exception e) : base(message, e) { }

            private string strExtraInfo;
            public string ExtraErrorInfo
            {
                get
                {
                    return strExtraInfo;
                }

                set
                {
                    strExtraInfo = value;
                }

            }

        }

        public class LdapDirectoryException : Exception
        {

            public LdapDirectoryException() : base() { }
            public LdapDirectoryException(string message) : base(message) { }
            public LdapDirectoryException(string message, Exception e) : base(message, e) { }

            private string strExtraInfo;
            public string ExtraErrorInfo
            {
                get
                {
                    return strExtraInfo;
                }

                set
                {
                    strExtraInfo = value;
                }

            }

        }

        public class LdapDirectoryGroupException : Exception
        {

            public LdapDirectoryGroupException() : base() { }
            public LdapDirectoryGroupException(string message) : base(message) { }
            public LdapDirectoryGroupException(string message, Exception e) : base(message, e) { }

            private string strExtraInfo;
            public string ExtraErrorInfo
            {
                get
                {
                    return strExtraInfo;
                }

                set
                {
                    strExtraInfo = value;
                }

            }

        }

        public class GlobalSettingException : Exception
        {

            public GlobalSettingException() : base() { }
            public GlobalSettingException(string message) : base(message) { }
            public GlobalSettingException(string message, Exception e) : base(message, e) { }

            private string strExtraInfo;
            public string ExtraErrorInfo
            {
                get
                {
                    return strExtraInfo;
                }

                set
                {
                    strExtraInfo = value;
                }
            }

        }

        public class LicenseKeyException : Exception
        {

            public LicenseKeyException() : base() { }
            public LicenseKeyException(string message) : base(message) { }
            public LicenseKeyException(string message, Exception e) : base(message, e) { }

            private string strExtraInfo;
            public string ExtraErrorInfo
            {
                get
                {
                    return strExtraInfo;
                }

                set
                {
                    strExtraInfo = value;
                }

            }

        }

    }

    public class EnclosureResourceException : Exception
    {

        public EnclosureResourceException() : base() { }
        public EnclosureResourceException(string message) : base(message) { }
        public EnclosureResourceException(string message, Exception e) : base(message, e) { }

        private string strExtraInfo;
        public string ExtraErrorInfo
        {
            get
            {
                return strExtraInfo;
            }

            set
            {
                strExtraInfo = value;
            }

        }

    }

    public class LogicalEnclosureResourceException : Exception
    {

        public LogicalEnclosureResourceException() : base() { }
        public LogicalEnclosureResourceException(string message) : base(message) { }
        public LogicalEnclosureResourceException(string message, Exception e) : base(message, e) { }

        private string strExtraInfo;
        public string ExtraErrorInfo
        {
            get
            {
                return strExtraInfo;
            }

            set
            {
                strExtraInfo = value;
            }

        }

    }

    public class ResourceNotFoundException : Exception
    {

        public ResourceNotFoundException() : base() { }
        public ResourceNotFoundException(string message) : base(message) { }
        public ResourceNotFoundException(string message, Exception e) : base(message, e) { }

        private string strExtraInfo;
        public string ExtraErrorInfo
        {
            get
            {
                return strExtraInfo;
            }

            set
            {
                strExtraInfo = value;
            }

        }

    }

    public class EnclosureGroupResourceException : Exception
    {

        public EnclosureGroupResourceException() : base() { }
        public EnclosureGroupResourceException(string message) : base(message) { }
        public EnclosureGroupResourceException(string message, Exception e) : base(message, e) { }

        private string strExtraInfo;
        public string ExtraErrorInfo
        {
            get
            {
                return strExtraInfo;
            }

            set
            {
                strExtraInfo = value;
            }

        }

    }

    public class BaselineResourceException : Exception
    {

        public BaselineResourceException() : base() { }
        public BaselineResourceException(string message) : base(message) { }
        public BaselineResourceException(string message, Exception e) : base(message, e) { }

        private string strExtraInfo;
        public string ExtraErrorInfo
        {
            get
            {
                return strExtraInfo;
            }

            set
            {
                strExtraInfo = value;
            }

        }

    }

	public class SnmpTrapDestination : Exception
    {

        public SnmpTrapDestination() : base() { }
        public SnmpTrapDestination(string message) : base(message) { }
        public SnmpTrapDestination(string message, Exception e) : base(message, e) { }

        private string strExtraInfo;
        public string ExtraErrorInfo
        {
            get
            {
                return strExtraInfo;
            }

            set
            {
                strExtraInfo = value;
            }

        }

    }

    public class NetworkResourceException : Exception
    {

        public NetworkResourceException() : base() { }
        public NetworkResourceException(string message) : base(message) { }
        public NetworkResourceException(string message, Exception e) : base(message, e) { }

        private string strExtraInfo;
        public string ExtraErrorInfo
        {
            get
            {
                return strExtraInfo;
            }

            set
            {
                strExtraInfo = value;
            }

        }

    }

	public class NetworkSetResourceException : Exception
    {

        public NetworkSetResourceException() : base() { }
        public NetworkSetResourceException(string message) : base(message) { }
        public NetworkSetResourceException(string message, Exception e) : base(message, e) { }

        private string strExtraInfo;
        public string ExtraErrorInfo
        {
            get
            {
                return strExtraInfo;
            }

            set
            {
                strExtraInfo = value;
            }

        }

    }

    public class LogicalInterconnectGroupResourceException : Exception
    {

        public LogicalInterconnectGroupResourceException() : base() { }
        public LogicalInterconnectGroupResourceException(string message) : base(message) { }
        public LogicalInterconnectGroupResourceException(string message, Exception e) : base(message, e) { }

        private string strExtraInfo;
        public string ExtraErrorInfo
        {
            get
            {
                return strExtraInfo;
            }

            set
            {
                strExtraInfo = value;
            }

        }

    }

    public class LogicalInterconnectResourceException : Exception
    {

        public LogicalInterconnectResourceException() : base() { }
        public LogicalInterconnectResourceException(string message) : base(message) { }
        public LogicalInterconnectResourceException(string message, Exception e) : base(message, e) { }

        private string strExtraInfo;
        public string ExtraErrorInfo
        {
            get
            {
                return strExtraInfo;
            }

            set
            {
                strExtraInfo = value;
            }

        }

    }

    public class InterconnectResourceException : Exception
    {

        public InterconnectResourceException() : base() { }
        public InterconnectResourceException(string message) : base(message) { }
        public InterconnectResourceException(string message, Exception e) : base(message, e) { }

        private string strExtraInfo;
        public string ExtraErrorInfo
        {
            get
            {
                return strExtraInfo;
            }

            set
            {
                strExtraInfo = value;
            }

        }

    }

    public class InterconnectTypeResourceException : Exception
    {

        public InterconnectTypeResourceException() : base() { }
        public InterconnectTypeResourceException(string message) : base(message) { }
        public InterconnectTypeResourceException(string message, Exception e) : base(message, e) { }

        private string strExtraInfo;
        public string ExtraErrorInfo
        {
            get
            {
                return strExtraInfo;
            }

            set
            {
                strExtraInfo = value;
            }

        }

    }

    public class InterconnectPortResourceException : Exception
    {

        public InterconnectPortResourceException() : base() { }
        public InterconnectPortResourceException(string message) : base(message) { }
        public InterconnectPortResourceException(string message, Exception e) : base(message, e) { }

        private string strExtraInfo;
        public string ExtraErrorInfo
        {
            get
            {
                return strExtraInfo;
            }

            set
            {
                strExtraInfo = value;
            }

        }

    }

    public class UplinkSetResourceException : Exception
    {

        public UplinkSetResourceException() : base() { }
        public UplinkSetResourceException(string message) : base(message) { }
        public UplinkSetResourceException(string message, Exception e) : base(message, e) { }

        private string strExtraInfo;
        public string ExtraErrorInfo
        {
            get
            {
                return strExtraInfo;
            }

            set
            {
                strExtraInfo = value;
            }

        }

    }

    public class ServerHardwareResourceException : Exception
    {

        public ServerHardwareResourceException() : base() { }
        public ServerHardwareResourceException(string message) : base(message) { }
        public ServerHardwareResourceException(string message, Exception e) : base(message, e) { }

        private string strExtraInfo;
        public string ExtraErrorInfo
        {
            get
            {
                return strExtraInfo;
            }

            set
            {
                strExtraInfo = value;
            }

        }

    }

    public class StorageSystemResourceException : Exception
    {

        public StorageSystemResourceException() : base() { }
        public StorageSystemResourceException(string message) : base(message) { }
        public StorageSystemResourceException(string message, Exception e) : base(message, e) { }

        private string strExtraInfo;
        public string ExtraErrorInfo
        {
            get
            {
                return strExtraInfo;
            }

            set
            {
                strExtraInfo = value;
            }

        }

    }

	public class StoragePoolResourceException : Exception
    {

        public StoragePoolResourceException() : base() { }
        public StoragePoolResourceException(string message) : base(message) { }
        public StoragePoolResourceException(string message, Exception e) : base(message, e) { }

        private string strExtraInfo;
        public string ExtraErrorInfo
        {
            get
            {
                return strExtraInfo;
            }

            set
            {
                strExtraInfo = value;
            }

        }

    }

    public class StorageVolumeResourceException : Exception
    {

        public StorageVolumeResourceException() : base() { }
        public StorageVolumeResourceException(string message) : base(message) { }
        public StorageVolumeResourceException(string message, Exception e) : base(message, e) { }

        private string strExtraInfo;
        public string ExtraErrorInfo
        {
            get
            {
                return strExtraInfo;
            }

            set
            {
                strExtraInfo = value;
            }

        }

    }

    public class SanManagerResourceException : Exception
    {

        public SanManagerResourceException() : base() { }
        public SanManagerResourceException(string message) : base(message) { }
        public SanManagerResourceException(string message, Exception e) : base(message, e) { }

        private string strExtraInfo;
        public string ExtraErrorInfo
        {
            get
            {
                return strExtraInfo;
            }

            set
            {
                strExtraInfo = value;
            }

        }

    }

    public class ServerProfileResourceException : Exception
    {

        public ServerProfileResourceException() : base() { }
        public ServerProfileResourceException(string message) : base(message) { }
        public ServerProfileResourceException(string message, Exception e) : base(message, e) { }

        private string strExtraInfo;
        public string ExtraErrorInfo
        {
            get
            {
                return strExtraInfo;
            }

            set
            {
                strExtraInfo = value;
            }

        }

    }

    public class ServerProfileTemplateResourceException : Exception
    {

        public ServerProfileTemplateResourceException() : base() { }
        public ServerProfileTemplateResourceException(string message) : base(message) { }
        public ServerProfileTemplateResourceException(string message, Exception e) : base(message, e) { }

        private string strExtraInfo;
        public string ExtraErrorInfo
        {
            get
            {
                return strExtraInfo;
            }

            set
            {
                strExtraInfo = value;
            }

        }

    }

    public class ServerProfileConnectionException : Exception
    {

    public ServerProfileConnectionException() : base() { }
    public ServerProfileConnectionException(string message) : base(message) { }
    public ServerProfileConnectionException(string message, Exception e) : base(message, e) { }

    private string strExtraInfo;
    public string ExtraErrorInfo
    {
        get
        {
            return strExtraInfo;
        }

        set
        {
            strExtraInfo = value;
        }

    }

    }

    public class UnmanagedDeviceResourceException : Exception
    {

        public UnmanagedDeviceResourceException() : base() { }
        public UnmanagedDeviceResourceException(string message) : base(message) { }
        public UnmanagedDeviceResourceException(string message, Exception e) : base(message, e) { }

        private string strExtraInfo;
        public string ExtraErrorInfo
        {
            get
            {
                return strExtraInfo;
            }

            set
            {
                strExtraInfo = value;
            }

        }

    }

    public class PowerDeliveryDeviceException : Exception
    {

        public PowerDeliveryDeviceException() : base() { }
        public PowerDeliveryDeviceException(string message) : base(message) { }
        public PowerDeliveryDeviceException(string message, Exception e) : base(message, e) { }

        private string strExtraInfo;
        public string ExtraErrorInfo
        {
            get
            {
                return strExtraInfo;
            }

            set
            {
                strExtraInfo = value;
            }

        }

    }

    public class VcMigratorException : Exception
    {

        public VcMigratorException() : base() { }
        public VcMigratorException(string message) : base(message) { }
        public VcMigratorException(string message, Exception e) : base(message, e) { }

        private string strExtraInfo;
        public string ExtraErrorInfo
        {
            get
            {
                return strExtraInfo;
            }

            set
            {
                strExtraInfo = value;
            }

        }

    }

    public class ITempPolicy : ICertificatePolicy
    {
        public ITempPolicy() { }
        public bool CheckValidationResult(
            ServicePoint sPoint, X509Certificate cert,
            WebRequest wRequest, int certProb)
        {
            return true;
        }
    }

}
"@

$Global:CompileResults = $CSharpProvider.CompileAssemblyFromSource($Params,$Source)
$Assembly = $Global:CompileResults.CompiledAssembly

if ($Global:CompileResults.Errors -and (-not($Assembly))) 
{

	[System.String]$Exception    = 'InvalidOperationException'
    [System.String]$ErrorId      = 'CSharpCompileFailure'
    [System.Object]$TargetObject = 'CSharpSource'
    [System.Management.Automation.ErrorCategory]$ErrorCategory = 'InvalidResult'
    [System.String]$Message      = "Line {0}, Column {1}. {2}" -f $Global:CompileResults.Errors[0].Line,$Global:CompileResults.Errors[0].Column,$Global:CompileResults.Errors[0].ErrorText
    
    $_exception  = New-Object $Exception $Message
    $errorRecord = New-Object Management.Automation.ErrorRecord $_exception, $ErrorID, $ErrorCategory, $TargetObject
    throw $errorRecord

}

$debugMode = $False

#Note: Set $debugPreference to control debug logging
If ($debugmode) 
{

    $debugPreference = "Continue"         # Display requests and responses
    $VerbosePreference = "Continue" 

}
#Else{ $debugPreference = "SilentlyContinue" } # Hide debug messages

#region URIs
[String]$script:AuthProviderSetting = "LOCAL"
${Global:ConnectedSessions}         = New-Object System.Collections.ArrayList
${Global:ResponseErrorObject}       = New-Object System.Collections.ArrayList
[TimeSpan]$script:defaultTimeout    = New-TimeSpan -Minutes 20
$script:FSOpenMode                  = [System.IO.FileMode]::Open
$script:FSRead                      = [System.IO.FileAccess]::Read
[MidpointRounding]$script:MathMode  = 'AwayFromZero' 
[String]$script:MaxXAPIVersion      = "200"
[String]$script:applMinVersion      = "200"
[String]$script:repository          = "https://api.github.com/repos/HewlettPackard/POSH-HPOneView/releases"

#------------------------------------
# Appliance Configuration
#------------------------------------
[String]$script:ApplianceStartProgressUri  = '/rest/appliance/progress'
[String]$script:ApplianceVersionUri        = '/rest/appliance/nodeinfo/version'
[String]$script:ApplianceEulaStatusUri     = '/rest/appliance/eula/status'
[String]$script:ApplianceEulaSaveUri       = '/rest/appliance/eula/save'
[String]$script:ApplianceNetworkConfigUri  = '/rest/appliance/network-interfaces'
[String]$script:ApplianceNetworkStatusUri  = '/rest/appliance/network-interfaces/status'
[String]$script:ApplianceNetworkMacAddrUri = '/rest/appliance/network-interfaces/mac-addresses'
[string]$script:ApplianceDateTimeUri       = '/rest/appliance/configuration/time-locale'
[String]$script:ApplianceGlobalSettingsUri = '/rest/global-settings'
[String]$script:ApplianceXApiVersionUri    = '/rest/version'
[String]$script:applBackup                 = "/rest/backups"
[String]$script:applRestoreFile            = "/rest/backups/archive"
[String]$script:applRestore                = "/rest/restores"
[Hashtable]$script:progressStepEnum        = @{

	COMPLETED            = "Restore Completed";
	FAILED               = "Restore Failed";
	PREPARING_TO_RESTORE = "Preparing to Restore";
	RESTORING_DB         = "Restoring Database";
	RESTORING_FILES      = "Restoring Files";
	STARTING_SERVICES    = "Starting Services";
	UNKNOWN              = "The restore step is unknown"

}
[Hashtable]$Script:ApplianceLocaleSetEnum  = @{

	'en-US' = 'en_US.UTF-8';
	'en_US' = 'en_US.UTF-8';
	'zh_CN' = 'zh_CN.UTF-8';
	'zh-CN' = 'zh_CN.UTF-8';
	'ja_JP' = 'ja_JP.UTF-8';
	'ja-JP' = 'ja_JP.UTF-8';


}
[Hashtable]$Script:ApplianceLocaleEnum     = @{

	'en_US.UTF-8' = 'English (United States)';
	'zh_CN.UTF-8' = 'Chinese (China)';
	'ja_JP.UTF-8' = 'Japanese (Japan)';

}
[String]$script:applSupportDump            = "/rest/appliance/support-dumps"
[String]$script:applHealthStatus           = "/rest/appliance/health-status"
[String]$script:applRabbitmqUri            = "/rest/certificates/client/rabbitmq"
[String]$script:applKeypairUri             = "/rest/certificates/client/rabbitmq/keypair/default"
[String]$script:applCaUri                  = "/rest/certificates/ca"
[String]$script:applUpdate                 = "/rest/appliance/firmware/image"
[String]$script:applUpdatePending          = "/rest/appliance/firmware/pending"
[String]$script:applUpdateNotification     = "/rest/appliance/firmware/notification"
[String]$script:applUpdateMonitor          = "/cgi-bin/status/update-status.cgi"
[String]$script:applSnmpReadCommunity      = "/rest/appliance/device-read-community-string"
[String]$script:applianceRebootUri         = '/rest/appliance/shutdown?type=REBOOT'
[String]$script:applianceShutDownUri       = '/rest/appliance/shutdown?type=HALT'
[String]$script:applianceCsr               = '/rest/certificates/https/certificaterequest'
[String]$script:applianceSslCert           = '/rest/certificates/https'
[String]$Script:appliancePingTestUri       = '/rest/appliance/reachable'
[string]$script:applianceDebugLogSetting   = '/logs/rest/debug/'
#------------------------------------
# Physical Resource Management
#------------------------------------
[String]$script:ServerHardwareUri                       = "/rest/server-hardware"
[String]$script:serverHardwareTypesUri                  = "/rest/server-hardware-types"
[String]$script:StorageSystemUri                        = "/rest/storage-systems"
[String]$script:StorageVolumeUri                        = "/rest/storage-volumes"
[String]$script:StoragePoolUri                          = "/rest/storage-pools"
[String]$script:AttachableVolumesUri                    = '/rest/storage-volumes/attachable-volumes'
[String]$script:StorageVolumeTemplateUri                = "/rest/storage-volume-templates"
[string]$script:ApplStorageVolumeTemplateRequiredPolicy = '/rest/global-settings/appliance/global/StorageVolumeTemplateRequired'
[String]$script:fcSanManagerProvidersUri                = "/rest/fc-sans/providers"  #list available SAN Manager plugins, and create SAN Manager
[Hashtable]$script:fcSanManagerSnmpAuthLevel            = @{
	None        = "noauthnopriv";
	AuthOnly    = "authnopriv";
	AuthAndPriv = "authpriv"
}
[String]$script:FcSanManagersUri                        = "/rest/fc-sans/device-managers" #created SAN Managers
[String]$script:FcManagedSansUri                        = "/rest/fc-sans/managed-sans" #Discovered managed SAN(s) that the added SAN Manager will manage
[String]$Script:SanEndpoints                            = '/rest/fc-sans/endpoints'
[String]$script:enclosuresUri                           = "/rest/enclosures"
[String]$script:LogicalEnclosuresUri                    = '/rest/logical-enclosures'
[String]$script:enclosureGroupsUri                      = "/rest/enclosure-groups"
[String]$script:enclosurePreviewUri                     = "/rest/enclosure-preview"
[String]$script:fwUploadUri                             = "/rest/firmware-bundles"
[String]$script:fwDriversUri                            = "/rest/firmware-drivers"
[String]$script:powerDevicesUri                         = "/rest/power-devices"
[String]$script:powerDevicesDiscoveryUri                = "/rest/power-devices/discover"
[String]$script:powerDevicePotentialConnections         = "/rest/power-devices/potentialConnections?providerUri="
[String]$script:unmanagedDevicesUri                     = "/rest/unmanaged-devices?sort=name:asc"
[PSCustomObject]$script:mpModelTable                    = @{
	ilo2 = "RI7";
	ilo3 = "RI9";
	ilo4 = "RI10"
}
[HashTable]$Script:ServerPowerControlEnum               = @{

	PressAndHold   = 'PressAndHold';
	MomentaryPress = 'MomentaryPress';
	ColdBoot       = 'ColdBoot';
	Reset          = 'Reset'

}
#------------------------------------
# Network Resource Management
#------------------------------------
[String]$script:networkSetsUri               = "/rest/network-sets"
[String]$script:ethNetworksUri               = "/rest/ethernet-networks"
[String]$script:fcNetworksUri                = "/rest/fc-networks"
[String]$script:fcoeNetworksUri              = "/rest/fcoe-networks"
[String]$script:connectionTemplatesUri       = "/rest/connection-templates"
[String]$script:logicalInterconnectGroupsUri = "/rest/logical-interconnect-groups"
[String]$script:logicalInterconnectsUri      = "/rest/logical-interconnects"
[String]$script:interconnectsUri             = "/rest/interconnects"
[String]$script:InterconnectTypesUri         = '/rest/interconnect-types'
[String]$script:uplinkSetsUri                = "/rest/uplink-sets"
[String]$script:logicalDownlinksUri          = "/rest/logical-downlinks"
[String]$script:ApplianceVmacPoolsUri        = '/rest/id-pools/vmac'
[String]$script:ApplianceVmacPoolRangesUri   = '/rest/id-pools/vmac/ranges'
[String]$script:ApplianceVwwnPoolsUri        = '/rest/id-pools/vwwn'
[String]$script:ApplianceVwwnPoolRangesUri   = '/rest/id-pools/vwwn/ranges'
[String]$script:ApplianceVsnPoolsUri         = '/rest/id-pools/vsn'
[String]$script:ApplianceVsnPoolRangesUri    = '/rest/id-pools/vsn/ranges'
[String]$script:ApplianceIPv4PoolsUri        = '/rest/id-pools/ipv4'
[String]$script:ApplianceIPv4SubnetsUri      = '/rest/id-pools/ipv4/subnets'
[String]$script:ApplianceVmacGenerateUri     = '/rest/id-pools/vmac/generate'
[String]$script:ApplianceVwwnGenerateUri     = '/rest/id-pools/vwwn/generate'
[String]$script:ApplianceVsnPoolGenerateUri  = '/rest/id-pools/vsn/generate'
$script:macAddressPattern                    = @('^([0-9a-f]{2}:){5}([0-9a-f]{2})$')
$script:wwnAddressPattern                    = @('^([0-9a-f]{2}:){7}([0-9a-f]{2})$')
$script:wwnLongAddressPattern                = @('^([0-9a-f]{2}:){15}([0-9a-f]{2})$')
[RegEx]$script:ip4regex                      = "\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}"
[Hashtable]$global:GetUplinkSetPortSpeeds    = @{
    Speed0M   = "0";
    Speed100M = "100Mb";
    Speed10G  = "10Gb";
    Speed10M  = "10Mb";
    Speed1G   = "1Gb";
    Speed1M   = "1Mb";
    Speed20G  = "20Gb";
    Speed2G   = "2Gb";
    Speed2_5G = "2.5Gb";
    Speed40G  = "40Gb";
    Speed4G   = "4Gb";
    Speed8G   = "8Gb";
    Auto       = "Auto"
}
[Hashtable]$global:SetUplinkSetPortSpeeds    = @{
	'0'    = "Speed0M";
	'100M' = "Speed100M";
	'100' = "Speed100M";
	'10G'  = "Speed10G";
	'10'   = "Speed10G";
	'10M'  = "Speed10M";
	'1G'   = "Speed1G";
	'1'    = "Speed1G";
	'1M'   = "Speed1M";
	'20G'  = "Speed20G";
	'2G'   = "Speed2G";
	'2'    = "Speed2G";
	'2.5G' = "Speed2_5G";
	'40G'  = "Speed40G";
	'4G'   = "Speed4G";
	'8G'   = "Speed8G";
	'4'    = "Speed4G";
	'8'    = "Speed8G";
	'Auto' = "Auto"
}
[Hashtable]$global:LogicalInterconnectConsistencyStatusEnum = @{

	'CONSISTENT'     = "Consistent" ;
	'NOT_CONSISTENT' = "Inconsistent with group" 

}
[Array]$Script:IngressDscpClassMappingValues = @('DSCP 18, AF21','DSCP 20, AF22','DSCP 22, AF23','DSCP 26, AF31','DSCP 28, AF32','DSCP 30, AF33','DSCP 34, AF41','DSCP 36, AF42','DSCP 38, AF43','DSCP 16, CS2','DSCP 24, CS3','DSCP 32, CS4','DSCP 10, AF11','DSCP 12, AF12','DSCP 14, AF13','DSCP 8, CS1','DSCP 0, CS0','DSCP 46, EF','DSCP 40, CS5','DSCP 48, CS6','DSCP 56, CS7')
[Hashtable]$Global:UplinkSetNetworkTypeEnum               = @{

	Ethernet      = 'Ethernet';
	FibreChannel  = 'FibreChannel';
	Untagged      = 'Ethernet';
	Tunnel        = 'Ethernet'
}
[Hashtable]$Global:UplinkSetEthNetworkTypeEnum            = @{

	Ethernet = 'Tagged'
	Untagged = 'Untagged'
	Tunnel   = 'Tunnel'

}
[Array]$Script:SnmpEneTrapCategoryEnums                   = @('Other', 'PortStatus', 'PortThresholds')
[Array]$Script:SnmpFcTrapCategoryEnums                    = @('Other', 'PortStatus')
[Array]$Script:SnmpVcmTrapCategoryEnums                   = @('Legacy')
[Array]$Script:SnmpTrapSeverityEnums                      = @('Critical', 'Info', 'Major', 'Minor', 'Normal', 'Unknown', 'Warning')
#------------------------------------
#  Profile Management
#------------------------------------
$script:ServerProfilesUri                          = "/rest/server-profiles"
$script:ServerProfileTemplatesUri                  = '/rest/server-profile-templates'
$Script:ServerProfilesAvailableNetworksUri         = '/rest/server-profiles/available-networks'
$script:profileIndexListUri                        = "/rest/index/resources?sort=name:asc&category=server-profiles"
$script:profileAvailStorageSystemsUri              = '/rest/server-profiles/available-storage-systems'
[pscustomobject]$script:profileSanManageOSType     = @{
    CitrixXen = "Citrix Xen Server 5.x/6.x";
    AIX       = "AIX";
    IBMVIO    = "IBM VIO Server";
    RHEL4     = "RHE Linux (Pre RHEL 5)";
    RHEL3     = "RHE Linux (Pre RHEL 5)";
    RHEL      = "RHE Linux (5.x, 6.x)";
    RHEV      = "RHE Virtualization (5.x, 6.x)";
    VMware    = "ESX 4.x/5.x";
    Win2k3    = "Windows 2003";
    Win2k8    = "Windows 2008/2008 R2";
    Win2k12   = "Windows 2012 / WS2012 R2";
    OpenVMS   = "OpenVMS";
    Egenera   = "Egenera";
    Exanet    = "Exanet";
    Solaris9  = "Solaris 9/10";
    Solaris10 = "Solaris 9/10";
    Solaris11 = "Solaris 11";
    ONTAP     = "NetApp/ONTAP";
    OEL       = "OE Linux UEK (5.x, 6.x)";
    HPUX11iv1 = "HP-UX (11i v1, 11i v2)"
    HPUX11iv2 = "HP-UX (11i v1, 11i v2)";
    HPUX11iv3 = "HP-UX (11i v3)";
    SUSE      = "SuSE (10.x, 11.x)";
    SUSE9     = "SuSE Linux (Pre SLES 10)";
    Inform    = "InForm"
}
[Hashtable]$Script:ServerProfileConnectionTypeEnum = @{

	'ethernet-networks' = 'Ethernet';
	'network-sets'      = 'Ethernet';
	'fcoe-networks'     = 'FibreChannel';
	'fc-networks'       = 'FibreChannel'

}
[Hashtable]$Script:LogicalDiskTypeEnum             = @{

	'Sas'     = 'SasHdd';
	'Sata'    = 'SataHdd';
	'Sasssd'  = 'SasSsd';
	'Satassd' = 'SataSsd';
	'Auto'    = $Null

}
[Hashtable]$Script:FirmwareControlModeEnum         = @{

	FirmwaerOnly        = 'FirmwareOnly';
	FirmwareAndSoftware = 'FirmwareAndOSDrivers';
	FirmwareOffline     = 'FirmwareOnlyOfflineMode'

}

#------------------------------------
#  Index Search
#------------------------------------
$script:indexUri            = "/rest/index/resources" 
$script:associationsUri     = "/rest/index/associations"
$script:associationTreesUri = "/rest/index/trees"
#------------------------------------
#  Tasks
#------------------------------------
$script:allNonHiddenTaskUri = "/rest/tasks?filter=hidden=$false"
$script:taskUri             = "/rest/tasks"
$script:taskFinishedStates  = @(
	
	"Error",
	"Warning",
	"Completed",
	"Terminated",
	"Killed"
	
) 
#------------------------------------
#  Alerts and Events
#------------------------------------
$script:alertsUri              = "/rest/alerts"
$script:eventsUri              = "/rest/events"
$script:smtpNotificationConfig = "/rest/appliance/notifications/email-config"
$script:smtpTestNotification   = "/rest/appliance/notifications/send-email"
#------------------------------------
#  Licenses
#------------------------------------
$script:licensesUri = "/rest/licenses"
#------------------------------------
#  Security
#------------------------------------
$script:LoginSessionsUri            = '/rest/login-sessions'
$script:ActiveUserSessionsUri       = '/rest/active-user-sessions'
$script:UsersUri                    = '/rest/users'
$script:userRoleUri                 = "/rest/users/role"
$script:authnProvidersUri           = "/rest/logindomains"
$script:authnProviderValidatorUri   = "/rest/logindomains/validator"
$script:authnSettingsUri            = "/rest/logindomains/global-settings"
$script:authnDirectoryGroups        = "/rest/logindomains/groups"
$script:authnEgroupRoleMappingUri   = "/rest/logindomains/grouptorolemapping"
$script:applAuditLogsUri            = "/rest/audit-logs"
$script:applAuditLogDownloadUri     = "/rest/audit-logs/download"
$Script:applianceRolesUri           = '/rest/roles'
$Script:ApplianceLoginDomainDetails = '/rest/logindetails'
$Script:OrganizationalUnitPattern   = '^(?:(?:CN|OU|DC)\=[\w\s]+,)*(?:CN|OU|DC)\=[\w\s]+$'

#endregion

$script:WhiteListedURIs = @(

    $loginSessionsUri,
    $applUpdateMonitor,
    $ApplianceXApiVersionUri,
    "/ui-js/pages/",
    $applEulaStatus,
    $applEulaSave,
    ($usersUri + "/changePassword"),
    "/startstop/rest/component?fields=status",
	$ApplianceStartProgressUri,
	$ApplianceLoginDomainDetails

)

#######################################################
# Resource Objects
#

function NewObject 
{

    [CmdletBinding()]
    param
	(

		[switch]$AddStorageVolume,
		[switch]$AddStorageVolumeV3,
		[switch]$AlertFilter,
		[switch]$AllApiResponse,
		[switch]$ApplianceCSR,
		[switch]$ApplianceDebug,
		[switch]$ApplianceVersion,
		[switch]$AuthDirectory,
		[switch]$AuthDirectoryServer,
		[switch]$AuthLogin,
		[switch]$BaseTrafficClass,
		[switch]$BulkEthernetNetworks,
		[switch]$ConvertSnapshotToVol,
		[switch]$CustomBaseline,
		[switch]$CustomBaselineRestore,
		[switch]$DefaultBestEffortTrafficClass,
		[switch]$DefaultFCoELosslessQosTrafficClassifiers,
		[switch]$DefaultNoFCoELosslessQosTrafficClassifiers,
		[switch]$DirectoryGroup,
		[switch]$DownloadFileStatus,
		[switch]$EnclosureGroup,
		[switch]$EnclosureImport,
		[switch]$EphemeralStorageVolume,
		[switch]$EthernetNetwork,
		[switch]$FCNetwork,
		[switch]$FCoELossLessTrafficClass,
		[switch]$FCoENetwork,
		[switch]$GlobalSetting,
		[switch]$IDPoolRange,
		[switch]$InterconnectBayMapping,
		[switch]$LogicalInterconnectBaseline,
		[switch]$LIG,
		[switch]$LiUplinkSetObject,
		[switch]$LigUplinkSetObject,
		[switch]$LicenseKey,
		[switch]$LoginMessageObject,
		[switch]$NetworkSet,
		[switch]$PatchOperation,
		[switch]$Ping,
		[switch]$PowerDeliveryDeviceAdd,
		[switch]$ProfileConnection,
		[switch]$ProfileConnectionFcBootTarget,
		[switch]$RabbitmqCertReq,
		[switch]$QosConfiguration,
		[switch]$SanManager,
		[switch]$SanManagerConnectInfo,
		[switch]$SelfSignedCert,
		[switch]$ServerImport,
		[switch]$ServerProfile,
		[switch]$ServerProfileLocalStorage,
		[switch]$ServerProfileLocalStorageLogicalDrive,
		[switch]$ServerProfileStorageVolume,
		[switch]$ServerProfileTemplate,
		[switch]$ServerProfileTemplateLocalStorage,
		[switch]$SmtpConfig,
		[switch]$SnmpConfig,
		[switch]$SnmpTrapDestination,
		[switch]$StoragePath,
		[switch]$StorageSystemCredentials,
		[switch]$StorageSystemManagedPort,
		[switch]$StorageVolume,
		[switch]$StorageVolumeTemplate,
		[switch]$UpdateAlert,
		[switch]$UplinkSetLocation,
		[switch]$UplinkSetLocationEntry,
		[switch]$UplinkSetLogicalLocation,
		[switch]$UplinkSetLogicalLocationEntry,
		[switch]$UnmanagedDevice,
		[switch]$UserAccount,
		[switch]$VcMigration,
		[switch]$VolSnapshot

	)

	Begin
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

	}

	Process
	{

		switch($PSBoundParameters.Keys)
		{

			'SnmpConfig'
			{

				Return [PSCustomObject]@{

					type              = 'snmp-configuration'
					readCommunity     = 'public';
					enabled           = $true;
					systemContact     = $null;
					snmpAccess        = New-Object System.Collections.ArrayList;
					trapDestinations  = New-Object System.Collections.ArrayList

				}
			
			}

			'SnmpTrapDestination'
			{

				Return [PSCustomObject]@{

					trapDestination    = $null;
					communityString    = $null;
					trapFormat         = $null;
					trapSeverities     = New-Object System.Collections.ArrayList;
					vcmTrapCategories  = New-Object System.Collections.ArrayList;
					enetTrapCategories = New-Object System.Collections.ArrayList;
					fcTrapCategories   = New-Object System.Collections.ArrayList;

				}

			}

			'PatchOperation'
			{

				Return [PSCustomObject]@{

					op    = $null;
					path  = $null;
					value = $null

				}

			}

			'CustomBaseline'
			{

				Return [PSCustomObject]@{

					 baselineUri        = $null;
					 hotfixUris         = New-Object System.Collections.ArrayList;
					 customBaselineName = $null
					
				}

			}

			'LoginMessageObject'
			{

				Return [PSCustomObject]@{

					Message             = $null;
					Acknowledgment      = $null;
					ApplianceConnection = $null

				}

			}

			'ConvertSnapshotToVol'
			{

				Return [PSCustomObject]@{

					type                   = 'AddStorageVolumeV3';
					name                   = $null;
					description            = $null;
					snapshotPoolUri        = $null;
					provisioningParameters = [PSCustomObject] @{

						storagePoolUri = $null;
						shareable      = $false

					};

					snapshotUri = $null
				  
				}

			}

			'VolSnapshot'
			{

				Return [PSCustomObject]@{

					type = 'Snapshot';
					name = '{volumeName}_{timestamp}';
					description = $null

				}

			}

			'LogicalInterconnectBaseline'
			{

				Return [PsCustomObject]@{ 
			
					command                 = 'Update'; 
					ethernetActivationType  = 'OddEven';
					ethernetActivationDelay = 5;
					fcActivationType        = 'OddEven';
					fcActivationDelay       = 5;
					sppUri                  = $null; 
					force                   = $false
		
				}

			}

			'StoragePath'
			{

				Return [PSCustomObject]@{

					storageTargetType = "Auto";
                    storageTargets = New-Object System.Collections.ArrayList;
                    connectionId = 1;
                    isEnabled = $true

				}

			}

			'LicenseKey'
			{

				Return [PsCustomObject] @{

	        		type = "License";
	        		key  = $null

	    		}

			}

			'UnmanagedDevice'
			{

				Return [PSCustomObject]@{ 
				
					name           = [string]$null; 
					model          = [string]$null; 
					height         = [int]1; 
					mac            = [string]$null;
					ipv4Address    = [string]$null;
					ipv6Address    = [string]$null;
					maxPwrConsumed = [int]100 
				
				}

			}

			'RabbitmqCertReq'
			{

				Return [PSCustomObject] @{
        
					commonName = 'default';
					type       = 'RabbitMqClientCertV2'
            
				}

			}

			'AuthLogin'
			{

				Return [PSCustomObject] @{
        
					userName        = $null;
					password        = $null;
					authLoginDomain = $null
            
				}

			}

			'DownloadFileStatus'
			{

				Return [PSCustomObject]@{

					status              = $null;
					file                = $null;
					ApplianceConnection = $null

				}

			}

			'GlobalSetting'
			{

				Return [PSCustomObject]@{
					
					type  = "SettingV2"; 
					name  = $null; 
					value = $null
				
				}

			}

			'StorageVolumeTemplate'
			{

				Return [PSCustomObject]@{
					
					type             = "StorageVolumeTemplateV3"
					name             = $null;
					description      = $null;
					snapshotPoolUri  = $null;
					storageSystemUri = $null;
					provisioning     = [PSCustomObject]@{
                    
						capacity        = 10737418240;
                        provisionType   = 'Full';
                        shareable       = $false;
                        storagePoolUri  = $null
                    
					}
            
                }

			}

			'CustomBaselineRestore'
			{

				Return [PSCustomObject]@{

					baselineUri        = $null;
					hotfixUris         = New-Object System.Collections.ArrayList;
					customBaselineName = $null

				}

			}

			'SmtpConfig'
			{

				Return [PSCustomObject]@{
        
				    type               = "EmailNotification";
				    senderEmailAddress = $null;
				    password           = $null;
				    smtpServer         = $null;
				    smtpPort           = 1;
				    alertEmailDisabled = $false
				
				}

			}

			'UpdateAlert'
			{

				Return [PSCustomObject] @{ 
			
					alertState     = $null;
					assignedToUser = $null;
					notes          = $null;
					eTag           = $null
				
				} 

			}

			'SelfSignedCert'
			{
			
				Return [PSCustomObject]@{

					type               = "CertificateDtoV2";
					country            =  $null;
					state              =  $null;
					locality           =  $null;
					organization       =  $null;
					commonName         =  $null;
					organizationalUnit =  $null;
					alternativeName    =  $null;
					contactPerson      =  $null;
					email              =  $null;
					surname            =  $null;
					givenName          =  $null;
					initials           =  $null;
					dnQualifier        =  $null

				}	
			
			}

			'ApplianceCSR'
			{

				Return [PSCustomObject]@{

					type               = "CertificateDtoV2";
					country            =  $null;
					state              =  $null;
					locality           =  $null;
					organization       =  $null;
					commonName         =  $null;
					organizationalUnit =  $null;
					alternativeName    =  $null;
					contactPerson      =  $null;
					email              =  $null;
					surname            =  $null;
					givenName          =  $null;
					initials           =  $null;
					dnQualifier        =  $null;
					unstructuredName   =  $null;
					challengePassword  =  $null

				}	

			}

			'AuthDirectory'
			{

				Return [PSCustomObject]@{
					
					type                = 'LoginDomainConfigVersion200'
					authProtocol        = 'AD';
					baseDN              = $null;
					orgUnits            = New-Object System.Collections.ArrayList
					userNamingAttribute = 'CN';
					name                = $null;
					credential          = [PSCustomObject]@{
						
						userName = $null; 
						password = $null
					
					};
					directoryServers    = New-Object System.Collections.ArrayList;

				}

			}

			'DirectoryGroup'
			{

				Return [PSCustomObject]@{

					type                = 'Group2RolesMappingPerGroupValidationDto';
					group2rolesPerGroup = [PSCustomObject]@{
					
						type        = 'Group2RolesMappingPerGroupDto';
						loginDomain = $null;
						egroup      = $null;
						roles       = New-Object System.Collections.ArrayList;

					}
					credentials = [PSCustomObject]@{

						userName = $null;
						password = $null

					}

				}

			}

			'AuthDirectoryServer'
			{

				Return [PSCustomObject]@{

					type                                 = 'LoginDomainDirectoryServerInfoDto'
					directoryServerCertificateBase64Data = $null;
					directoryServerIpAddress             = $null;
					directoryServerSSLPortNumber         = "636";

				}

			}

			'IDPoolRange'
			{

				Return [PsCustomObject]@{ 

					type          = "Range"; 
					rangeCategory = "CUSTOM";
					startAddress  = $null; 
					endAddress    = $null

				}

			}

			'UserAccount'
			{

				Return [PsCustomObject]@{

				    type         = "UserAndRoles";
				    userName     = $null; 
				    fullName     = $null; 
				    password     = $null; 
				    emailAddress = $emailAddress; 
				    officePhone  = $null; 
				    mobilePhone  = $null; 
				    enabled      = $True;
				    roles        = $null

				}

			}

			'PowerDeliveryDeviceAdd'
			{

				Return [PSCustomObject]@{

				    hostname = $null;
				    username = $null;
				    password = $null;
				    force    = $null

				}

			}
			
			'ApplianceDebug'
			{

				Return [PSCustomObject]@{

				    scope      = $null;
				    loggerName = $null;
				    level      = $null

				}

			}

			'AlertFilter'
			{

				Return [PSCustomObject]@{

				    disabled        = $False;
				    filter          = $null;
				    displayFilter   = $null;
				    userQueryFilter = $null;
				    emails          = $null;

				}

			}

			'ServerProfile'
            {

                Return [PSCustomObject]@{

					type                  = "ServerProfileV5"; 
					name                  = $null; 
					description           = $null; 
					affinity              = $null;
					hideUnusedFlexNics    = $true;
					bios                  = [PSCustomObject]@{

						manageBios         = $false;
						overriddenSettings = $null

					}; 
					firmware                 = [PSCustomObject]@{

						manageFirmware       = $false;
						firmwareBaselineUri  = $null;
						forceInstallFirmware = $false;
						firmwareInstallType  = 'FirmwareAndOSDrivers'
                            
					};
					boot           = [PSCustomObject]@{
                       
						manageBoot = $false; 
						order      = New-Object System.Collections.ArrayList
                           
					};
					bootMode                 = $null;
					localStorage             = [PSCustomObject]@{

						controllers = New-Object System.Collections.ArrayList; 

					}
					serialNumberType         = 'Virtual'; 
					macType                  = 'Virtual';
					wwnType                  = 'Virtual';
					connections              = New-Object System.Collections.ArrayList; 
					serialNumber             = $null;
					serverHardwareUri        = $null;
					serverHardwareTypeUri    = $null;
					serverProfileTemplateUri = $null;
					enclosureGroupUri        = $null;
					enclosureUri             = $null;
					sanStorage               = $null;
					uuid                     = $null;
                }

            }

			'ServerProfileTemplate'
			{

				Return [PSCustomObject]@{

					type                     = "ServerProfileTemplateV1"; 
					name                     = $null; 
					description              = $null; 
					serverProfileDescription = $null;
					affinity                 = $null;
					hideUnusedFlexNics       = $true;
					bios                     = [PSCustomObject]@{

						manageBios         = $false;
						overriddenSettings = $null

					}; 
					firmware                 = [PSCustomObject]@{

						manageFirmware       = $false;
						firmwareBaselineUri  = $null;
						forceInstallFirmware = $false;
						firmwareInstallType  = 'FirmwareAndOSDrivers'
                                    
					};
					boot                     = [PSCustomObject]@{
                               
						manageBoot = $false; 
						order      = New-Object System.Collections.ArrayList
                                   
					};
					bootMode                 = $null;
					localStorage             = [PSCustomObject]@{

						controllers = New-Object System.Collections.ArrayList; 

					}
					serialNumberType         = 'Virtual'; 
					macType                  = 'Virtual';
					wwnType                  = 'Virtual';
					connections              = New-Object System.Collections.ArrayList; 
					serverHardwareTypeUri    = $null;
					enclosureGroupUri        = $null;
					sanStorage               = $null;

				}

			} 

			'ServerProfileTemplateLocalStorage'
			{

				Return [PSCustomObject]@{

					slotNumber          = '0';
					managed             = $true;
					mode                = 'RAID'
				    initialize          = $false;
				    logicalDrives       = New-Object System.Collections.ArrayList

				}

			}

			'ServerProfileLocalStorage'
			{

				Return [PSCustomObject]@{

					slotNumber          = '0';
					importConfiguration = $false;
					managed             = $true;
					mode                = 'RAID'
				    initialize          = $false;
				    logicalDrives       = New-Object System.Collections.ArrayList

				}

			}

			'ServerProfileLocalStorageLogicalDrive'
			{

				Return [PSCustomObject]@{ 

					driveName         = '';
				    bootable          = $false;
				    raidLevel         = $null;
					numPhysicalDrives = 0;
					driveTechnology   = $null
				
				}

			}

			'EnclosureImport'
			{

				Return [PSCustomObject]@{

                    hostname             = $null;
                    username             = $null;
                    password             = $null;
                    licensingIntent      = 'OneVeiw';
					force                = $false;
                    enclosureGroupUri    = $null;
                    firmwareBaselineUri  = $null;
                    forceInstallFirmware = $false;
                    updateFirmwareOn     = "EnclosureOnly";
					state                = $null
                
				}

			}

			'ServerImport'
			{

				Return [PSCustomObject]@{

                    hostname             = $null;
                    username             = $null;
                    password             = $null;
					force                = $false;
                    licensingIntent      = 'OneVeiw';
					configurationState   = $null
                
				}

			}

			'StorageSystemCredentials'
			{

				Return [PSCustomObject]@{
					
					ip_hostname = $null; 
					username    = $null; 
					password    = $null
				
				}

			}

			'StorageSystemManagedPort'
			{

				Return [PSCustomObject]@{

					type                = "StorageTargetPortV3"; 
					portName            = $null; 
					name                = $null;
					expectedNetworkUri  = $null; 
					expectedNetworkName = $null;
					actualNetworkUri    = $null; 
					actualNetworkSanUri = $null;
					portWwn             = $null; 
					groupName           = $null; 
					label               = $null;
					protocolType       = 'FC'

				}

			}

			'StorageVolume'
			{

				Return [PSCustomObject]@{

				   isPermanent = $true;
				   name        = $null;
				   description = $null;
				   type        = "StorageVolume";
				   templateUri = $null;
				   provisioningParameters = @{

				       storagePoolUri    = $null;
				       requestedCapacity = '107374182400';
				       provisionType     = "Thin";
				       shareable         = $false

				   }

        		}

			}

			'ServerProfileStorageVolume'
			{

				Return [PsCustomObject]@{
            
				    id                     = 1;
				    volumeUri              = $null;
				    volumeStoragePoolUri   = $null;
				    volumeStorageSystemUri = $null;
				    lunType                = 'Auto';
				    storagePaths           = New-Object System.Collections.ArrayList;
				    ApplianceConnection    = $null;

				}   

			}

			'AddStorageVolume'
			{

				Return [PSCustomObject]@{

					type                   = "AddStorageVolumeV2";
					name                   = $null;
					description            = $null;
					storageSystemUri       = $null;
					wwn                    = $null;
					provisioningParameters = [PSCustomObject]@{

						shareable = $false
					}

				}

			}

			'AddStorageVolumeV3'
			{

				Return [PSCustomObject]@{

					type                    = 'AddStorageVolumeV3';
					name                    = $null;
					description             = $null;
					storageSystemUri        = $null;
					storageSystemVolumeName = $null;
					provisioningParameters  = [PSCustomObject]@{

						shareable = $false
					
					}
				
				}

			}

			'EphemeralStorageVolume'
			{

				Return [PsCustomObject]@{
            
					id                             = 1;
					lun                            = $null;
					lunType                        = 'Auto';
					volumeStoragePoolUri           = $null;
					volumeStorageSystemUri         = $null;
					volumeName                     = $null;
					volumeProvisionType            = 'Thin';
					volumeProvisionedCapacityBytes = '10737418240';
					permanent                      = $true;
					volumeShareable                = $false;
					ApplianceConnection            = $null;
					storagePaths                   = New-Object System.Collections.ArrayList

				}

			}

			'ProfileConnection'
			{

				Return [PSCustomObject]@{
            
				    id            = 1;
					functionType  = 'Ethernet';
				    name          = $null;
				    portId        = $null; 
				    networkUri    = $null; 
				    requestedMbps = 2000; 
				    boot          = [PSCustomObject]@{

				        priority = 'NotBootable'
						targets  = New-Object System.Collections.ArrayList

				    };
					macType             = 'Virtual';
					mac		            = $null;
					wwpnType            = 'Virtual';
					wwnn	            = $null;
					wwpn	            = $null;
				    ApplianceConnection = $null

				}

			}

			'ProfileConnectionFcBootTarget'
			{

				Return [PSCustomObject]@{

                    arrayWwpn = $null;
                    lun       = $null

                }

			}

			'SanManager'
			{

				Return [PSCustomObject]@{
			
					"connectionInfo" = New-Object System.Collections.ArrayList
					
				}

			}

			'SanManagerConnectInfo'
			{

				Return [PSCustomObject]@{
				
					name  = $null;
					Value = $null
				
				}

			}

			'EthernetNetwork'
			{

				Return [pscustomobject]@{
						    
					type                = "ethernet-networkV3"; 
					vlanId              = 1; 
					ethernetNetworkType = 'Tagged'; 
					purpose             = 'General'; 
					name                = $null; 
					smartLink           = $false;
					privateNetwork      = $false

				}

			}

			'BulkEthernetNetworks'
			{

				Return [pscustomobject]@{

					type           = "bulk-ethernet-network"; 
					vlanIdRange    = $null; 
					purpose        = 'General'; 
					namePrefix     = $null; 
					smartLink      = $false; 
					privateNetwork = $false;
					bandwidth      = @{
							        
						typicalBandwidth = 1;
						maximumBandwidth = 10000
							        
					}

				}

			}

			'FCNetwork'
			{

				[pscustomobject]@{

					type                    = "fc-networkV2"; 
					name                    = $Name; 
					linkStabilityTime       = 30; 
					autoLoginRedistribution = $true; 
					fabricType              = 'FabricAttach'; 
					connectionTemplateUri   = $null;
					managedSanUri           = $null
					    
				}

			}

			'FCoENetwork'
			{

				Return [pscustomobject]@{
					    
					type                  = "fcoe-network"; 
					name                  = $null; 
					vlanId                = 1; 
					connectionTemplateUri = $null;
					managedSanUri         = $null

				}
				
			}

			'NetworkSet'
			{

				Return [PSCustomObject] @{

					type             = "network-set"; 
					name             = $null; 
					networkUris      = New-Object System.Collections.ArrayList; 
					nativeNetworkUri = $null; 
	    		
				}

			}

			'EnclosureGroup'
			{

				Return [PSCustomObject]@{

					type                        = "EnclosureGroupV200";
					name                        = $null;
					enclosureTypeUri            = '/rest/enclosure-types/c7000'; 
					stackingMode                = 'Enclosure';
					interconnectBayMappingCount = 8;
					interconnectBayMappings     = [System.Collections.ArrayList]@();
					configurationScript         = $null;
					powerMode                   = 'RedundantPowerFeed';
					ipRangeUris                 = [System.Collections.ArrayList]@();
					enclosureCount              = 1

				}

			}

			'InterconnectBayMapping'
			{

				Return [PSCustomObject]@{
					
					interconnectBay             = 1; 
					logicalInterconnectGroupUri = $null
				
				}

			}

			'ApplianceVersion'
			{

				Return [PSCustomObject]@{

					applianceName    = $null;
					softwareVersion  = $null; 
					major            = $null;
					minor            = $null;
					xapiVersion      = $null;
					modelNumber      = $null

				}

			}

			'AllApiResponse'
			{

				Return [PSCustomObject]@{

					type        = [string]$null;
					nextPageUri = [string]$null;
					start       = [int]0;
					prevPageUri = [string]$null;
					total       = [int]0;
					count       = [int]0;
					members     = New-Object System.Collections.ArrayList;
					eTag        = [string]$null;
					created     = [string]$null;
					modified    = [string]$null;
					category    = [string]$null;
					uri         = [string]$null

				}

			}

			#Default LIG Object
			"LIG"
			{
			
				Return [PSCustomObject]@{
					name                    = $Null;
					uplinkSets              = New-Object System.Collections.ArrayList; 
					interconnectMapTemplate = [PSCustomObject]@{interconnectMapEntryTemplates = New-Object System.Collections.ArrayList};
					internalNetworkUris     = New-Object System.Collections.ArrayList; 
					ethernetSettings = @{

						type                        = "EthernetInterconnectSettingsV3";
						enableIgmpSnooping          = $false;
						igmpIdleTimeoutInterval     = 60; 
						enableFastMacCacheFailover  = $true;
						macRefreshInterval          = 260;
						enableNetworkLoopProtection = $false;
						enablePauseFloodProtection  = $false
				        
					};
					fcoeSettings     = @{
						
						fcoeMode = "NotApplicable"
						
					};
					snmpConfiguration       = $Null;
					qosConfiguration        = [PSCustomObject]@{
						
						type                     = "qos-aggregated-configuration";
						activeQosConfig          = $Null;
						inactiveFCoEQosConfig    = $null;
						inactiveNonFCoEQosConfig = $null

							
					};
					stackingMode            = "Enclosure";
					enclosureType           = "C7000"
					type                    = "logical-interconnect-groupV3"
				}

			}
			
			#Default qosConfiguration Object for LIG
			"QosConfiguration"
			{
				
				Return [PSCustomObject]@{
				
					type                       = "QosConfiguration";
					configType                 = "Passthrough";
					qosTrafficClassifiers      = [System.Collections.ArrayList]@()
					uplinkClassificationType   = $Null; #Leave Null to support default 'Passthrough'
					downlinkClassificationType = $Null; #Leave Null to support default 'Passthrough'
				
				}

			}

			#Default With FCoE Lossless Traffic Classifiers Object
			"DefaultFCoELosslessQosTrafficClassifiers"
			{
			
				Return @(

					#1
					[PSCustomObject]@{ 
					qosTrafficClass = [PSCustomObject]@{
			
			            maxBandwidth     = 100;
			            bandwidthShare   = "65";
			            egressDot1pValue = 0;
			            realTime         = $false;
			            className        = "Best effort";
			            enabled          = $true;
			
			        };
							
					qosClassificationMapping = [PSCustomObject]@{
			
						dot1pClassMapping = [System.Collections.ArrayList]@(1,0);
			            dscpClassMapping  = [System.Collections.ArrayList]@(
			
							"DSCP 10, AF11",
							"DSCP 12, AF12",
							"DSCP 14, AF13",
							"DSCP 8, CS1",
							"DSCP 0, CS0"
			
						)
			
					}
			
				},
							
					#2
					[PSCustomObject]@{ 
					qosTrafficClass = [PSCustomObject]@{
			
						maxBandwidth     = 100;
						bandwidthShare   = "0";
						egressDot1pValue = 0;
						realTime         = $false;
						className        = "Class1";
						enabled          = $false;
			
			        };
								
					qosClassificationMapping = [PSCustomObject]@{
						
						dot1pClassMapping = New-Object System.Collections.ArrayList;
						dscpClassMapping  = New-Object System.Collections.ArrayList
							
					}
			
				},
				
					#3
					[PSCustomObject]@{ 
					qosTrafficClass = [PSCustomObject]@{
			
			            maxBandwidth     = 100;
			            bandwidthShare   = "0";
			            egressDot1pValue = 0;
			            realTime         = $false;
			            className        = "Class2";
			            enabled          = $false;
			
			        };
								
					qosClassificationMapping = [PSCustomObject]@{
						
						dot1pClassMapping = New-Object System.Collections.ArrayList;
						dscpClassMapping  = New-Object System.Collections.ArrayList
							
					}
			
				},
				
					#4
					[PSCustomObject]@{ 
					qosTrafficClass = [PSCustomObject]@{
			
			            maxBandwidth     = 100;
			            bandwidthShare   = "0";
			            egressDot1pValue = 0;
			            realTime         = $false;
			            className        = "Class3";
			            enabled          = $false;
			
			        };
								
					qosClassificationMapping = [PSCustomObject]@{
						
						dot1pClassMapping = New-Object System.Collections.ArrayList;
						dscpClassMapping  = New-Object System.Collections.ArrayList
							
					}
			
				},
				
					#5
					[PSCustomObject]@{ 
					qosTrafficClass = [PSCustomObject]@{
			
			            maxBandwidth     = 100;
			            bandwidthShare   = "0";
			            egressDot1pValue = 0;
			            realTime         = $false;
			            className        = "Class4";
			            enabled          = $false;
			
			        };
								
					qosClassificationMapping = [PSCustomObject]@{
						
						dot1pClassMapping = New-Object System.Collections.ArrayList;
						dscpClassMapping  = New-Object System.Collections.ArrayList
							
					}
			
				},
				
					#6
					[PSCustomObject]@{ 
					qosTrafficClass = [PSCustomObject]@{
			
			            maxBandwidth     = 100;
			            bandwidthShare   = "fcoe";
			            egressDot1pValue = 3;
			            realTime         = $false;
			            className        = "FCoE lossless";
			            enabled          = $true;
			
			        };					
							
					qosClassificationMapping = [PSCustomObject]@{
			
						dot1pClassMapping = [System.Collections.ArrayList]@(3);
						dscpClassMapping  = [System.Collections.ArrayList]@()
			
					}
			
				},
				
					#7
					[PSCustomObject]@{ 
					qosTrafficClass = [PSCustomObject]@{
			
			            maxBandwidth     = 100;
			            bandwidthShare   = "25";
			            egressDot1pValue = 2;
			            realTime         = $false;
			            className        = "Medium";
			            enabled          = $true;
			
			        };
								
					qosClassificationMapping = [PSCustomObject]@{
			
						dot1pClassMapping = [System.Collections.ArrayList]@(4,3,2);
						dscpClassMapping  = [System.Collections.ArrayList]@(
			
							"DSCP 18, AF21",
							"DSCP 20, AF22",
							"DSCP 22, AF23",
							"DSCP 26, AF31",
							"DSCP 28, AF32",
							"DSCP 30, AF33",
							"DSCP 34, AF41",
							"DSCP 36, AF42",
							"DSCP 38, AF43",
							"DSCP 16, CS2",
							"DSCP 24, CS3",
							"DSCP 32, CS4"
			
						)
			
					}
			
				},
				
					#8
					[PSCustomObject]@{ 
					qosTrafficClass = [PSCustomObject]@{
			
			            maxBandwidth     = 10;
			            bandwidthShare   = "10";
			            egressDot1pValue = 5;
			            realTime         = $true;
			            className        = "Real time";
			            enabled          = $true;
			
			        };
								
					qosClassificationMapping = [PSCustomObject]@{
			
						dot1pClassMapping = [System.Collections.ArrayList]@(5,6,7);
			            dscpClassMapping  = [System.Collections.ArrayList]@(
			
							"DSCP 46, EF",
							"DSCP 40, CS5",
							"DSCP 48, CS6",
							"DSCP 56, CS7"
			
						)
			
					}
			
				}
				
				)

			}

			#Default With No FCoE Lossless Traffic Classifiers Object
			"DefaultNoFCoELosslessQosTrafficClassifiers" 
			{
				
				Return @(

					#1
					[PSCustomObject]@{ 
						qosTrafficClass = [PSCustomObject]@{

						    maxBandwidth     = 100;
						    bandwidthShare   = "65";
						    egressDot1pValue = 0;
						    realTime         = $false;
						    className        = "Best effort";
						    enabled          = $true;

						};
								
						qosClassificationMapping = [PSCustomObject]@{

							dot1pClassMapping = [System.Collections.ArrayList]@(1,0);
						    dscpClassMapping  = [System.Collections.ArrayList]@(

								"DSCP 10, AF11",
								"DSCP 12, AF12",
								"DSCP 14, AF13",
								"DSCP 8, CS1",
								"DSCP 0, CS0"

							)

						}

					},
											
					#2
					[PSCustomObject]@{ 
						qosTrafficClass = [PSCustomObject]@{

							maxBandwidth     = 100;
							bandwidthShare   = "0";
							egressDot1pValue = 0;
							realTime         = $false;
							className        = "Class1";
							enabled          = $false;

					    };
									
						qosClassificationMapping = [PSCustomObject]@{
							
							dot1pClassMapping = New-Object System.Collections.ArrayList;
							dscpClassMapping  = New-Object System.Collections.ArrayList
								
						}

					},
								
					#3
					[PSCustomObject]@{ 
						qosTrafficClass = [PSCustomObject]@{

					        maxBandwidth     = 100;
					        bandwidthShare   = "0";
					        egressDot1pValue = 0;
					        realTime         = $false;
					        className        = "Class2";
					        enabled          = $false;

					    };
									
						qosClassificationMapping = [PSCustomObject]@{
							
							dot1pClassMapping = New-Object System.Collections.ArrayList;
							dscpClassMapping  = New-Object System.Collections.ArrayList
								
						}

					},
								
									#4
									[PSCustomObject]@{ 
						qosTrafficClass = [PSCustomObject]@{

					        maxBandwidth     = 100;
					        bandwidthShare   = "0";
					        egressDot1pValue = 0;
					        realTime         = $false;
					        className        = "Class3";
					        enabled          = $false;

					    };
									
						qosClassificationMapping = [PSCustomObject]@{
							
							dot1pClassMapping = New-Object System.Collections.ArrayList;
							dscpClassMapping  = New-Object System.Collections.ArrayList
								
						}

					},
								
					#5
					[PSCustomObject]@{ 
						qosTrafficClass = [PSCustomObject]@{

					        maxBandwidth     = 100;
					        bandwidthShare   = "0";
					        egressDot1pValue = 0;
					        realTime         = $false;
					        className        = "Class4";
					        enabled          = $false;

					    };
									
						qosClassificationMapping = [PSCustomObject]@{
							
							dot1pClassMapping = New-Object System.Collections.ArrayList;
							dscpClassMapping  = New-Object System.Collections.ArrayList
								
						}

					},
								
					#6
					[PSCustomObject]@{ 
						qosTrafficClass = [PSCustomObject]@{

					        maxBandwidth     = 100;
					        bandwidthShare   = "0";
					        egressDot1pValue = 0;
					        realTime         = $false;
					        className        = "Class5";
					        enabled          = $false;

					    };					
								
						qosClassificationMapping = [PSCustomObject]@{
							
							dot1pClassMapping = New-Object System.Collections.ArrayList;
							dscpClassMapping  = New-Object System.Collections.ArrayList
								
						}

					},
								
					#7
					[PSCustomObject]@{ 
						qosTrafficClass = [PSCustomObject]@{

					        maxBandwidth     = 100;
					        bandwidthShare   = "25";
					        egressDot1pValue = 2;
					        realTime         = $false;
					        className        = "Medium";
					        enabled          = $true;

					    };
									
						qosClassificationMapping = [PSCustomObject]@{

							dot1pClassMapping = [System.Collections.ArrayList]@(4,3,2);
							dscpClassMapping  = [System.Collections.ArrayList]@(

								"DSCP 18, AF21",
								"DSCP 20, AF22",
								"DSCP 22, AF23",
								"DSCP 26, AF31",
								"DSCP 28, AF32",
								"DSCP 30, AF33",
								"DSCP 34, AF41",
								"DSCP 36, AF42",
								"DSCP 38, AF43",
								"DSCP 16, CS2",
								"DSCP 24, CS3",
								"DSCP 32, CS4"

							)

						}

					},
								
					#8
					[PSCustomObject]@{ 
						qosTrafficClass = [PSCustomObject]@{

					        maxBandwidth     = 10;
					        bandwidthShare   = "10";
					        egressDot1pValue = 5;
					        realTime         = $true;
					        className        = "Real time";
					        enabled          = $true;

					    };
									
						qosClassificationMapping = [PSCustomObject]@{

							dot1pClassMapping = [System.Collections.ArrayList]@(5,6,7);
					        dscpClassMapping  = [System.Collections.ArrayList]@(

								"DSCP 46, EF",
								"DSCP 40, CS5",
								"DSCP 48, CS6",
								"DSCP 56, CS7"

							)

						}

					}
				
				)

			}

			#Default BestEffort Traffic Class
			"DefaultBestEffortTrafficClass"
			{
				
				Return [PSCustomObject]@{ 

					qosTrafficClass = [PSCustomObject]@{

					    maxBandwidth     = 100;
					    bandwidthShare   = "65";
					    egressDot1pValue = 0;
					    realTime         = $false;
					    className        = "Best effort";
					    enabled          = $true;

					};
								
					qosClassificationMapping = [PSCustomObject]@{

						dot1pClassMapping = [System.Collections.ArrayList]@(1,0);
					    dscpClassMapping  = [System.Collections.ArrayList]@(

							"DSCP 10, AF11",
							"DSCP 12, AF12",
							"DSCP 14, AF13",
							"DSCP 8, CS1",
							"DSCP 0, CS0"

						)

					}

				}

			}

			#FCoE Lossless Traffic Class
			"FCoELossLessTrafficClass"
			{

				Return [PSCustomObject]@{ 

					qosTrafficClass = [PSCustomObject]@{
				
				        maxBandwidth     = 100;
				        bandwidthShare   = "fcoe";
				        egressDot1pValue = 3;
				        realTime         = $false;
				        className        = "FCoE lossless";
				        enabled          = $true;
				
				    };					
								
					qosClassificationMapping = [PSCustomObject]@{
				
						dot1pClassMapping = [System.Collections.ArrayList]@(3);
						dscpClassMapping  = New-Object System.Collections.ArrayList
				
					}
				
				}

			}
			
			#Basic, not enabled Traffic Class
			"BaseTrafficClass"
			{
				
				Return [PSCustomObject]@{ 
					
					qosTrafficClass = [PSCustomObject]@{
					
						maxBandwidth     = 100;
						bandwidthShare   = "0";
						egressDot1pValue = 0;
						realTime         = $false;
						className        = "Class";
						enabled          = $false;
					
					};
									
					qosClassificationMapping = [PSCustomObject]@{
							
						dot1pClassMapping = New-Object System.Collections.ArrayList;
						dscpClassMapping  = New-Object System.Collections.ArrayList
							
					}

				}

			}

			"Ping"
			{

				Return [PSCustomObject]@{

					type        = "PingDto";
					address     = "example.com";
					noOfPackets = 5

				}

			}

			"liUplinkSetObject"
			{
			
				Return [PSCustomObject]@{

					type                   = "uplink-setV3";
					name                   = $Name; 
					networkUris            = New-Object System.Collections.ArrayList;
					portConfigInfos        = New-Object System.Collections.ArrayList;
					networkType            = $null; 
					primaryPortLocation    = $null;
					fcNetworkUris          = New-Object System.Collections.ArrayList;
					fcoeNetworkUris        = New-Object System.Collections.ArrayList;				
					connectionMode         = $null; 
					ethernetNetworkType    = $null; 
					lacpTimer              = 'Short';
					logicalInterconnectUri = $null

				}
			
			}

			'ligUplinkSetObject'
			{

				Return [PSCustomObject]@{

					logicalPortConfigInfos = New-Object System.Collections.ArrayList;
					networkUris            = New-Object System.Collections.ArrayList;
					name                   = $null; 
					mode                   = 'Auto'; 
					networkType            = "Ethernet";
					primaryPort            = $null;
					ethernetNetworkType    = $null; 
					lacpTimer              = 'Short'

				}

			}

			'UplinkSetLogicalLocation'
			{
				
				Return [PSCustomObject]@{
					
					desiredSpeed    = $null;
					logicalLocation = [PSCustomObject]@{
						                
						locationEntries =  @(
						
							[PSCustomObject]@{
						                    
								type          = "Enclosure";
								relativeValue = 1

							},
							[PSCustomObject]@{

								type          = "Bay";
								relativeValue = 1
						
							},
							[PSCustomObject]@{

								type          = "Port";
								relativeValue = 1
						
							}

						)
					
					}
					
				}

			}

			'UplinkSetLocation'
			{
				
				Return [PSCustomObject]@{

					desiredSpeed = $null;
					location     = [PSCustomObject]@{
						                
						locationEntries = @(
                        
                            [PSCustomObject]@{
						                    
						        type  = "Enclosure";
						        value = 1

						    },
						    [PSCustomObject]@{

						        type  = "Bay";
						        value = 1

						    },
						    [PSCustomObject]@{

						        type  = "Port";
						        value = 1

						    }

                        )

					}
					
				}

			}

			'UplinkSetLogicalLocationEntry'
			{

				Return [PSCustomObject]@{
						                    
					type          = $Null;
					relativeValue = 1

				}

			}
				
			'UplinkSetLocationEntry'
			{

				Return [PSCustomObject]@{
						                    
					type  = $Null;
					value = 1

				}

			}

            'vcMigration'
            {

                Return [PSCustomObject]@{

					enclosureGroupUri           = $Null;
					logicalInterconnectGroupUri = $Null;
					iloLicenseType              = $licensingIntent;
					credentials                 = [PSCustomObject]@{
			    				            
						 oaIpAddress            = $OAIPAddress;
						 oaUsername             = $OAUserName;
						 oaPassword             = $OAPassword;
						 vcmUsername            = $VCMUserName;
						 vcmPassword            = $VCMPassword;
						 type                   = "EnclosureCredentials"
                				            
					};				            
					category                    = "migratable-vc-domains";
					type                        = "migratable-vc-domains"

                }

            }

		}

	}

}

#######################################################
# Basic Support Functions
#

function New-ErrorRecord 
{

    <#  
    .Synopsis
    Creates an custom ErrorRecord that can be used to report a terminating or non-terminating error.  
    
    .Description
    Creates an custom ErrorRecord that can be used to report a terminating or non-terminating error.  
    
    .Parameter Exception      
    The Exception that will be associated with the ErrorRecord. 
     
    .Parameter ErrorID      
    A scripter-defined identifier of the error. This identifier must be a non-localized string for a specific error type.  
    
    .Parameter ErrorCategory      
    An ErrorCategory enumeration that defines the category of the error.  The supported Category Members are (from: http://msdn.microsoft.com/en-us/library/system.management.automation.errorcategory(v=vs.85).aspx) :
        
        • AuthenticationError - An error that occurs when the user cannot be authenticated by the service. This could mean that the credentials are invalid or that the authentication system is not functioning properly. 
        • CloseError - An error that occurs during closing. 
        • ConnectionError - An error that occurs when a network connection that the operation depends on cannot be established or maintained. 
        • DeadlockDetected - An error that occurs when a deadlock is detected. 
        • DeviceError - An error that occurs when a device reports an error. 
        • FromStdErr - An error that occurs when a non-Windows PowerShell command reports an error to its STDERR pipe. 
        • InvalidArgument - An error that occurs when an argument that is not valid is specified. 
        • InvalidData - An error that occurs when data that is not valid is specified. 
        • InvalidOperation - An error that occurs when an operation that is not valid is requested. 
        • InvalidResult - An error that occurs when a result that is not valid is returned. 
        • InvalidType - An error that occurs when a .NET Framework type that is not valid is specified. 
        • LimitsExceeded - An error that occurs when internal limits prevent the operation from being executed. 
        • MetadataError - An error that occurs when metadata contains an error.  
        • NotEnabled - An error that occurs when the operation attempts to use functionality that is currently disabled. 
        • NotImplemented - An error that occurs when a referenced application programming interface (API) is not implemented. 
        • NotInstalled - An error that occurs when an item is not installed. 
        • NotSpecified - An unspecified error. Use only when not enough is known about the error to assign it to another error category. Avoid using this category if you have any information about the error, even if that information is incomplete. 
        • ObjectNotFound - An error that occurs when an object cannot be found. 
        • OpenError - An error that occurs during opening. 
        • OperationStopped - An error that occurs when an operation has stopped. For example, the user interrupts the operation. 
        • OperationTimeout - An error that occurs when an operation has exceeded its timeout limit. 
        • ParserError - An error that occurs when a parser encounters an error. 
        • PermissionDenied - An error that occurs when an operation is not permitted. 
        • ProtocolError An error that occurs when the contract of a protocol is not being followed. This error should not happen with well-behaved components. 
        • QuotaExceeded An error that occurs when controls on the use of traffic or resources prevent the operation from being executed. 
        • ReadError An error that occurs during reading. 
        • ResourceBusy An error that occurs when a resource is busy. 
        • ResourceExists An error that occurs when a resource already exists. 
        • ResourceUnavailable An error that occurs when a resource is unavailable. 
        • SecurityError An error that occurs when a security violation occurs. This field is introduced in Windows PowerShell 2.0. 
        • SyntaxError An error that occurs when a command is syntactically incorrect. 
        • WriteError An error that occurs during writing. 
    
    .Parameter TargetObject      
    The object that was being processed when the error took place.  
    
    .Parameter Message      
    Describes the Exception to the user.  
    
    .Parameter InnerException      
    The Exception instance that caused the Exception association with the ErrorRecord.  
	.Parameter TargetType
    To customize the TargetType value, specify the appropriate Target object type.  Values can be "Array", "PSObject", "HashTable", etc.  Can be provided by ${ParameterName}.GetType().Name.
    
    .Example     
     #>

    [CmdletBinding()]
    param(

        [Parameter(Mandatory = $true, Position = 0)]
        [System.String]$Exception,

        [Parameter(Mandatory = $true, Position = 1)]
        [Alias('ID')]
        [System.String]$ErrorId,

        [Parameter(Mandatory = $true, Position = 2)]
        [Alias('Category')]
        [ValidateSet('AuthenticationError','ConnectionError','NotSpecified', 'OpenError', 'CloseError', 'DeviceError',
            'DeadlockDetected', 'InvalidArgument', 'InvalidData', 'InvalidOperation',
                'InvalidResult', 'InvalidType', 'MetadataError', 'NotImplemented',
                    'NotInstalled', 'ObjectNotFound', 'OperationStopped', 'OperationTimeout',
                        'SyntaxError', 'ParserError', 'PermissionDenied', 'ResourceBusy',
                            'ResourceExists', 'ResourceUnavailable', 'ReadError', 'WriteError',
                                'FromStdErr', 'SecurityError')]
        [System.Management.Automation.ErrorCategory]$ErrorCategory,

        [Parameter(Mandatory = $true, Position = 3)]
        [System.Object]$TargetObject,

        [Parameter()]
        [System.String]$Message,

        [Parameter()]
        [System.Exception]$InnerException,
        [Parameter(Mandatory = $false)]
        [System.String]$TargetType = "String"
    )

    Process 
	{

        # ...build and save the new Exception depending on present arguments, if it...
        $_exception = if ($Message -and $InnerException) {
            # ...includes a custom message and an inner exception
            New-Object $Exception $Message, $InnerException
        } elseif ($Message) {
            # ...includes a custom message only
            New-Object $Exception $Message
        } else {
            # ...is just the exception full name
            New-Object $Exception
        }

        # now build and output the new ErrorRecord
        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Building ErrorRecord object"

        $record = New-Object Management.Automation.ErrorRecord $_exception, $ErrorID,$ErrorCategory, $TargetObject

        $record.CategoryInfo.TargetType = $TargetType

        Return $record
    }

}

function Enable-HPOVMSDSC 
{

	# .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding()]

    Param ()

	Begin { }

	Process 
	{

		$RegKey = "HKCU:\Software\Hewlett-Packard\HPOneView"

		if (-not(Test-Path $RegKey)) { New-Item -Path $RegKey -force | Write-Verbose }

		$UseMSDSC = [bool](Get-ItemProperty -LiteralPath $RegKey -ea silentlycontinue).'UseMSDSC'

		if (-not($UseMSDSC)) { New-ItemProperty -Path $RegKey -Name UseMSDSC -Value 1 -Type DWORD | write-verbose }

		else { Set-ItemProperty -Path $RegKey -Name UseMSDSC -Value 1 -Type DWORD | write-verbose }

	}

	End { }

}

function Disable-HPOVMSDSC 
{

	# .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding()]

    Param ()

	Begin { }

	Process 
	{

		$RegKey = "HKCU:\Software\Hewlett-Packard\HPOneView"

		if (-not(Test-Path $RegKey)) { New-Item -Path $RegKey -force | Write-Verbose }

		$UseMSDSC = [bool](Get-ItemProperty -LiteralPath $RegKey -ea silentlycontinue).'UseMSDSC'

		if (-not($UseMSDSC)) { New-ItemProperty -Path $RegKey -Name UseMSDSC -Value 0 -Type DWORD | write-verbose }

		else { Set-ItemProperty -Path $RegKey -Name UseMSDSC -Value 0 -Type DWORD | write-verbose }

	}

	End { }

}

function RestClient 
{

<#

    .SYNOPSIS 
    Internal Private Class for building a RestClient using [System.Net.HttpWebRequest]

    .DESCRIPTION 
    This is a private, internal class/function to create a new [System.Net.HttpWebRequest] object with pre-defined properties of the HttpWebReqeuest connection.  This class will set the following attributes, which the caller can overload the values with their own after the resource has been created:

        Timeout = 20000
        ContentType = "application/json"
        Accept = "application/json"
	    Headers.Item("X-API-Version") = $script:MaxXAPIVersion
        Headers.Item("accept-language") = "en_US"
        Headers.Item("accept-encoding") = "gzip, deflate"
        Headers.Item("auth") =${Global:ConnectedSessions}.sessionID  NOTE: Only if the sessionID exists.
        AutomaticDecompression = "GZip,Deflate,None"

    The URI of the HttpWebRequest object will automatically include the connected (or requested if the first call is Connect-HPOVMgmt) appliance address or name ($script:HPOneViewAppliance).  This value can be overloaded, but the Auth token that may be included as an HTTP header item could be invalid.

    .INPUTS
    None.

    .OUTPUTS
    New [System.Net.HttpWebRequest] object.

    .PARAMETER URI
    The URI of the request.  Do not include the appaliance hostname or IP Address, only the cononical URI value (i.e. /rest/server-hardware).

    .PARAMETER Method
    Optional.  Provide the HTTP method for the request.  The default value is 'GET'.  Only the following values are allowed:

        GET
        PUT
        POST
        DELETE
        PATCH (to be supported in a future release)

    .PARAMETER Appliance
    Optional.  Provide the appliance hostname or FQDN.  The default is the value of '$script:HPOneViewAppliance'
#>

    [CmdletBinding()]
    Param 
	(

        [parameter(Mandatory = $False, Position = 0)]
        [ValidateScript({if ("GET","POST","DELETE","PATCH","PUT" -match $_) {$true} else { Throw "'$_' is not a valid Method.  Only GET, POST, DELETE, PATCH, or PUT are allowed." }})]
        [string]$method = "GET",

        [parameter(Mandatory, Position = 1, HelpMessage = "Enter the resource URI (ex. /rest/enclosures)")]
        [ValidateScript({if ($_.startswith('/')) {$true} else {throw "-URI must being with a '/' (eg. /rest/server-hardware) in its value. Please correct the value and try again."}})]
        [string]$uri,

        [parameter(Mandatory, Position = 2)]
        [ValidateNotNullorEmpty()]
        [string]$Appliance = $Null

    )

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

        $url = $Appliance + $uri

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Building new [System.Net.HttpWebRequest] object for $method https://$url"

    }

	Process 
    {

        [System.Net.HttpWebRequest]$restClient              = [System.Net.HttpWebRequest]::Create("https://$url")
        [String]$restClient.Method                          = $method
        [int]$restClient.Timeout                            = 20000
        [String]$restClient.ContentType                     = "application/json"
        [String]$restClient.Accept                          = "application/json"
		[String]$restClient.Headers.Item("X-API-Version")   = $script:MaxXAPIVersion
        [String]$restClient.Headers.Item("accept-language") = "en_US"
        [String]$restClient.Headers.Item("accept-encoding") = "gzip, deflate"
        [String]$restClient.AutomaticDecompression          = "GZip,Deflate,None"
 
        # Set the callback to check for null certificate and thumbprint matching.
		#This method is only supported in PowerShell 4 or greater
        $restClient.ServerCertificateValidationCallback = {

            $_WebRequest = [System.Net.WebRequest]$args[0]
 
            $_certificate = [System.Security.Cryptography.X509Certificates.X509Certificate2]$args[1]

            try 
			{ 
				
				$_san = ($_certificate.Extensions | Where-Object {$_.Oid.Value -eq "2.5.29.17"}).Format(0) -split ", " 
			
			}

            catch 
			{ 
				
				$_san = $null 
			
			}

            $_chain = New-Object Security.Cryptography.X509Certificates.X509Chain 

            [void]$_chain.ChainPolicy.ApplicationPolicy.Add("1.3.6.1.5.5.7.3.1")

            $_status = $_chain.Build($_certificate)

            if ($_chain.ChainStatus) { $_chainstatus = $_chain.ChainStatus | % { $_.Status.ToString() } }

            $_certObject = [HPOneView.PKI.SslCertificate] @{

                    Certificate             = $_WebRequest.ServicePoint.Certificate;
                    Issuer                  = $_WebRequest.ServicePoint.Certificate.Issuer;
                    Subject                 = $_WebRequest.ServicePoint.Certificate.Subject;
                    SubjectAlternativeNames = $_san;
                    CertificateIsValid      = $_status;
                    ErrorInformation        = $_chainstatus

            }

			# // Check _san as well?  DnsNameList is likely not enough, and is failing cert chain validation in some cases with DCS.
            if (($_certificate.DnsNameList -contains $_WebRequest.Host -or $_certObject.SubjectAlternativeNames -match $_WebRequest.Host) -and (-not($_status)) -and ($_chainstatus -contains "UntrustedRoot"))
            {

                if (-not(($Global:ConnectedSessions | ? Name -eq $_WebRequest.Host).SslChecked))
                {

                    $_backgroundcolor = [System.Console]::BackgroundColor 
                    $Host.UI.WriteLine([System.ConsoleColor]::Yellow,$_backgroundcolor,"`n$($_certObject | Out-String)")
                    $Host.UI.WriteWarningLine("The appliance SSL Certificate is UNTRUSTED.  Use the Import-HPOVSSLCertificate to import the appliance Self-Signed certificate to your user accounts local Trusted Root Certification Authorities store to not display this warning when you first connect to your appliance.")
					$Host.UI.WriteLine("")

                    ($Global:ConnectedSessions | ? Name -eq $_WebRequest.Host).SslChecked = $true

                }
            
                return $true
            
			}

            #If Cert IS valid, but cannot validate with Root CA, can validate with Subordinate CA and unable to validate revocation, display warning
			elseif ((-not ($_status)) -and ($_certificate.ErrorInformation -contains "PartialChain" -and $_certificate.ErrorInformation -contains "RevocationStatusUnknown" -and $_certificate.ErrorInformation -contains "OfflineRevocation")) 
			{ 

                $Host.UI.WriteLine([System.ConsoleColor]::Yellow,$_backgroundcolor,"`n$($_certObject | Out-String)")

                $Host.UI.WriteWarningLine("The appliance SSL Certificate is UNTRUSTED.  This system does not trust the CA issuer, and is unable to verify the Certificate Authorities Revocation List (CRL) or the Revocation List Destination (CLD) is not contained within the certificate.")
				$Host.UI.WriteLine("")
                
            }

			#If Cert IS valid, but cannot validate with Root CA and unable to validate revocation, display warning
			elseif ((-not ($_status)) -and ($_certificate.ErrorInformation -contains "RevocationStatusUnknown" -and $_certificate.ErrorInformation -contains "OfflineRevocation")) 
			{				 
                
				$Host.UI.WriteLine([System.ConsoleColor]::Yellow,$_backgroundcolor,"`n$($_certObject | Out-String)")
                
				$Host.UI.WriteWarningLine("The appliance SSL Certificate is UNTRUSTED.  This system is unable to verify the Certificate Authorities Revocation List (CRL) or the Revocation List Destination (CLD) is not contained within the certificate.  If you are using an Enterprise Certificate Authority (i.e. Windows Server CA), please make sure the CRL is published as part of the issued certificate (CRL is an Extension that needs to be enabled prior to issuing certificates).")
				$Host.UI.WriteLine("")

			}

            #Cert is trusted and a Global ConnectedSession exists
            elseif ($_status -and ($Global:ConnectedSessions | ? Name -eq $_WebRequest.Host))
            {

                ($Global:ConnectedSessions | ? Name -eq $_WebRequest.Host).SslChecked = $true
            
                return $_status

            }

            elseif ($_status)
            {

                #$Host.UI.WriteLine("Reached final ElseIf and cert is trusted.")
                return $_status

            }

            else 
			{

				$Host.UI.WriteLine([System.ConsoleColor]::Red,[System.ConsoleColor]::Black,"`n$($_certObject | Out-String)")

            }

            return $false

        }

    }

    End 
	{

        Return [System.Net.HttpWebRequest]$restClient

    }

}

function Send-HPOVRequest 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding()]
    Param 
	(

        [parameter(Position = 0, Mandatory = $true, HelpMessage = "Enter the resource URI (ex. /rest/enclosures)")]
        [ValidateScript({if ($_.startswith('/')) {$true} else {throw "-URI must being with a '/' (eg. /rest/server-hardware) in its value. Please correct the value and try again."}})]
        [string]$uri,

        [parameter(Position = 1, Mandatory = $false)]
        [string]$method = "GET",
        
        [parameter(Position = 2, Mandatory = $false)]
        [object]$body = $null,

        [parameter(Position = 3, Mandatory = $false)]
        [int]$start = 0,

        [parameter(Position = 4, Mandatory = $false)]
        [int]$count = 0,

        [parameter(Position = 5, Mandatory = $false)]
        [hashtable]$addHeader,

        [parameter(Mandatory = $false, HelpMessage = "Enter the hostname or an array of hostnames")]
		[Alias('Appliance','ApplianceConnection')]
        [Object]$Hostname = ${Global:ConnectedSessions}

    )

    Begin 
	{ 

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] BEGIN"

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		#Support getting the Appliance Connection Name from the object being passed within the body param
		if ($PSBoundParameters['body'] -and $body.ApplianceConnection -and (-not($body -is [Array]) -and (-not($body -is [System.Collections.ArrayList]))))
		{

			$Hostname = $body.ApplianceConnection.Name

		}

        #Collection to return all responses from all specified appliance connections
		$AllResponses = New-Object System.Collections.ArrayList

    }

    Process 
	{

        $c = 1

		if (-not($PSboundParameters['Hostname']) -and (-not([bool]($Hostname | Measure-Object).count)))
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoAuthSession ObjectNotFound 'Hostname' -Message "No appliance Hostname parameter provided and no valid appliance session(s) found."
            $PSCmdlet.ThrowTerminatingError($errorRecord)

		}

        ForEach ($ApplianceHost in $Hostname) 
        {

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] PROCESS"

			if (${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name)
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Prior Global Response Error Object for '$($ApplianceHost.Name)' found. Clearing."

				$_ResponseObject = (${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name)

				[void]${Global:ResponseErrorObject}.Remove($_ResponseObject)

			}
            
            #If the value is String, we assume this is the Appliance Hostname, so look up the Connection details in ${Global:ConnectedSessions}
            if ($ApplianceHost -is [String] -and (${Global:ConnectedSessions} | ? Name -eq $ApplianceHost )) 
            {

                $ApplianceHost = ${Global:ConnectedSessions} | ? { $_.Name -eq $ApplianceHost }

            }

            elseif ($ApplianceHost -is [String])
            {

                [PSCustomObject]$ApplianceHost = @{Name = $ApplianceHost}

            }

            "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '{0}' appliance connection request. {1} of {2}" -f $ApplianceHost.Name,$c,$Hostname.count | Write-Verbose 

            #Need to check for authenticated session when the URI passed is not value of $script:loginSessionsUri
            "[$($MyInvocation.InvocationName.ToString().ToUpper())] Requested URI '{0}' to '{1}'" -f $uri, ($ApplianceHost.Name -join ',') | Write-Verbose 

            if ($script:WhiteListedURIs -contains $uri) 
            {

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] We have reached the URI Whitelist condition block. Unauth request allowed for '$uri'."

            }
			    
            #Else, require authentication
            elseif (-not($ApplianceHost.SessionID)) 
            {

                $errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoAuthSession AuthenticationError 'Send-HPOVRequest' -Message "No valid session ID found for '$($ApplianceHost.Name)'.  The call to '$uri' requires authentication.  Please use Connect-HPOVMgmt to connect and authenticate to an appliance."
                $PSCmdlet.ThrowTerminatingError($errorRecord)

            }
    
            #Pagination handling:
			$AllMembers = New-Object System.Collections.ArrayList

            #See if the caller specified a count, either in the URI or as a param
            #(if so, we will let them handle pagination manually)
            [bool]$manualPaging = $false

            if ($uri.ToLower().Contains("count=") -or $uri.ToLower().Contains("count =")) 
            {

                $manualPaging = $true

            }

            elseif ($count -gt 0) 
            {

                $manualPaging = $true

                #add start & count params to the URI
                if (-not ($uri -contains "?")) 
                {

                    $uri += "?"    

                }

                $uri += ("start=" + $start + "&")

                $uri += ("count=" + $count)

            }

            elseif ($start -gt 0) 
            {

                #start specified, but no count -- just set the start param & auto-page from there on:
                $manualPaging = $false

                if (-not ($uri -contains "?")) 
                {

                    $uri += "?"   
                 
                }

                $uri += ("start=" + $start)
            }

            do 
            {

                #Used to keep track of async task response
                $taskRecieved = $False

                [System.Net.HttpWebRequest]$req = RestClient $method $uri $ApplianceHost.Name

                #Add Auth Session token if it exists                
                if ($ApplianceHost.SessionID -and $ApplianceHost.SessionID -ne 'TemporaryConnection') 
				{ 
					
					$req.Headers.Item("auth") = $ApplianceHost.SessionID 
				
				}

                
                #Increase timeout for synchronOut call for Support Dumps to be generated as they are not an Async task.
                if ($uri -match "support-dump") 
				{ 
                
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Increase HttpWebRequest timeout to 200s, as a Support Dump is being requested."
                    $req.Timeout = 200000 
                    
                }

                #Handle additional headers being passed in for updated API (storage volume removal)
                #Variable defined as a hashtable in case other API pass more than one additional header
                if($addHeader)
				{

                    $addHeader.GetEnumerator() | ForEach-Object { $req.Headers.Item($_.key) = $_.value }

                }

                #Send the request with a messege
                if ($body) 
				{
                
                    if (($method -eq "PUT" -or $method -eq "PATCH") -and $body.etag) 
					{

		    			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] HTTP Method is $method and eTag value found $($body.etag).  Setting 'If-Match' HTTP Header."

                        #Handle eTags from connection manager
                        $req.Headers.Item("If-match") = $body.etag

                    }

                    #Remove any found ApplianceConnection property(ies) to not generate REST API Error
                    if (($method -eq "PUT" -or $method -eq "PATCH") -and ($body.ApplianceConnection))
                    {

                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] HTTP Method is $method. Removing 'ApplianceConnection' NoteProperty from object(s)."
						
						
                        $body = ($body | % { Select-Object -InputObject $_ -Property * -ExcludeProperty ApplianceConnection })

                    }

		    		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Body object found. Converting to JSON."

					if ($method -eq "PATCH" -and (-not($body -is [Array])))
					{

						[Array]$body = @($body)

					}
					
                    #Create a new stream writer to write the json to the request stream.
					if (-not($body -is [String]))
					{

						#Do not use Pipeline, or you will lose the Array when a single object is part of an array, espcially needed for PATCH method
						$js = ConvertTo-Json -InputObject $body -Depth 99 -Compress #| write-verbose

					}

		    		#Needed to remove \r character that ConvertTo-JSON adds which /rest/logindirectories does not support for the directory server SSL certificate
                    if ($body.type -eq "LoginDomainConfigVersion2Dto") 
					{ 
						
						$js = $js -replace "\\r",$null 
					
					}

		            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Request Body: $($js)"

                    #Send the messege
		            $stream = New-Object IO.StreamWriter $req.GetRequestStream()
		            $stream.AutoFlush = $True
		            $stream.WriteLine($js)
		            $stream.Close()

                }

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Request: $($method) https://$($ApplianceHost.Name)$($uri)"
   
                #Write Verbose the headers if needed
                $i = 0
                foreach ($h in $req.Headers) 
				{ 

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Request Header $($i+1): $($h) = $($req.Headers[$i])"
                    $i++ 

				}

                try 
				{

                    #Get response from appliance
                    [System.Net.WebResponse]$LastWebResponse = $req.GetResponse()

                    #Display the response status if verbose output is requested
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Response Status: $([int]$LastWebResponse.StatusCode) {$([String]$LastWebResponse.StatusDescription)}"

                    $i = 0
                    foreach ($h in $LastWebResponse.Headers) 
					{ 
						
						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Response Header $($i+1): $($h) = $($LastWebResponse.Headers[$i])"
						
						$i++ 
					
					}
                    
                    $rs = $LastWebResponse.GetResponseStream()

                    #Read the response
                    $reader = New-Object System.IO.StreamReader($rs)
                    $resp   = $reader.ReadToEnd() | ConvertFrom-json

					$rs.Close()
					$reader.Close()
					$LastWebResponse.Close()                   

					if ($resp -is [String])
					{

						"[$($MyInvocation.InvocationName.ToString().ToUpper())] Response: {0}" -f $resp | Write-Verbose 

					}

					else
					{

						"[$($MyInvocation.InvocationName.ToString().ToUpper())] Response: {0}" -f ($resp | fl * -force | out-string) | Write-Verbose 

					}
                    
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Manual Pagination: $($manualPaging)"

                    #If asynchronOut (HTTP status=202), make sure we return a Task object:
					if ([int]$LastWebResponse.StatusCode -eq 202 -and $LastWebResponse.Headers.Item('Location'))
                    {

                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Async Task (HTTP 202) received"

                        #AsynchronOut operation -- in some cases we get the Task object returned in the body.
                        #In other cases, we only get the Task URI in the Location header.
                        #In either case, return a Task object with as much information as we know
                        if ($LastWebResponse.Headers.Item('Location')) 
						{

                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Async Task Location found in HTTP headers: $($LastWebResponse.Headers.Item('Location'))"

                            #Return custom task resource if response does not contain actual task resource
                            if (-not($resp.category -eq "tasks")) 
							{

                                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Task Resource Object to return to caller."

                                #Only have the Task URI - generate a Task object to be returned:
                                [string]$taskUri = $LastWebResponse.Headers.Item('Location')

                                #First, make sure the task URI is relative:
                                $pos = $taskUri.IndexOf($script:taskUri)

                                if ($pos -gt 0) 
								{

                                    $taskUri = $taskUri.Substring($pos)

                                }

                                $resp = Send-HPOVRequest -appliance $ApplianceHost.Name -uri $taskUri -method GET

		    					#Handle previOut Send-HPOVRequest call
                                if ([int]$LastWebResponse.statusCode -eq 200) 
								{
                                    
                                    #Change the statusCode from 200 to 202, as wewant to reply to the caller with HTTP 202 as Async Task status.
                                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Updating HTTP statusCode property to 202"

                                    $resp | select * -ExcludeProperty statusCode | Add-Member -NotePropertyName statusCode -NotePropertyValue 202

                                }

                            }

		    				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding 'HPOneView.Appliance.TaskResource' to PSObject TypeNames for task object"

		    				$resp | % { $_.PSObject.TypeNames.Insert(0,”HPOneView.Appliance.TaskResource") }

                        }

                        elseif (-not($resp)) 
						{

                            $errorRecord = New-ErrorRecord InvalidOperationException RestAPIError InvalidResult 'Send-HPOVRequest' -Message 'SEND-HPOVREQUEST: REST API ERROR: The operation is asynchronOut, but neither a Task resource or URI was returned!'
                            throw $errorRecord
                        
                        }

                    }

		    		#Handle Task Objects that have been directly accessed via task URI and not created async tasks (HTTP 202)
		    		if (([int]$LastWebResponse.StatusCode -eq 200 -or [int]$LastWebResponse.StatusCode -eq 202) -and ($resp.category -eq "tasks") -and (-not($resp.PSObject.TypeNames -match "HPOneView.Appliance.TaskResource"))) 
					{
		    			
		    			$resp | % { $_.PSObject.TypeNames.Insert(0,”HPOneView.Appliance.TaskResource") }

		    		}

                    #User Logoff success message
                    if (([int]$LastWebResponse.StatusCode -eq 204) -and ($uri -eq $script:loginSessionsUri))
                    {

                        $resp = [PSCustomObject]@{ Message = "User logoff successful." }

                    }

					elseif (([int]$LastWebResponse.StatusCode -eq 204 -or [int]$LastWebResponse.StatusCode -eq 200) -and $method -eq "DELETE")
					{
						
						$resp = [PSCustomObject]@{StatusCode = [int]$LastWebResponse.StatusCode; Message = "Resource deleted successfully." }
						
					}

					# // Need to update this to add members collection into $_AllMembers as an ArrayList
                    #Handle multi-page result sets
                    if ([bool]($resp | gm -Name members -ErrorAction SilentlyContinue) -and (-not($manualPaging))) 
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Response members and automatic pagination"

                        $resp.members | % { 
							
							Add-Member -InputObject $_ -NotePropertyName ApplianceConnection -NotePropertyValue ([PSCustomObject]@{ Name = $ApplianceHost.Name; ConnectionId = $ApplianceHost.ConnectionId }) -Force 

							[void]$AllMembers.Add($_) 
						
						}

                        write-verbose "total stored '$($AllMembers.count)'"

                        write-verbose "nextPageURI: '$($AllMembers.nextPageUri)'"

                        if ($resp.nextPageUri) 
						{ 

                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Pagination has occurred. Received $($resp.count) resources of $($resp.total)"

                            $uri = $resp.nextPageUri

                        }

                        else 
						{ 

                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Reached end of pagination. Building AllResults"

                            $_AllResults = [PsCustomObject]@{
								
								members     = $AllMembers; 
								count       = $AllMembers.Count;
								total       = $AllMembers.Count;
								category    = $resp.category; 
								eTag        = $resp.eTag;
								nextPageUri = $resp.nextPageUri;
								start		= $resp.start;
								prevPageUri	= $resp.prevPageUri;
								created		= $resp.created;
								modified	= $resp.modified;
								uri			= $resp.uri
							
							}

							[void]$AllResponses.Add($_AllResults)
                            
                        }

                    }
					
					elseif ($resp.members -and $manualPaging )
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Response members and manual paging"

						$resp.members | % { 
							
							Add-Member -InputObject $_ -NotePropertyName ApplianceConnection -NotePropertyValue ([PSCustomObject]@{ ConnectionId = $ApplianceHost.ConnectionId; Name = $ApplianceHost.Name }) -Force 

						}

						[void]$AllResponses.Add($resp)

					}

					elseif ($resp)
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Response object, no paging needed."

						Add-Member -InputObject $resp -NotePropertyName ApplianceConnection -NotePropertyValue ([PSCustomObject]@{ ConnectionId = $ApplianceHost.ConnectionId; Name = $ApplianceHost.Name }) -Force 

						[void]$AllResponses.Add($resp)

					}

                } 
       
                catch [System.Net.WebException] 
                { 

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Net.WebException Error caught"

					"[$($MyInvocation.InvocationName.ToString().ToUpper())] {0}" -f $_.Exception.Message | write-verbose
                    
                    if ($_.Exception.InnerException -match "System.Net.WebException: Unable to connect to the remote server") 
					{ 
                    
                        $errorRecord = New-ErrorRecord HPOneView.Appliance.NetworkConnectionException ApplianceNotResponding ResourceUnavailable 'Hostname' -Message "Unable to connect to '$($ApplianceHost.Name)' due to timeout."
                        $PSCmdLet.ThrowTerminatingError($errorRecord)

                    }
					
					elseif ($_.Exception.Message -match 'The remote name could not be resolved')
					{

						$errorRecord = New-ErrorRecord HPOneView.Appliance.NetworkConnectionException RemoteNameLookupFailure ObjectNotFound 'Hostname' -Message "Unable to connect to the appliance.  $($_.Exception.Message)."
                        $PSCmdLet.ThrowTerminatingError($errorRecord)
					}

                    if ($_.Exception.InnerException) 
					{

                        if ($_.Exception.InnerException.Response) 
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] InnerException"

                            $LastWebResponse = $_.Exception.InnerException.Response

                        }

                        else 
						{

                            Write-Error $_.Exception.InnerException.Message

                        }

                    } 
                
                    else 
					{

                        if ($_.Exception.Response) 
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Exception"

                            $LastWebResponse = $_.Exception.Response

                        }

                        else 
						{

                            Write-Error $_.Exception.Message

                        }

                    }

                    if ($LastWebResponse) 
					{

                        Try
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Error Response."
						
							$reader = New-Object System.IO.StreamReader($LastWebResponse.GetResponseStream())

						}

						Catch
						{

							$PSCmdlet.ThrowTerminatingError($_)

						}

                        $ErrorResponse = $reader.ReadToEnd() | ConvertFrom-JSON

						$LastWebResponse.Close()

						$reader.Close()

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] ERROR RESPONSE: $($ErrorResponse | ConvertTo-Json -Depth 99 | out-string)"

                        #Set Global Response Error Object
						if (-not(${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name))
						{
						
							$_NewResponseErrorObject = [PSCustomObject]@{

								Name            = $ApplianceHost.Name
								LastWebResponse = $LastWebResponse
								ErrorResponse   = $ErrorResponse

							}

							[void]${Global:ResponseErrorObject}.Add($_NewResponseErrorObject)
						
						}

						else
						{

							(${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).LastWebResponse = $LastWebResponse
							(${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse   = $ErrorResponse

						}                       
                        
                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Response Status: HTTP $([int](${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).LastWebResponse.StatusCode) [$((${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).LastWebResponse.StatusDescription)]"

                        foreach ($h in (${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).LastWebResponse.Headers) 
						{ 
							
							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Response Header: $($h) = $((${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).LastWebResponse.Headers[$i])"
							
							$i++ 
						
						}

                        switch ([int](${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).LastWebResponse.StatusCode) 
						{

                            #HTTP 400 errors
                            400 
							{
                                
                                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] HTTP 400 error caught."

								switch ((${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.errorCode)
								{

									#Hande initial authentication errors
									"AUTHN_AUTH_DIR_FAIL"
									{
                                    
										${Global:ConnectedSessions}.Remove($ApplianceHost)
										$errorRecord = New-ErrorRecord HPOneView.Appliance.AuthSessionException InvalidUsernameOrPassword AuthenticationError 'Send-HPOVRequest' -Message "$((${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.message)  $((${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.recommendedActions)"
										$pscmdlet.ThrowTerminatingError($errorRecord)

									}

									#Handle invalid user session
		    						"AUTHN_LOGOUT_FAILED"
									{

		    							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User session no longer valid, likely due to session timeout. Clearing library runtime global and script variables."

										${Global:ConnectedSessions}.Remove($ApplianceHost)

										$errorRecord = New-ErrorRecord HPOneView.Appliance.AuthSessionException InvalidUserSession AuthenticationError "Appliance:$($ApplianceHost.Name)" -Message "$($global:ResponseErrorObject.($ApplianceHost.Name).details)"
										Throw $errorRecord

									}

									#Handle user not acknowledging login message
		    						"AUTHN_LOGIN_MESSAGE_ACKNOWLEDGMENT_REQUIRED"
									{

		    							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User needed to accept the Login Message."

										$errorRecord = New-ErrorRecord HPOneView.Appliance.AuthSessionException LoginMessageAcknowledgementRequired AuthenticationError "Appliance:$($ApplianceHost.Name)" -Message ("{0} {1} " -f $global:ResponseErrorObject.($ApplianceHost.Name).details, $global:ResponseErrorObject.($ApplianceHost.Name).recommendedActions)
										Throw $errorRecord

									}

									default
									{

										if ((${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.errorSource) 
										{ 
										
											$source = (${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.errorSource 
									
										}

										else 
										{ 
										
											$source = 'Send-HPOVRequest' 
									
										}

										$errorRecord = New-ErrorRecord InvalidOperationException InvalidAuthOperation InvalidOperation $source -Message "$((${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.message) $((${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.details)"
										$pscmdlet.ThrowTerminatingError($errorRecord)

									}

								}

                                
		    					
		    					
                                

                            }

                            #User is unauthorized
                            401 
							{

                                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] HTTP 401 error caught."
                                
                                if ((${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.details -cmatch "User not authorized for this operation" -or (${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.message -cmatch "insufficient privilege for operation") 
								{

		    						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $((${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.message) Request was '$method' at '$uri'."

                                    $errorRecord = New-ErrorRecord HPOneview.Appliance.AuthPrivilegeException InsufficientPrivilege AuthenticationError 'Send-HPOVRequest' -Message "[Send-HPOVRequest]: $((${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.message).  Request was '$method' at '$uri'. "
                                    $PSCmdlet.ThrowTerminatingError($errorRecord)

                                }

                                else 
								{

                                    [void]${Global:ConnectedSessions}.Remove($ApplianceHost)

                                    $errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException InvalidOrTimedoutSession AuthenticationError 'Send-HPOVRequest' -Message "[Send-HPOVRequest]: Your session has timed out or is not valid. Please use Connect-HPOVMgmt to authenticate to your appliance."
                                    $PSCmdlet.ThrowTerminatingError($errorRecord)

                                }

                            }

		    				403 
							{
		    					
		    					$resp = $Null

		    					if ((${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.errorCode -eq "PASSWORD_CHANGE_REQUIRED") 
								{ 
									
									$errorRecord = New-ErrorRecord HPOneview.Appliance.PasswordChangeRequired PasswordExpired PermissionDenied "URI" -Message ((${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.message + " " + (${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.recommendedActions) 
								
								}
		    					
								else 
								{ 
									
									$errorRecord = New-ErrorRecord HPOneview.Appliance.ResourcePrivledgeException ResourcePrivledge PermissionDenied "URI" -Message ((${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.message + " " + (${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.recommendedActions) 
								
								}

                                Throw $errorRecord

                            }

		    				404 
							{
		    					
		    					$resp = $Null

                                $errorRecord = New-ErrorRecord HPOneview.ResourceNotFoundException ResourceNotFound ObjectNotFound "URI" -Message ("The request resource '$uri' could not be found. " + (${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.recommendedActions)
                                Throw $errorRecord

                            }
                        
                            405 
							{
                        
                                $errorRecord = New-ErrorRecord InvalidOperationException (${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.errorCode InvalidOperation "$($Method):$($uri)" -Message ("[Send-HPOVRequest]: The requested HTTP method is not valid/supported.  " + (${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.details + " URI: $uri")
                                Throw $errorRecord

                            }

                            { @(409, 412) -contains $_ } 
							{
                        
                                $errorRecord = New-ErrorRecord InvalidOperationException $(${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.errorCode InvalidOperation 'Send-HPOVRequest' -Message ("[Send-HPOVRequest]: $((${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.message) $((${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.recommendedActions)")
                                Throw $errorRecord

                            }

		    				500 
							{

		    					if ((${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.details) 
								{ 
									
									$message = (${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.details 
								
								}

		    					else 
								{ 
									
									$message = (${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.message 
								
								}
		    					
		    					if (-not($message.Substring($message.length - 1) -eq ".")) { $message += "." }
		    					
		    					$errorRecord = New-ErrorRecord InvalidOperationException $(${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.errorCode InvalidOperation 'Send-HPOVRequest' -Message ("[Send-HPOVRequest]: $message $((${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.recommendedActions)") #-InnerException $global:ResponseErrorObject
                                Throw $errorRecord

		    				}

                            #Wait for appliance startup here by calling Wait-HPOVApplianceStart
                            { @(503, 0) -contains $_ } 
							{
                                
                                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] HTTP $([int]$LastWebResponse.StatusCode) error caught."

                                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Calling Wait-HPOVApplianceStart"

								Try
								{

									Wait-HPOVApplianceStart -Appliance $ApplianceHost.Name

								}

								Catch
								{

									$PSCmdlet.ThrowTerminatingError($_)

								}
                                

                                #appliance startup should have finished.
                                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Returning caller back to: $($method.ToUpper()) $uri"

                                if ($addHeader) 
								{ 
									
									return (Send-HPOVRequest -uri $uri -method $method -body $body -addHeader $addHeader -Hostname $ApplianceHost.Name) 
								
								}

                                else 
								{ 
									
									return (Send-HPOVRequest -uri $uri -method $method -body $body -Hostname $ApplianceHost.Name) 

								}

                            }

                            501 
							{

                                $errorRecord = New-ErrorRecord InvalidOperationException (${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.errorCode SyntaxError 'Send-HPOVRequest' -Message ("[Send-HPOVRequest]: " + (${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.message + " " + (${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.recommendedActions) -InnerException (${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.details
                                Throw $errorRecord

                            }
                            
                        } 

                    }

                    else 
					{

                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No Exception Response Object to return."

                        return $null

                    }

                }

				"[$($MyInvocation.InvocationName.ToString().ToUpper())] Does nextPageUri member exist: {0}" -f [bool]($resp | gm -Name nextPageUri -ErrorAction SilentlyContinue) | Write-Verbose
				"[$($MyInvocation.InvocationName.ToString().ToUpper())] Is nextPageUri Null or Empty: {0}" -f [string]::IsNullOrEmpty($resp.nextPageUri) | Write-Verbose

				$_Stop = $False

				#Always stop if manual paging
				if ($ManualPaging)
				{

					'[$($MyInvocation.InvocationName.ToString().ToUpper())] Stopping Do/Until loop because of manual paging' | Write-Verbose

					$_Stop = $True

				}

				#If not manual paging and nextPageUri doesn't exist, stop
				elseif (-not($ManualPaging) -and -not([bool]($resp | gm -Name nextPageUri -ErrorAction SilentlyContinue)))
				{

					"[$($MyInvocation.InvocationName.ToString().ToUpper())] Stopping Do/Until loop because nextPageUri doesn't exist and have received all objects." | Write-Verbose

					$_Stop = $True

				}

				#If not manual paging, nextPageUri exists and it is null or empty
				elseif (-not($ManualPaging) -and ([bool]($resp | gm -Name nextPageUri -ErrorAction SilentlyContinue)) -and [string]::IsNullOrEmpty($resp.nextPageUri))
				{
				
					"[$($MyInvocation.InvocationName.ToString().ToUpper())] Stopping Do/Until loop because nextPageUri is null/empty and have received all objects." | Write-Verbose

					$_Stop = $True
				
				}


            #} until ($manualPaging -or -not([bool]($resp | gm -Name nextPageUri) -or $resp.nextPageUri -eq $null))
			} until ($_Stop)

            $c++

        } #Continue with next appliance

    }

    End 
    {

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] END"

		Return $AllResponses

    }

}

function ConvertTo-Object
{
	    
    [CmdletBinding()]
    Param 
	(

         [parameter(Position = 0, Mandatory)]
         [ValidateNotNullOrEmpty()]
         [System.Collections.ArrayList]$Objects

    )

    Begin
    {

        $NewObjects = New-Object System.Collections.ArrayList

    }

	Process
	{
		
		#Write-verbose "Objects is '$($Objects.GetType().Fullname)' type."
		
		ForEach($_obj in $Objects)
		{

			#Write-verbose "_obj is '$($_obj.GetType().Fullname)' type."

			#Write-verbose "Processing: $($_obj.name)"

			switch ($_obj.category)
			{

				"ethernet-networks"
				{
				
					#[HPOneView.Networking.EthernetNetwork]$_newObj = $_obj

					$_obj.PSObject.TypeNames.Insert(0,'HPOneView.Networking.EthernetNetwork')
				
				}

				"fc-networks"
				{
				
					#[HPOneView.Networking.FibreChannelNetwork]$_newObj = $_obj
					$_obj.PSObject.TypeNames.Insert(0,'HPOneView.Networking.FibreChannelNetwork')
				
				}

				"fcoe-networks"
				{
				
					#[HPOneView.Networking.FCoENetwork]$_newObj = $_obj
					$_obj.PSObject.TypeNames.Insert(0,'HPOneView.Networking.FCoENetwork')

				}

                default
                {
                
                    #$_newObj = $_obj

                }

			}


            #Write-verbose "_newObj is '$($_newObj.GetType().Fullname)' type."

			#[void]$NewObjects.Add($_newObj)
			[void]$NewObjects.Add($_obj)

		}

	}

	End
	{

		Return $NewObjects

	}

}
 
function Ping-HPOVAddress
{

    # .ExternalHelp HPOneView.200.psm1-help.xml
    
    [CmdletBinding()]
    Param 
	(

		#allow via pipeline
		[parameter(Position = 0, Mandatory, ValueFromPipeline, HelpMessage = "Device FQDN or IP Address to PING from the HP OneView Appliance.")]
		[ValidateNotNullOrEmpty()]
		[string]$Address,

		[parameter(Position = 1, Mandatory = $False, HelpMessage = "Number of packets to send.")]
		[ValidateNotNullOrEmpty()]
		[int]$Packets = 5,

		[parameter(Mandatory = $False, HelpMessage = "Run as Async")]
		[switch]$Async,

		#Only allow a single appliance connection
		[parameter(Position = 2, Mandatory= $false)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}
    
	)

    Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		#Allow targets to be passed via pipeline
		if (-not($PSBoundParameters['Address'])) 
		{ 
			
			$PipelineInput = $True 
		
		}

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if  (($ApplianceConnection | Measure-Object).Count -eq 0)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError 'ApplianceConnection' -Message 'This CMDLET requires athentication.  Please log into a valid appliance using Connect-HPOVMgmt, and then try the call again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		else
		{

			$c = 0
		
			ForEach ($_Connection in $ApplianceConnection) 
			{
		
				Try 
				{
			
					$ApplianceConnection[$c] = Test-HPOVAuth $_Connection
		
				}
		
				Catch [HPOneview.Appliance.AuthSessionException] 
				{
		
					$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
					$PSCmdlet.ThrowTerminatingError($errorRecord)
		
				}
		
				Catch 
				{
		
					$PSCmdlet.ThrowTerminatingError($_)
		
				}
		
				$c++
		
			}

		}

		$_TaskCollection = New-Object System.Collections.ArrayList

    }

	Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{

			$_PingObject = NewObject -Ping

			$_PingObject.address = $Address

			if ($PSBoundParameters['Packets'])
			{

				$_PingObject.noOfPackets = $Packets

			}

			Try
			{

				$_resp = Send-HPOVRequest $appliancePingTestUri POST $_PingObject -Hostname $_Connection

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			if (-not($PSBoundParameters['Async']))
			{

				$_resp = Wait-HPOVTaskComplete $_resp

				Write-Host " "
				$_resp.progressUpdates.statusUpdate | Out-Host
				Write-Host " "

			}
					
			[void]$_TaskCollection.Add($_resp)

		}

	}

	End
	{

		Return $_TaskCollection

	}

}

function Wait-HPOVApplianceStart 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml
    
    [CmdletBinding()]
    Param 
	(

		[parameter(Position = 0, Mandatory, HelpMessage = "Provide the Appliance IP Address or Host Name to monitor.")]
		[Alias('Appliance')] 
		[ValidateNotNullOrEmpty()]
		[string]$Hostname = $null
    
	)

    Begin 
	{
		
		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller" 
    
    }

    Process 
	{

        do 
		{
            
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Services not started. Monitoring startup progress"
            
            $waitRequest  = $Null
            $waitResponse = $Null

            [System.Net.httpWebRequest]$waitRequest = RestClient -uri $ApplianceStartProgressUri -appliance $Hostname

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] REQUEST: $($waitRequest.Method) $($waitRequest.RequestUri)"

            $i = 0

            foreach ($h in $waitRequest.Headers) 
			{ 
				
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Request Header $($i+1): $($h) = $($waitRequest.Headers[$i])"
				
				$i++ 
			
			}

            try 
			{

                #Get response from appliance
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting response..."

                $waitResponse = $waitRequest.GetResponse()

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Received HTTP\$([int]$waitResponse.StatusCode) status."

                #This will trigger when the GetResponse() does not generate an HTTP Error Code and get trapped by the Catch statement below
                If ($_displayflag) 
				{

                    write-host "]"

                    #Reset flag so we don't display the ending brace
                    $_displayflag = $False

                }

                #Read the response
                $reader = New-Object System.IO.StreamReader($waitResponse.GetResponseStream())
                $responseJson = $reader.ReadToEnd()
                $reader.Close()

                $resp = ConvertFrom-json $responseJson

				$percentComplete = [Math]::Round(($resp.complete / $resp.total) * 100,$mathMode)
                
                #Handle the call from -Verbose so Write-Progress does not get borked on display.
                if ($PSBoundParameters['Verbose'] -or $VerbosePreference -eq 'Continue') 
				{ 
                    
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Skipping Write-Progress display."
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Percent Complete: $percentComplete%"
                    start-sleep -s 2

                }
                  
                else 
				{

                    #Display progress-bar
                    Write-Progress -activity "Appliance services starting" -Status "$percentComplete%" -percentComplete $percentComplete

                    start-sleep -s 2

                }

            }

            #Catch if we haven't received HTTP 200, as we should display a nice message stating services are still beginning to start
            catch [Net.WebException] 
			{

                if ($waitResponse) 
				{

                    $rs = $waitResponse.GetResponseStream()

                    $reader = New-Object System.IO.StreamReader($rs)

                    $responseJson = $reader.ReadToEnd()

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] ERROR RESPONSE: $($responseJson | ConvertFrom-Json | out-string)"

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Response Status: HTTP_$([int]$waitResponse.StatusCode) $($waitResponse.StatusDescription)"

                    foreach ($h in $waitResponse.Headers) 
					{ 
						
						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Response Header: $($h) = $($waitResponse.Headers[$i])"
						
						$i++ 
					
					}

                }

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] EXCEPTION CAUGHT! HTTP Status Code: $([int]$waitResponse.StatusCode)"

				#Handle WebExcpetion errors that are not HTTP Status Code 503 or 0, and throw error
				if ([int]$waitResponse.StatusCode -ne 503 -and [int]$waitResponse.StatusCode -ne 0)
				{

					Throw $_.Exception.Message

				}

                write-verbose "$($waitResponse| Out-string)"

                #Only want to display this message once.
                if (-not($_displayflag)) 
				{

                    Write-host "Waiting for services to begin starting [" -nonewline

                }

                if (-not ([int]$waitResponse.StatusCode -eq 200)) 
				{

                    Write-host "*" -nonewline -ForegroundColor Green

                    $_displayflag = $true

                    start-sleep -s 5

                }

                $waitRequest = $null
            }

        } until ($resp.complete -eq $resp.total -and [int]$waitResponse.StatusCode -eq 200)

    }

    end 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Web Services have started successfully"

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Pausing 10 seconds to let web services finish their final startup"

        start-sleep -s 10

    }

}

function Connect-HPOVMgmt 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding()]
    Param
	(

		[parameter(Mandatory, HelpMessage = "Enter the appliance DNS name or IP", Position = 0)]
		[ValidateNotNullOrEmpty()]
		[alias('Appliance')]
		[string]$Hostname,

		[parameter(Mandatory = $false, HelpMessage = "Enter the authentication domain", Position = 3)]
		[ValidateNotNullOrEmpty()]
		[alias('authProvider')]
		[string]$AuthLoginDomain = 'LOCAL',

		[parameter(Mandatory, HelpMessage = "Enter the user name", Position = 1)]
		[ValidateNotNullOrEmpty()]
		[alias("u",'user')]
		[string]$UserName,

		[parameter(Mandatory = $false, HelpMessage = "Enter the password:", Position = 2)]
		[alias("p")]
		[ValidateNotNullOrEmpty()]
		[String]$password,

		[parameter(Mandatory = $false)]
		[switch]$LoginAcknowledge 

    )

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		#Check if user provided AuthLoginDomain and see if AuthProvider is set in registry (format 'AuthProvider#{ApplianceName}')
		if (-not($PSboundParameters['AuthLoginDomain']))
		{

			$RegQueryAuthProvider = Get-ItemProperty "HKCU:\Software\Hewlett-Packard\HPOneView" "AuthProvider#$Hostname" -ErrorAction SilentlyContinue
			
			If (-not($RegQueryAuthProvider)) 
			{ 
				
				Set-ItemProperty -Path HKCU:\Software\Hewlett-Packard\HPOneView -Name "AuthProvider#$Hostname" -Value LOCAL -Type STRING | write-verbose 
			
			}
			
			else
			{

				$AuthLoginDomain = (Get-ItemProperty HKCU:\SOFTWARE\Hewlett-Packard\HPOneView "AuthProvider#$Hostname" -ea SilentlyContinue)."AuthProvider#$Hostname"

			}

		}
        
        #Check to see if a connection to the appliance exists
        if ((${Global:ConnectedSessions}.Name -contains $Hostname) -and ((${Global:ConnectedSessions} | ? name -eq $Hostname).SessionID)) 
        {

            Write-Warning "You are already connected to $Hostname"
            continue
                
        }

        #Create the connection object for tracking
        else 
        {

			# Look for Connection where Name exists but SessionID does not, and remove the object from $ConnectedSessions
			if ((${Global:ConnectedSessions}.Name -contains $Hostname) -and (-not(${Global:ConnectedSessions} | ? name -eq $Hostname).SessionID)) 
			{

				write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Found incomplete session object in $ConnectedSessions for '$Hostname'. Removing."

				#Found incomplete session connection. must remove it from the collection first.
				$_ndx = [array]::IndexOf(${Global:ConnectedSessions}, (${Global:ConnectedSessions}.Name -contains $Hostname))

				[void]${Global:ConnectedSessions}.RemoveAt($_ndx)
			        
			}

            write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Creating Session Container"

            [HPOneView.Appliance.Connection]$ApplianceConnection = New-Object HPOneView.Appliance.Connection

            #Figure out ConnectionId
            if (${Global:ConnectedSessions})
            {

                $tmpConnectionId = 1

                While (${Global:ConnectedSessions}.ConnectionId -contains $tmpConnectionId) 
                {

                    $tmpConnectionId++

                }

                $ApplianceConnection.ConnectionId = $tmpConnectionId
            
            }

			#Store the entire auth request for later deletion when issuing Disconnect-HPOVmgmt
            $ApplianceConnection.Name            = $Hostname
            $ApplianceConnection.UserName        = $UserName
            $ApplianceConnection.AuthLoginDomain = $AuthLoginDomain

            [void] ${Global:ConnectedSessions}.Add($ApplianceConnection)

            write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(${Global:ConnectedSessions} | out-string)"
            
        }

        if (-not($password))
        {

            [SecureString]$password = read-host -AsSecureString "Password"
            $decryptPassword = [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($password))
            
        }

        else 
        {

            $decryptPassword = $password

        }

        #Check to make sure the appliance X-API-Version is at least the supported minimum
        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Checking X-API Version"
            
        try 
        {
            
            $applianceVersion = (Send-HPOVRequest $script:ApplianceXApiVersionUri -Hostname $Hostname).currentVersion

            if ($applianceVersion -and $applianceVersion -lt $script:applMinVersion ) 
            {

				[void] ${Global:ConnectedSessions}.Remove($ApplianceConnection)

                #Display terminating error
                $errorRecord = New-ErrorRecord System.NotImplementedException LibraryTooNew OperationStopped $Hostname -Message "The appliance you are connecting to supports an older version of this library.  Please visit https://github.com/HewlettPackard/POSH-HPOneView for a supported version of the library."
                $PSCmdlet.ThrowTerminatingError($errorRecord)

            }

        }

        catch 
        {

			[void] ${Global:ConnectedSessions}.Remove($ApplianceConnection)
            
			$PSCmdlet.ThrowTerminatingError($_)

        }

    }

    Process 
    {

        $_authinfo = NewObject -AuthLogin

        $_authinfo.userName        = $UserName
        $_authinfo.password        = $decryptPassword
        $_authinfo.authLoginDomain = $AuthLoginDomain

		if ($PSBoundParameters['LoginAcknowledge'])
		{

			$_authinfo | Add-Member -NotePropertyName loginMsgAck -NotePropertyValue $True

		}

        try 
        {

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending auth request"

			$_LoginMessage = Send-HPOVRequest $ApplianceLoginDomainDetails -Hostname $Hostname

			Write-Host ("{0}`n" -f $_LoginMessage.loginMessage.message)
            
            $resp = Send-HPOVRequest $loginSessionsUri POST $_authinfo -Hostname $Hostname

        } 

        catch [HPOneView.Appliance.AuthSessionException] 
        {

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Authentication Exception Caught."

			switch ($_.FullyQualifiedErrorId)
			{

				'LoginMessageAcknowledgementRequired'
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Authentication Exception Caught."

					#Get LoginMessage from appliance.
					Try
					{

						$caption = "Please Confirm";
						$message = "Do you acknowledge the login message?";
						$yes     = new-Object System.Management.Automation.Host.ChoiceDescription "&Yes","Yes, I accept the login message.";
						$no      = new-Object System.Management.Automation.Host.ChoiceDescription "&No","No, I do not.";
						$choices = [System.Management.Automation.Host.ChoiceDescription[]]($yes,$no);
						$answer  = $host.ui.PromptForChoice($caption,$message,$choices,0) 

						switch ($answer)
						{

							#YES
							0 
							{

								Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Submitting auth request again, with login message acknowledgement."
                            
								$_authinfo | Add-Member -NotePropertyName loginMsgAck -NotePropertyValue $True

								Try
								{

									$resp = Send-HPOVRequest $LoginSessionsUri POST $_authinfo -Hostname $Hostname

								}

								Catch
								{

									$PSCmdlet.ThrowTerminatingError($_)

								}

							}

							#NO
							1
							{

								Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User selected 'No'."

								'You are not authenticated to {0}, as you chose not to accept the Login Message acknowledgement.' -f $Hostname | Write-Warning 

								#Remove Connection from global tracker
								[void] ${Global:ConnectedSessions}.Remove($ApplianceConnection)

								Return

							}

						}   

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

				}

				{'InvalidUsernameOrPassword' -match $_}
				{

					#Remove Connection from global tracker
					[void] ${Global:ConnectedSessions}.Remove($ApplianceConnection)

					$errorRecord = New-ErrorRecord HPOneView.Appliance.AuthSessionException InvalidUsernameOrPassword AuthenticationError 'Connect-HPOVMgmt' -Message $_.Exception.Message 
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				default
				{

					#Remove Connection from global tracker
					[void] ${Global:ConnectedSessions}.Remove($ApplianceConnection)

					$errorRecord = New-ErrorRecord HPOneView.Appliance.AuthSessionException ($_ -split ",")[0] AuthenticationError 'Connect-HPOVMgmt' -Message $_.Exception.Message 
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

			}           

        }

		catch [HPOneview.Appliance.PasswordChangeRequired] 
        {

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Password needs to be changed. Use Set-HPOVInitialPassword if this is first time setup, or Set-HPOVUserPassword to update your own accounts password."

			[void] ${Global:ConnectedSessions}.Remove($ApplianceConnection)

			#Throw terminating error
			$errorRecord = New-ErrorRecord HPOneview.Appliance.PasswordChangeRequired PasswordExpired PermissionDenied 'Username' -Message ($global:ResponseErrorObject.message + " " + $global:ResponseErrorObject.recommendedActions + " Use Set-HPOVInitialPassword if this is first time setup, or Set-HPOVUserPassword to update your own accounts password.")
			$PSCmdlet.ThrowTerminatingError($errorRecord)   
        
        }
		    
        catch [Net.WebException] 
        {

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Response: $($resp)"

			[void] ${Global:ConnectedSessions}.Remove($ApplianceConnection)

            $errorRecord = New-ErrorRecord System.Net.WebException ApplianceNotResponding OperationStopped $Hostname -Message "The appliance at $Hostname is not responding on the network.  Check for firewalls or ACL's prohibiting access to the appliance."
            $PSCmdlet.ThrowTerminatingError($errorRecord)

        }

    }

    end 
    {

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Authentication Response: $($resp | out-string)"

        #If a sessionID is returned, then the user has authenticated
        if ($resp.sessionID) 
        {
            
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Session token received: $($resp.sessionID)"
            
			(${Global:ConnectedSessions} | ? { $_.Name -EQ $Hostname } ).SessionID = $resp.sessionID
    
            #Get list of supported Roles from the appliance
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting list of supported roles from appliance."

            try 
			{ 
				
				$_ApplianceSecurityRoles = (Send-HPOVRequest $Script:applianceRolesUri -Hostname $Hostname).members.roleName 

				(${Global:ConnectedSessions} | ? { $_.Name -EQ $Hostname } ) | Add-Member -NotePropertyName ApplianceSecurityRoles -NotePropertyValue $_ApplianceSecurityRoles  -force
			
			}

            catch [HPOneview.Appliance.AuthPrivilegeException] 
			{ 
				
				(${Global:ConnectedSessions} | ? { $_.Name -EQ $Hostname } ) | Add-Member -NotePropertyName ApplianceSecurityRoles -NotePropertyValue $null -force
			
			}

			Return $ApplianceConnection

        }

        else 
        { 
                              
            Return $resp 

        }

    }

}

function Show-HPOVAppliance 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding()]
    Param()

    Begin 
	{

		Write-Warning "Show-HPOVAppliance CMDLET is deprecated.  Please update your scripts to use the `${Global:ConnectedSessions} global variable."

    }

    Process 
	{

    
    }

    End 
	{

		Return ${Global:ConnectedSessions}

    }

}

function Disconnect-HPOVMgmt 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml
    
    [CmdletBinding()]
    Param
	(
    
        [parameter(Position = 0, Mandatory = $false, HelpMessage = "Enter the hostname or an array of hostnames")]
		[Alias('Appliance','ApplianceSession')]
        [Object]$Hostname = ${Global:ConnectedSessions}
    
    )

    Begin 
    {

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"
		
		if (-not($Hostname))
        { 
        
            $errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoAuthSession ResourceUnavailable 'Hostname' -Message "No valid logon session available.  Please use Connect-HPOVMgmt to connecto to an appliance, and then use Disconnect-HPOVmgmt to terminate your session."
            $PSCmdlet.ThrowTerminatingError($errorRecord)
            
        }

		$Hostname = [System.Collections.ArrayList]${Global:ConnectedSessions}.Clone()

    }

    Process 
    {

        if (-not($PSBoundParameters['Hostname']))
        {

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No hostname(s) or connection(s) provided. Processing all connected sessions."

        }

        ForEach ($_Connection in $Hostname)
        {

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Connection: $($_Connection | fl * | Out-String)"

            if ($_Connection -is [String])
            {

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Hostname provide, looking in global connection tracker for connection."

                [HPOneView.Appliance.Connection]$_Connection = ${Global:ConnectedSessions} | ? Name -eq $_Connection

            }

        
            if ($_Connection -eq $Null -or $_Connection.SessionID -eq $Null)
            {

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User Session not found in " + '${Global:ConnectedSessions}'

				if ($_Connection -is [HPOneView.Appliance.Connection])
				{

					$_ConnectionName = $_Connection.Name

				}

				else
				{
				
					$_ConnectionName  = $Hostname
				
				}

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException UnableToLogoff ObjectNotFound 'Hostname' -Message "User session for '$_ConnectionName' not found in library connection tracker (`${Global:ConnectedSessions}). Did you accidentially remove it, or have you not created a session to an appliance?"
                $PSCmdlet.WriteError($errorRecord)

            }
           
            else
            {


                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Attempting to logoff user '$($_Connection.Username)' from '$($_Connection.Name)'."

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending Delete Session ID request"

		        try 
                {
                
                    $Resp = Send-HPOVRequest $script:LoginSessionsUri DELETE $_Connection.SessionId -Hostname $_Connection.Name

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Removing connection from global connection tracker"

                    $Global:ConnectedSessions.Remove($_Connection)
                    
                }
                
                #Need to clean up
                catch
                {
                
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())]  Unable to complete logoff. Displaying error"
                    $PSCmdlet.ThrowTerminatingError($_)
                
                }

            }

        }

	}

    End
    {

    
    }

}

function Test-HPOVAuth
{

	[CmdletBinding()]
    Param
	(
    
        [parameter(Position = 0, Mandatory = $false, ValueFromPipeline, HelpMessage = "Enter the hostname or an array of hostnames")]
        [Object]$Appliance
    
    )

    Begin 
    {

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Caller: $Caller"

		if ($PSBoundParameters['Appliance'])
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify Auth for $Appliance"

		}

		else
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] -Appliance value via pipeline."
			
			$PipelineInput = $True

		}

		$_ApplianceConnections = New-Object System.Collections.ArrayList

	}

	Process
	{

		if ($PipelineInput)
		{
	
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify Auth for $($Appliance.Name)"

		}
		
		ForEach ($_Appliance in $Appliance)
		{

			"[$($MyInvocation.InvocationName.ToString().ToUpper())] `$Appliance is [{0}]"  -f $_Appliance.GetType().FullName | Write-Verbose

			Switch ($_Appliance.GetType().FullName)
			{

				'HPOneView.Appliance.Connection'
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Recieved HPOneView.Appliance.Connection Object: $($_Appliance | Out-String)"

					If (-not(${Global:ConnectedSessions} | ? name -eq $_Appliance.Name))
					{

						$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError "$($Caller):$($_Appliance.Name)" -Message "No Appliance connection session found for '$($_Appliance.Name)' within `${Global:ConnectedSessions} global variable.  This CMDLET requires at least one active connection to an appliance.  Please use Connect-HPOVMgmt to establish a connection, then try your command agian."

					}

					$_Appliance = $Appliance

				}

				'System.String'
				{

					if (-not(${Global:ConnectedSessions} | ? name -eq $_Appliance))
					{

						$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError "$($Caller):$($_Appliance)" -Message "No connection session found for '$($_Appliance)' within `${Global:ConnectedSessions} global variable.  This CMDLET requires at least one active connection to an appliance.  Please use Connect-HPOVMgmt to establish a connection, then try your command agian."

					}

					elseif (${Global:ConnectedSessions} | ? name -eq $_Appliance)
					{
					
						$_Appliance = ${Global:ConnectedSessions} | ? name -eq $_Appliance

					}

				}

				'System.Management.Automation.PSCustomObject'
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Recieved PSCustomObject: $($_Appliance | Out-String)"

					If (-not(${Global:ConnectedSessions} | ? name -eq $_Appliance.Name))
					{

						$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError "$($Caller):$($_Appliance.Name)" -Message "No Appliance connection session found for '$($_Appliance.Name)' within `${Global:ConnectedSessions} global variable.  This CMDLET requires at least one active connection to an appliance.  Please use Connect-HPOVMgmt to establish a connection, then try your command agian."

					}

					$_Appliance = ${Global:ConnectedSessions} | ? name -eq $_Appliance.Name

				}

				default
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Unsupported ApplianceConnection object."

					$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NotaValidApplianceConnection AuthenticationError "$($Caller)" -Message "The provided appliance object is not valid, as it is neither an [HPOneView.Appliance.Connection] object, [String] value representing a potentially valid Appliance Connection, or a [PSCustomObject] property of a resource object obtained from an appliance.  Please correct the ApplianceConnection parameter value, and then try your command agian."

				}

			}

			If ($errorRecord)
			{ 

				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Else
			{

				[void]$_ApplianceConnections.Add($_Appliance)

			}

		}

	}

	End
	{
	
		Return $_ApplianceConnections

	}

}

function New-HPOVResource 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding()]
    Param
    (

		[parameter(Position = 0, Mandatory = $true, HelpMessage = "Enter the URI string of the resource type to be created")]
		[ValidateNotNullOrEmpty()]
		[string] $uri,

		[parameter(Position = 1, Mandatory = $true, HelpMessage = "Enter the resource object definition")]
		[ValidateNotNullOrEmpty()]
		[object] $resource,

		[parameter(Mandatory, ValueFromPipeline, HelpMessage = "Enter the hostname or an array of hostnames")]
        [Object]$ApplianceConnection = $null
    
	)

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		Try 
		{
		
			$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

		}

		Catch [HPOneview.Appliance.AuthSessionException] 
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $ApplianceConnection -Message $_.Exception.Message -InnerException $_.Exception
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		Catch 
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

		$_NewResourceCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{

		Try
		{

			$_resp = Send-HPOVRequest $uri POST $resource -Hostname $ApplianceConnection

		}

		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

		[void]$_NewResourceCollection.Add($_resp)

    }

	End
	{

		Return $_NewResourceCollection

	}

}

function Set-HPOVResource 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml
    [CmdletBinding()]
    Param 
	(

		[parameter(Position = 0, Mandatory = $true, ValueFromPipeline = $true, HelpMessage = "Enter the resource object that has been modifed")]
		[ValidateNotNullOrEmpty()]
		[ValidateScript({$_.Uri})]
		[object]$resource,

		[parameter(Mandatory = $false)]
		[string]$force = $false,

		[parameter(Mandatory, ValueFromPipeline, HelpMessage = "Enter the hostname or an array of hostnames")]
        [Object]$ApplianceConnection = $null
    
	)

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		Try 
		{
		
			$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

		}

		Catch [HPOneview.Appliance.AuthSessionException] 
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $ApplianceConnection -Message $_.Exception.Message -InnerException $_.Exception
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}


		Catch 
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

		$_SetResourceCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{

		$uri = $resource.uri

        if ($force -eq $true) { $uri += "?force=true" }

		Try
		{

			$_resp = Send-HPOVRequest $uri PUT $resource -Hostname $ApplianceConnection

		}

		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

		[void]$_SetResourceCollection.Add($_resp)

    }

	End
	{

		Return $_SetResourceCollection

	}

}

function Remove-HPOVResource 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml
     
    [CmdletBinding()]
    Param 
	(

		[parameter(Position = 0, Mandatory = $true, ValueFromPipeline = $true, HelpMessage = "Provide the Object, Name or URI of the resource object to delete/remove.")]
		[ValidateNotNullorEmpty()]
		[Alias("ro",'nameOruri','uri','name')]
		[object]$Resource,

		[parameter(Mandatory = $false)]
		[switch]$force,

		[parameter(Mandatory, ValueFromPipeline, HelpMessage = "Enter the hostname or object of the appliance connection")]
		[ValidateNotNullorEmpty()]
		[Object]$ApplianceConnection = $null
	
	)

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		Try 
		{
		
			$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

		}

		Catch [HPOneview.Appliance.AuthSessionException] 
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $ApplianceConnection -Message $_.Exception.Message -InnerException $_.Exception
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		Catch 
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

		$_RemoveResourceCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{
         
        switch ($Resource.GetType().Name) 
		{ 

            "PSCustomObject"  
			{ 
                
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Resource object passed."
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Name: $($Resource.name)"
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] URI: $($Resource.uri)"
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Type: $($Resource.type)"

                [void]$_RemoveResourceCollection.Add($Resource)
                
            }
         
            "String"
			{
                
                #nameOrUri value is a URI
                if ($Resource.StartsWith("/rest"))
				{

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Resource URI passed '$($Resource)', getting object"

					Try
					{

						$_resource = Send-HPOVRequest $Resource -Hostname $ApplianceConnection

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}
					
					[void]$_RemoveResourceCollection.Add($_resource)

                }

                #It's a string value
                else 
				{
                    
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Resource name provided: $($Resource)"
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Querying appliance index for resource."

                    #Use Index filtering to locate object
					Try
					{

						$_resources = Send-HPOVRequest ($indexUri + "?filter=name='$Resource'") -Hostname $ApplianceConnection

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Found $($_resources.count) resources."

                    if($_resources.members)
					{

                        #Error should only be displayed if a Name was provided, and it wasn't globally unique on the appliance (i.e. Server Profile and Ethernet Network with the same name, which is completely valid.)
                        if($_resources.count -gt 1)
						{
                            
                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Resources found: $($_resources.members | % { $_.name + " of type " + $_.category })"

                            $errorRecord = New-ErrorRecord InvalidOperationException ResourceNotUnique LimitsExceeded 'Resource' -Message "'$Resource' is not unique.  Located $($_resources.count) resources with the same value."
                            $pscmdlet.ThrowTerminatingError($errorRecord)

                        }

                        else 
						{ 
                        
                            [void]$_RemoveResourceCollection.Add($_resources.members)

                        }

                    }

                    else 
					{ 

                        $errorRecord = New-ErrorRecord InvalidOperationException ResourceNotFound ObjectNotFound 'Resource' -Message "Resource '$Resource' not found. Please check the resource value provided and try the call again."
                        $pscmdlet.ThrowTerminatingError($errorRecord)

                    }

                }

            }   
			  
        }

	}
    
	End
	{

		$n = 1

		ForEach ($_resource in $_RemoveResourceCollection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_resource.name)', $n of $($_RemoveResourceCollection.Count)"

            if ([bool]$force) 
			{ 
				
				$_resource.uri += "?force=true" 
			
			}

            Try
			{
								
				Send-HPOVRequest $_resource.uri DELETE

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$n++

        }

    }

}

function Set-DefaultDisplay ($resources, [string[]]$defProps) 
{
<#
     .DESCRIPTION 
     Handy internal utility function to set default display properties
#>
    $defDisplayProps = New-Object -TypeName System.Management.Automation.PSPropertySet -ArgumentList DefaultDisplayPropertySet, $defProps
    $PSStandardMembers = [System.Management.Automation.PSMemberInfo[]]$defDisplayProps 

    ForEach ($resource in $resources) 
	{

        Add-Member -InputObject $resource -MemberType MemberSet -Name PSStandardMembers -Value $PSStandardMembers -Force

    }

}

function ConvertFrom-HTML 
{

    [CmdletBinding()]
    param
	(

        [Parameter(Position = 0, ValueFromPipeline = $True, Mandatory = $True)]
        [ValidateNotNullOrEmpty()]
        [System.String] $html,

        [switch]$NoClobber
        
    )

    Begin { }

    Process 
	{
        
        # remove line breaks, replace with spaces
        if (-not ($NoClobber.ispresent)) { $html = $html -replace "(`r|`n|`t)", " " }
        
        # remove invisible content
        @('head', 'style', 'script', 'object', 'embed', 'applet', 'noframes', 'noscript', 'noembed') | % {$html = $html -replace "<$_[^>]*?>.*?</$_>", "" }
        
        # Condense extra whitespace
        $html = $html -replace "( )+", " "
        
        # Add line breaks
        @('div','p','blockquote','h[1-9]') | % { $html = $html -replace "</?$_[^>]*?>.*?</$_>", ("`n" + '$0' )} 

        # Add line breaks for self-closing tags
        @('div','p','blockquote','h[1-9]','br') | % { $html = $html -replace "<$_[^>]*?/>", ('$0' + "`n")} 
        
        #strip tags 
        $html = $html -replace "<[^>]*?>", ""
         
        # replace common entities
        @(
            @("&amp;bull;", " * "),
            @("&amp;lsaquo;", "<"),
            @("&amp;rsaquo;", ">"),
            @("&amp;(rsquo|lsquo);", "'"),
            @("&amp;(quot|ldquo|rdquo);", '"'),
            @("&amp;trade;", "(tm)"),
            @("&amp;frasl;", "/"),
            @("&amp;(quot|#34|#034|#x22);", '"'),
            @('&amp;(amp|#38|#038|#x26);', "&amp;"),
            @("&amp;(lt|#60|#060|#x3c);", "<"),
            @("&amp;(gt|#62|#062|#x3e);", ">"),
            @('&amp;(copy|#169);', "(c)"),
            @("&amp;(reg|#174);", "(r)"),
            @("&amp;nbsp;", " "),
            @("&amp;(.{2,6});", ""),
            @("&nbsp;", " ")
        ) | % { $html = $html -replace $_[0], $_[1] }

    }

    End 
	{
    
        return $html

    }

}


#######################################################
# Appliance Configuration: 
#

Function Get-HPOVApplianceCertificateStatus 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding(DefaultParameterSetName = 'Default')]

	Param 
	(
		
		[parameter(Mandatory = $false)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

	)
    
    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_ApplianceStatus = New-Object System.Collections.ArrayList

    }

    Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_Connection.Name)' Appliance (of $($ApplianceConnection.Count))"
			
			Try
			{

				$_status = Send-HPOVRequest $applianceSslCert -Hostname $_Connection

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$_status.PSObject.TypeNames.insert(0,'HPOneView.Appliance.ApplianceSslCertificateStatus')

			[void]$_ApplianceStatus.Add($_status)

		}

	}

	End 
	{

		Return $_ApplianceStatus	

	}

}

Function New-HPOVApplianceSelfSignedCertificate 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding(DefaultParameterSetName = 'Default', ConfirmImpact = 'High')]

	Param 
	(

		[parameter(Mandatory = $true, ParameterSetName = 'Default', Position = 0)]
        [Alias('C')]
        [ValidateNotNullOrEmpty()]
        [string]$Country,

        [Parameter(Mandatory = $true, ParameterSetName = 'Default', Position = 1)]
        [Alias('ST','Province')]
		[ValidateNotNullOrEmpty()]	
		[string]$State,

        [Parameter(Mandatory = $false, ParameterSetName = 'Default', Position = 2)]
		[Alias('L','Locality')]	
		[ValidateNotNullOrEmpty()]
		[string]$City,

        [parameter(Mandatory = $true, ParameterSetName = 'Default', Position = 3)]
        [Alias('O')]
		[ValidateNotNullOrEmpty()]
		[string]$Organization,

        [parameter(Mandatory = $true, ParameterSetName = 'Default', Position = 4)]
        [Alias('CN')]
		[ValidateNotNullOrEmpty()]
		[string]$CommonName,

        [parameter(Mandatory = $false, ParameterSetName = 'Default', Position = 5)]
		[Alias('OU')]	
		[ValidateNotNullOrEmpty()]
        [string]$OrganizationalUnit,

        [parameter(Mandatory = $false, ParameterSetName = 'Default', Position = 6)]
		[Alias('SAN')]	
		[ValidateNotNullOrEmpty()]
        [string]$AlternativeName,

        [parameter(Mandatory = $false, ParameterSetName = 'Default', Position = 7)]
		[Alias('Contact')]	
		[ValidateNotNullOrEmpty()]
        [string]$ContactName,

        [parameter(Mandatory = $false, ParameterSetName = 'Default', Position = 8)]
		[ValidateNotNullOrEmpty()]
        [string]$Email,

        [parameter(Mandatory = $false, ParameterSetName = 'Default', Position = 9)]
		[Alias('Sur')]	
		[ValidateNotNullOrEmpty()]
        [string]$Surname,

        [parameter(Mandatory = $false, ParameterSetName = 'Default', Position = 10)]
		[Alias('Giv')]	
		[ValidateNotNullOrEmpty()]
        [string]$GivenName,

        [parameter(Mandatory = $false, ParameterSetName = 'Default', Position = 11)]
		[ValidateNotNullOrEmpty()]
        [string]$Initials,

        [parameter(Mandatory = $false, ParameterSetName = 'Default', Position = 12)]
		[ValidateNotNullOrEmpty()]
        [string]$DNQualifier,

		[parameter(Mandatory)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Object]$ApplianceConnection = $null

	)

	Begin
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		if (-not($ApplianceConnection -is [HPOneView.Appliance.Connection]) -and (-not($ApplianceConnection -is [System.String])))
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException InvalidApplianceConnectionDataType InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter is not type [HPOneView.Appliance.Connection] or [System.String].  Please correct this value and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif  ($ApplianceConnection.Count -gt 1)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException MultipleApplianceConnections InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter contains multiple Appliance Connections.  This CMDLET only supports 1 Appliance Connection in the ApplianceConnect parameter value.  Please correct this and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		else
		{

			Try 
			{
	
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError 'ApplianceConnection' -TargetType $ApplianceConnection.GetType().Name -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}

        $_TaskStatus = New-Object System.Collections.ArrayList

	}

	Process 
	{	
			
		$_SelfSignedCertObject = NewObject -SelfSignedCert

		$_SelfSignedCertObject.country            =  $Country
		$_SelfSignedCertObject.state              =  $State
		$_SelfSignedCertObject.locality           =  $City
		$_SelfSignedCertObject.organization       =  $Organization
		$_SelfSignedCertObject.commonName         =  $ContactName
		$_SelfSignedCertObject.organizationalUnit =  $OrganizationalUnit
		$_SelfSignedCertObject.alternativeName    =  $AlternativeName
		$_SelfSignedCertObject.contactPerson      =  $ContactName
		$_SelfSignedCertObject.email              =  $Email
		$_SelfSignedCertObject.surname            =  $Surname
		$_SelfSignedCertObject.givenName          =  $GivenName
		$_SelfSignedCertObject.initials           =  $Initials
		$_SelfSignedCertObject.dnQualifier        =  $DNQualifier

		Try
		{

			Write-Warning 'Updates to the certificate will require the appliance internal web server to be restarted. There will be a temporary service interruption estimated to last 30 seconds.'

			if ($pscmdlet.ShouldProcess($ApplianceConnection.Name,"generate new self-signed certificate"))
			{    

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing: $($_SelfSignedCertObject | out-string)"

				$_resp = Send-HPOVRequest $applianceCsr POST $_SelfSignedCertObject -HostName $ApplianceConnection
        
			}

			else 
			{

				if ($PSBoundParameters['whatif'].ispresent) 
				{ 

					write-warning "-WhatIf was passed, would have proceeded 'New Self-Signed Certificate for Appliance $($ApplianceConnection.Name)'."

					$_resp = $null

				}

				else 
				{

					#If here, user chose "No", end processing

					$_resp = $Null

				}

			}

			[void]$_TaskStatus.Add($_resp)

		}

		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

	}

	End 
	{

		Return $_TaskStatus

	}

}

Function New-HPOVApplianceCsr 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding(DefaultParameterSetName = 'Default')]

	Param 
	(

		[parameter(Mandatory = $true, ParameterSetName = 'Default', Position = 0)]
        [Alias('C')]
        [ValidateNotNullOrEmpty()]
        [string]$Country,

        [Parameter(Mandatory = $true, ParameterSetName = 'Default', Position = 1)]
        [Alias('ST','Province')]
		[ValidateNotNullOrEmpty()]	
		[string]$State,

        [Parameter(Mandatory = $false, ParameterSetName = 'Default', Position = 2)]
		[Alias('L','Locality')]	
		[ValidateNotNullOrEmpty()]
		[string]$City,

        [parameter(Mandatory = $true, ParameterSetName = 'Default', Position = 3)]
        [Alias('O')]
		[ValidateNotNullOrEmpty()]
		[string]$Organization,

        [parameter(Mandatory = $true, ParameterSetName = 'Default', Position = 4)]
        [Alias('CN')]
		[ValidateNotNullOrEmpty()]
		[string]$CommonName,

        [parameter(Mandatory = $false, ParameterSetName = 'Default', Position = 5)]
		[Alias('OU')]	
		[ValidateNotNullOrEmpty()]
        [string]$OrganizationalUnit,

        [parameter(Mandatory = $false, ParameterSetName = 'Default', Position = 6)]
		[Alias('SAN')]	
		[ValidateNotNullOrEmpty()]
        [string]$AlternativeName,

        [parameter(Mandatory = $false, ParameterSetName = 'Default', Position = 7)]
		[Alias('Contact')]	
		[ValidateNotNullOrEmpty()]
        [string]$ContactName,

        [parameter(Mandatory = $false, ParameterSetName = 'Default', Position = 8)]
		[ValidateNotNullOrEmpty()]
        [string]$Email,

        [parameter(Mandatory = $false, ParameterSetName = 'Default', Position = 9)]
		[Alias('Sur')]	
		[ValidateNotNullOrEmpty()]
        [string]$Surname,

        [parameter(Mandatory = $false, ParameterSetName = 'Default', Position = 10)]
		[Alias('Giv')]	
		[ValidateNotNullOrEmpty()]
        [string]$GivenName,

        [parameter(Mandatory = $false, ParameterSetName = 'Default', Position = 11)]
		[ValidateNotNullOrEmpty()]
        [string]$Initials,

        [parameter(Mandatory = $false, ParameterSetName = 'Default', Position = 12)]
		[ValidateNotNullOrEmpty()]
        [string]$DNQualifier,

        [parameter(Mandatory = $false, ParameterSetName = 'Default', Position = 13)]
        [string]$ChallengePassword,

        [parameter(Mandatory = $false, ParameterSetName = 'Default', Position = 14)]
		[Alias('UN')]	
		[ValidateNotNullOrEmpty()]
        [string]$UnstructuredName,

		[parameter(Mandatory)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Object]$ApplianceConnection = $null

	)

	Begin
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		if (-not($ApplianceConnection -is [HPOneView.Appliance.Connection]) -and (-not($ApplianceConnection -is [System.String])))
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException InvalidApplianceConnectionDataType InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter is not type [HPOneView.Appliance.Connection] or [System.String].  Please correct this value and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif  ($ApplianceConnection.Count -gt 1)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException MultipleApplianceConnections InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter contains multiple Appliance Connections.  This CMDLET only supports 1 Appliance Connection in the ApplianceConnect parameter value.  Please correct this and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		else
		{

			Try 
			{
	
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError 'ApplianceConnection' -TargetType $ApplianceConnection.GetType().Name -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}

        $_TaskStatus = New-Object System.Collections.ArrayList

		#Handle runtime, none-script use
		if ($PSBoundParameters['ChallengePassword'] -and $ChallengePassword -eq '*'  ) 
		{

			Do 
			{

				[SecureString]$ChallengePassword        = Read-Host "Challenge Password:" -AsSecureString

				[SecureString]$ChallengePasswordConfirm = Read-Host "Confirm Challenge Password:" -AsSecureString

				$pwd1_text = [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($ChallengePassword))

				$pwd2_text = [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($ChallengePasswordConfirm))

				if (-not($pwd1_text -ceq $pwd2_text)) 
				{

					Write-Error "Passwords to not match. Please try again." -ea Continue

					$PasswordsMatch = $False

				}

				else { $PasswordsMatch = $True }

			} Until ($PasswordsMatch)

		}	

    }

	Process 
	{

		$_CsrObject = NewObject -ApplianceCSR

		$_CsrObject.country            =  $Country
		$_CsrObject.state              =  $State
		$_CsrObject.locality           =  $City
		$_CsrObject.organization       =  $Organization
		$_CsrObject.commonName         =  $ContactName
		$_CsrObject.organizationalUnit =  $OrganizationalUnit
		$_CsrObject.alternativeName    =  $AlternativeName
		$_CsrObject.contactPerson      =  $ContactName
		$_CsrObject.email              =  $Email
		$_CsrObject.surname            =  $Surname
		$_CsrObject.givenName          =  $GivenName
		$_CsrObject.initials           =  $Initials
		$_CsrObject.dnQualifier        =  $DNQualifier
		$_CsrObject.unstructuredName   =  $UnstructuredName
		$_CsrObject.challengePassword  =  $ChallengePassword

		Try
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing: $($_CsrObject | out-string)"

			$_resp = Send-HPOVRequest $applianceCsr POST $_CsrObject -HostName $ApplianceConnection
				
			[void]$_TaskStatus.Add($_resp)

		}

		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}


	}

	End 
	{

		Return $_TaskStatus

	}

}

Function Install-HPOVApplianceCertificate 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding(DefaultParameterSetName = 'Default')]

	Param 
	(

		[parameter(Mandatory = $true, ParameterSetName = 'Default', Position = 0, ValueFromPipeline = $true)]
        [Alias('PrivateKey')]
		[ValidateNotNullOrEmpty()]
        [Object]$Certificate,

		[parameter(Mandatory)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Object]$ApplianceConnection = $null

	)

	Begin
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		if (-not($ApplianceConnection -is [HPOneView.Appliance.Connection]) -and (-not($ApplianceConnection -is [System.String])))
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException InvalidApplianceConnectionDataType InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter is not type [HPOneView.Appliance.Connection] or [System.String].  Please correct this value and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif  ($ApplianceConnection.Count -gt 1)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException MultipleApplianceConnections InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter contains multiple Appliance Connections.  This CMDLET only supports 1 Appliance Connection in the ApplianceConnect parameter value.  Please correct this and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		else
		{

			Try 
			{
	
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError 'ApplianceConnection' -TargetType $ApplianceConnection.GetType().Name -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}

        $_TaskStatus = New-Object System.Collections.ArrayList

    }

	Process 
	{

			
		#handle new line so as not to bork ConvertTo-Json in Send-HPOVRequest
		$_TempCertificate += ($Certificate | Out-String) -join "\n"

		$_CertificateObject = [PSCustomObject]@{

			type       = "CertificateDataV2";
			base64Data = $_TempCertificate

		}

		Try
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing: $($_CsrObject | out-string)"

			$_resp = Send-HPOVRequest $applianceCsr PUT $_CertificateObject -HostName $ApplianceConnection
				
			[void]$_TaskStatus.Add($_resp)

		}

		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

	}

	End 
	{

		Return $_TaskStatus

	}

}

function Get-HPOVPendingUpdate 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding()]
	Param 
	(

		[parameter(Mandatory = $false, ParameterSetName = 'Default')]
		[ValidateNotNullorEmpty()]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

	)

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if  ($ApplianceConnection.Count -eq 0)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoAuthSessionFound InvalidArgument 'ApplianceConnection' -Message 'No ApplianceConnections were found.  Please use Connect-HPOVMgmt to establish an appliance connection.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

    }

    Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($Connection.Name)' Appliance (of $($ApplianceConnection.Count))"

			#Check to see if ane existing update is present.  Report to user if it is, and tell them to use -InstallNow
			Try
			{
				
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Checking if pending update exists"

				$_PendingUpdate = Send-HPOVRequest $applUpdatePending -Hostname $_Connection

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			if ($_PendingUpdate)
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Update found $($_PendingUpdate.fileName), $($_PendingUpdate.version)"

				$_PendingUpdate.PSObject.TypeNames.Insert(0,'HPOneView.Appliance.Update.Pending')

			}

			$_PendingUpdate

		}

	}

	End
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Finished"

    }

}

function Install-HPOVUpdate 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding(DefaultParameterSetName = 'Update',SupportsShouldProcess = $True, ConfirmImpact = 'High')]
	Param 
	(

		[parameter(Position = 0, Mandatory = $true, ParameterSetName = 'Update')]
        [parameter(Position = 0, Mandatory = $true, ParameterSetName = 'Stage')]
        [Alias('f')]
        [ValidateScript({Test-Path $_})]
        [string]$File,
        
        [Parameter(Position = 1, Mandatory = $false, ParameterSetName = 'Update')]
        [parameter(Position = 0, Mandatory = $false, ParameterSetName = 'StageInstall')]
        [string]$Eula,

        [Parameter(Mandatory = $false, ParameterSetName = 'Update')]
        [Parameter(Mandatory = $false, ParameterSetName = 'Stage')]
        [Parameter(Mandatory = $false, ParameterSetName = 'List')]
        [switch]$DisplayReleaseNotes,

        [parameter(Mandatory = $true, ParameterSetName = 'Stage')]
        [switch]$Stage,

        [parameter(Mandatory = $true, ParameterSetName = 'StageInstall')]
        [switch]$InstallNow,
        
        [parameter(Mandatory = $true, ParameterSetName = 'List')]
        [Alias('list')]
        [switch]$ListPending,

		[parameter(Mandatory = $false, ParameterSetName = "Update")]
		[parameter(Mandatory = $false, ParameterSetName = "Stage")]
		[parameter(Mandatory = $false, ParameterSetName = "List")]
		[ValidateNotNullorEmpty()]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

	)

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_StatusCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($Connection.Name)' Appliance (of $($ApplianceConnection.Count))"

			#Check to see if ane existing update is present.  Report to user if it is, and tell them to use -InstallNow
			Try
			{
				
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Checking if pending update exists"

				$_PendingUpdate = Send-HPOVRequest $applUpdatePending -Hostname $_Connection

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}
			
			if ($_PendingUpdate)
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Update found $($_PendingUpdate.fileName), $($_PendingUpdate.version)"

				$_PendingUpdate.PSObject.TypeNames.Insert(0,'HPOneView.Appliance.Update.Pending')

			}

			Switch ($PsCmdlet.ParameterSetName) 
			{
				
				#List staged update
				"List" 
				{

				    #If the request is to install a staged update, we need to handle no response.  If request is Update, then no pending update will exist yet.
				    If (-not($_PendingUpdate)) 
					{

				        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - No pending update found. Return is Null"

				        $errorRecord = New-ErrorRecord InvalidOperationException PendingUpdateNotFound ObjectNotFound 'Install-HPOVUpdate' -Message "No pending update found. Please first upload update and try again."
				        $pscmdlet.ThrowTerminatingError($errorRecord)

				    }

					$_PendingUpdate
				    
				    If ($PSBoundParameters['DisplayReleaseNotes'])
					{
                        
						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Displaying Release Notes"

						#Display Release Notes
						Try
						{

							Send-HPOVRequest "/rest/appliance/firmware/document-content/$($upload.fileName)/release" -Hostname $_Connection | ConvertFrom-HTML

						}
							
						Catch
						{

							$PScmdlet.ThrowTerminatingError($_)

						}

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Done. Displayed update release notes."

					}
				    
				    Return
				}

				#Stage Update
				"Stage" 
				{              

					if (-not($_PendingUpdate)) 
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Stage Only"
						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - UPLOAD FILE: $($File)"

						Try 
						{
                    
							#Upload update
							$FileName = Get-Item $File

							$_upload = Upload-File $applUpdate $File $_Connection.Name
                    
						}

						Catch 
						{
                        
							$errorRecord = New-ErrorRecord InvalidOperationException StageUpdateFailed InvalidResult 'Install-HPOVUpdate' -Message $_.Exception.Message
							$pscmdlet.ThrowTerminatingError($errorRecord)

						}

						If ($PSBoundParameters['DisplayReleaseNotes'])
						{
                        
							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Displaying Release Notes"

							#Display Release Notes
							Try
							{

								Send-HPOVRequest "/rest/appliance/firmware/document-content/$($upload.fileName)/release" -Hostname $_Connection | ConvertFrom-HTML

							}
							
							Catch
							{

								$PScmdlet.ThrowTerminatingError($_)

							}

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Done. Displayed update release notes."

						}

						Return $_upload

					}

					else 
					{
                    
						$errorRecord = New-ErrorRecord HPOneView.Appliance.FirmwareUpdateException PendingUpdateConflict ResourceExists 'Install-HPOVUpdate' -Message "An existing appliance update has been staged. Version: $($pendingUpdate.version) Filename: $($pendingUpdate.fileName)  Please use the -InstallUpdate parameter to proceed with the update, or use Remove-HPOVPendingUpdate cmdlet to remove the staged update."
						Throw $errorRecord

					}

				}

				#Upload update then install update below.
				"Update" 
				{

					if ($_PendingUpdate) 
					{

						$errorRecord = New-ErrorRecord InvalidOperationException PendingUpdateFound ResourceExists 'Install-HPOVUpdate' -Message "A pending update was found.  File name: $($pendingUpdate.fileName); Update Version: $($pendingUpdate.version). Please remove the update before continuing and try again."
						$pscmdlet.ThrowTerminatingError($errorRecord)
					
					}
					                
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - UPLOAD FILE: $($File)"

					Try 
					{
					
						#Upload update
						$FileName = Get-Item $File

						$pendingUpdate = Upload-File $script:applUpdate $File $_Connection.Name

						#Pause for 30 seconds? need to make sure appliance has finished processing update file before invoking update
						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Sleeping for 5 seconds."

						Start-Sleep -Seconds 5
                
					}

					Catch 
					{

						$errorRecord = New-ErrorRecord InvalidOperationException UploadUpdateFailed InvalidResult 'Install-HPOVUpdate' -Message $_.Exception.Message
						$pscmdlet.ThrowTerminatingError($errorRecord)

					}

				}

			}

			#Process pending update
			if (($PsCmdlet.ParameterSetName -eq "StageInstall") -or ($PsCmdlet.ParameterSetName -eq "Update" )) 
			{

			    #If the request is to install a staged update, we need to handle no response.  If request is Update, then no pending update will exist yet.
			    If ((-not($_PendingUpdate)) -and ($PsCmdlet.ParameterSetName -eq "StageInstall")) 
				{

			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - No pending update found. Return is Null"
			        
			        $errorRecord = New-ErrorRecord InvalidOperationException StorageSystemResourceNotFound ObjectNotFound 'Install-HPOVUpdate' -Message "No pending update found. Please first upload update and try again."
			        $pscmdlet.ThrowTerminatingError($errorRecord)

			    }


				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Install Now"

				$_PendingUpdate

			    If ($Eula -ne "accept") 
				{

			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - EULA NOT Accepted"
			        
			        #Display eula of update
			        
			        (New-Object System.Net.WebClient).DownloadString("https://$($_Connection.ApplianceConnection.Name)/ui-js/pages/upgrade/eula_content.html") | ConvertFrom-HTML -NoClobber

			        Do { $acceptEula = Read-Host "Accept EULA (Must type ACCEPT)" } Until ($acceptEula -eq "Accept")

			    }
			        
			    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - EULA Accepted"

			    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Beginning update $($_PendingUpdate.fileName)"

			    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Estimated Upgrade Time $($_PendingUpdate.estimatedUpgradeTime) minutes"

			    #Check to see if the update requires an appliance reboot.
			    if ($_PendingUpdate.rebootRequired) 
				{

			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Appliance reboot required $($_PendingUpdate.rebootRequired)"

			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Prompting for confirmation"

			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Is confirmation overridden $([bool]$confirm)"

					Write-Warning "Reboot required for the update."

			        #If it does require a reboot, then we need to prompt for confirmation. Overriden by -confirm:$false
			        if ($pscmdlet.ShouldProcess($_Connection.Name,"upgrade appliance using $($_PendingUpdate.fileName)")) 
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Appliance reboot required and user selected YES or passed -Confirm:`$false, executing Invoke-Upgrade"

						Try
						{

							$_resp = Invoke-Upgrade $_PendingUpdate

						}

						Catch
						{

							$PSCmdlet.ThrowTerminatingError($_)

						}
						
					}

					else 
					{

						if ($PSBoundParameters['whatif']) 
						{ 

			                write-warning "-WhatIf was passed, would have initiated appliance update."

			                $resp = $null

			            }

			            else 
						{

			    	        #If here, user chose "No", end processing
			    	        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - User selected NO."

			                $resp = $Null

			            }

					}

			    }

			    else
				{
					 
			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Appliance reboot NOT required, executing Invoke-Upgrade"
					
					Try
					{

						$_resp = Invoke-Upgrade $_PendingUpdate

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

			    }

				$resp

			}

		}

	}

	End
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Finished"

    }

}

function Invoke-Upgrade  
{
	[CmdletBinding()]
	Param 
	(

		[parameter(Mandatory = $true)]
		[ValidateNotNullorEmpty()]
		[Object]$PendingUpdate

	)

    Begin 
	{
	
	    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		$_FinalStatus = $null

	}

	Process 
	{

		Try
		{

			$_updateTask = Send-HPOVRequest ("$script:applUpdatePending"+"?file=$($pendingUpdate.fileName)") PUT -Hostname $PendingUpdate.ApplianceConnection.Name

		}
		
		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

        $sw = [System.Diagnostics.Stopwatch]::StartNew()

        #Loop to display progress-bar
        Do 
		{

            #Connect to update monitor web process
			Try
			{

				$_MonitorUpdate = Send-HPOVRequest $applUpdateMonitor -Hostname $PendingUpdate.ApplianceConnection.Name

			}
		
			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}
                        
            #Remove % from value in order to get INT
            if ($_MonitorUpdate.percentageCompletion) 
			{ 
				
				$percentComplete = $monitorUpdate.percentageCompletion.replace("%","") 
			
			}
            
			else 
			{ 
				
				$percentComplete = 0 
			
			}
                        
            #Remove " State = " to get proper status
            if ($_MonitorUpdate.status) 
			{ 
				
				$updateStatus = $monitorUpdate.status -replace " ","" -replace "State=","" 
			
			}

            else 
			{ 
				
				$updateStatus = "Starting" 
			
			}

			$sw = [System.Diagnostics.Stopwatch]::StartNew()		    
            
			#Handle the call from -Verbose so Write-Progress does not get borked on display.
            if ($PSBoundParameters['Verbose'] -or $VerbosePreference -eq 'Continue') 
			{ 
				
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Skipping Write-Progress display."  

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Update Status: Installing appliance update $($PendingUpdate.version), $updateStatus $percentComplete% [$($sw.elapsed.minutes)min $($sw.elapsed.seconds)sec]"  
			
			}
                          
		    else 
			{ 
				
				Write-Progress -id 1 -activity "Installing appliance update $updateVersion " -status "$updateStatus $percentComplete% [$($sw.elapsed.minutes)min $($sw.elapsed.seconds)sec]" -percentComplete $percentComplete 
			
			}

			if ($updateStatus -eq "UpdateReboot") 
			{

				#Handle the call from -Verbose so Write-Progress does not get borked on display.
				if ($PSBoundParameters['Verbose'] -or $VerbosePreference -eq 'Continue') 
				{ 

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] pausing for 5 minutes while appliance reboots. Invoking Start-Sleep"
					
					Start-Sleep -Seconds 300

				}

				else 
				{ 
					
					$time = 300

					foreach ($i in (1..$time)) 
					{

					    $percentage = $i / $time
				        
						Write-Progress -id 1 -activity "Installing appliance update $updateVersion " -status "$updateStatus $percentComplete% [$($sw.elapsed.minutes)min $($sw.elapsed.seconds)sec]" -percentComplete $percentComplete

						Write-Progress -id 2 -parent 1 -activity "Appliance Rebooting" -status "Pausing for 5 minutes" -percentComplete ($percentage * 100) -SecondsRemaining ($time - $i)

					    Start-Sleep 1

					}
						
					Write-Progress -id 2 -parent 1 -activity "Appliance Rebooting" -status "Pausing for 5 minutes" -Completed			
					
				}

			}

        } Until ([int]$percentComplete -eq 100)
                
        $sw.Stop()

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Upgrade operation took $($sw.elapsed.minutes)min, $($sw.elapsed.seconds)sec."

        #Retrieve final update status
        Try
		{

			$_FinalStatus = Send-HPOVRequest $applUpdateNotification -Hostname $PendingUpdate.ApplianceConnection.Name

		}

		Catch
		{

			$PScmdlet.ThrowTerminatingError($_)

		}

        Write-Progress -activity "Installing appliance update $updateVersion " -status $updateStatus -percentComplete $percentComplete

		Write-Progress -activity "Installing appliance update $updateVersion " -status $updateStatus -Completed

    }

	End 
	{

		Return $_FinalStatus

    }

}

function Remove-HPOVPendingUpdate 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding(DefaultParameterSetName = 'Default', SupportsShouldProcess = $True,ConfirmImpact = 'High')]
	Param 
	(
	
		[parameter(Mandatory = $false, ParameterSetName = "Default")]
		[ValidateNotNullorEmpty()]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}
	
	)

    Begin 
	{
    
        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		if  ($ApplianceConnection.Count -eq 0)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoAuthSessionFound InvalidArgument 'ApplianceConnection' -Message 'No ApplianceConnections were found.  Please use Connect-HPOVMgmt to establish an appliance connection.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_ColStatus = New-Object System.Collections.ArrayList
    
    }

    Process 
	{ 

		ForEach ($_Connection in $ApplianceConnection)
		{
			
			$_resp = $null

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($Connection.Name)' Appliance (of $($ApplianceConnection.Count))"

			#Check to see if ane existing update is present.  Report to user if it is, and tell them to use -InstallNow
			Try
			{
				
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Checking if pending update exists"

				$_PendingUpdate = Send-HPOVRequest $applUpdatePending -Hostname $_Connection

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}
			
			if ($_PendingUpdate)
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Update found $($_PendingUpdate.fileName), $($_PendingUpdate.version)"

				$_PendingUpdate.PSObject.TypeNames.Insert(0,'HPOneView.Appliance.Update.Pending')

				$_PendingUpdate

				if ($pscmdlet.ShouldProcess($_Connection.Name,'remove pending update, $($pendingUpdate.fileName) from appliance')) 
				{

				    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Removing pending update from applinace."

					Try
					{
						
						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Checking if pending update exists"

						$_resp = Send-HPOVRequest $applUpdatePending DELETE -Hostname $_Connection

						[void]$_ColStatus.Add($_resp)

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

				}

				else 
				{

				    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No pending update found"

				}

			}

		}

	}

    End 
	{ 
    
		Return $_ColStatus

    }

}

function Get-HPOVVersion 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding(DefaultParameterSetName = 'Default')]
	Param
	(

		[parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [switch]$ApplianceVer,

		[parameter(Mandatory = $false, ParameterSetName = 'Default')]
		[parameter(Mandatory = $false, ParameterSetName = 'CheckOnlineOnly')]
        [switch]$CheckOnline,

		[parameter(Position = 0, Mandatory = $false, ParameterSetName = 'Default')]
		[ValidateNotNullorEmpty()]
		[Alias('appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

	)
	
	Begin 
	{
	
		
		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if  ($ApplianceConnection.Count -eq 0 -and (-not($PSBoundParameters['CheckOnline'])))
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoAuthSessionFound InvalidArgument 'ApplianceConnection' -Message 'No ApplianceConnections were found.  Please use Connect-HPOVMgmt to establish an appliance connection.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif ($PSBoundParameters['ApplianceVer'])
		{

			$c = 0

			ForEach ($_Connection in $ApplianceConnection) 
			{

				Try 
				{
			
					$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

				}

				Catch [HPOneview.Appliance.AuthSessionException] 
				{

					$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				Catch 
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

				$c++

			}

		}

		$_ApplianceVersionCollection = New-Object System.Collections.ArrayList
	
	}
    
    Process 
	{

        $versionInfo = [PSCustomObject]@{ 

            "OneViewPowerShellLibrary" = $script:ModuleVersion.ToString();
            "libraryLoadedPath"        = (split-path -parent (get-module -Name HPOneView.200).path)

        }

		$versionInfo | % { $_.PSObject.TypeNames.insert(0,'HPOneView.Appliance.Version.Base') }
		
		$versionInfo

        #If the user provided the -Appliance switch, display the appliance and X-API versions
        If ($PSBoundParameters['ApplianceVer'])
		{

			ForEach ($_connection in $ApplianceConnection)
			{
			
				$_applianceversioninfo = NewObject -ApplianceVersion

				$applVersionInfo = Send-HPOVRequest $script:applVersion -Hostname $_connection

				$_applianceversioninfo.applianceName    = $_connection.Name
				$_applianceversioninfo.softwareVersion  = $applVersionInfo.softwareVersion 
				$_applianceversioninfo.major            = $applVersionInfo.major
				$_applianceversioninfo.minor            = $applVersionInfo.minor
				$_applianceversioninfo.xapiVersion      = (Get-HPOVXApiVersion -ApplianceConnection $_connection).currentVersion
				$_applianceversioninfo.modelNumber      = $applVersionInfo.modelNumber
				
				$_applianceversioninfo.PSObject.TypeNames.insert(0,'HPOneView.Appliance.Version.Extended')
			
				[void]$_ApplianceVersionCollection.Add($_applianceversioninfo)
			
			}

			if ($_ApplianceVersionCollection.Count -gt 0)
			{

				$_ApplianceVersionCollection

			}

        }

        if ($PSboundParameters['CheckOnline']) 
		{

            try 
			{ 

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Testing for Proxy settings"

				[Uri]$_ProxyUri = $null

				$_Options = @{Uri = $script:repository}

				$_Proxy = [System.Net.WebRequest]::GetSystemWebProxy()

				$_Proxy.Credentials = [System.Net.CredentialCache]::DefaultCredentials
				$_ProxyUri = $_Proxy.GetProxy($_Options.Uri)

				if ($_ProxyUri.OriginalString -ne $_Options.Uri)
				{

					$_Options.Add('Proxy',$_proxyUri)
					$_Options.Add('ProxyUseDefaultCredentials', $true)
					
				}

				$_OriginalProgressPreference = $ProgressPreference
				
				#Hide the display of Write-Progress Invoke-RestMethod displays
				$ProgressPreference = 'silentlyContinue'
                
				$resp = Invoke-RestMethod @_Options

				$ProgressPreference = $_OriginalProgressPreference

                $versionMajorMinor = "$($ModuleVersion.major).$($ModuleVersion.minor)"

                #filter for versions that match Major and Minor release, and exclude the HP VCM to OneView Migration Tool
                $matchedVersions = $resp | ? { $_.tag_name -like "v$versionMajorMinor*" -and (-not($_.tag_name.startswith('HPVCtoOV'))) -and (-not($_.tag_name.startswith('HPSIMtoOV'))) } 

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Found versions online: $($matchedVersions.tag_name -join ", ")"

                $newerVersion = $false

                #Compare the releases
                $matchedVersions | % { 
    
                    if ($newerVersion) 
					{ 
						
						write-verbose "Found previous version to compare: $newerVersion" 
					
					}

                    [version]$version = $_.tag_name -replace "v","" 

                    write-verbose "Comparing $version to $([version]$versionInfo.OneViewPowerShellLibrary)" 
        
                    #Compare found version with library
                    if (-not($newerVersion) -and $version.build -gt ([version]$versionInfo.OneViewPowerShellLibrary).build) 
					{
            
                        [version]$newerVersion = $version
                        $newerVersionObj = $_

						write-verbose "Newer version found: $newerVersion" 

                    }

                    elseif ($newerVersion.Build -lt $version.Build -and $version.build -gt ([version]$versionInfo.OneViewPowerShellLibrary).build) 
					{

                        [version]$newerVersion = $version
                        $newerVersionObj = $_

						write-verbose "Newer version found: $newerVersion" 

                    }
    
                }

                if ($newerVersion) 
				{ 

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Found $([string]$version)"

                    if ($ReleaseNotes) { $newerVersionObj.body -replace "## ","" -replace "\*","  • " }

                    $caption = "Please Confirm";
                    $message = "You currently have v$($versionInfo.OneViewPowerShellLibrary) installed.  The HP OneView PowerShell Library v$([string]$newerVersion) was found that is newer.  Do you want to download the current version of the HP OneView POSH Library (will open your web browser for you to download)?";
                    $yes     = new-Object System.Management.Automation.Host.ChoiceDescription "&Yes","Open your browser to download latest HP OneView POSH Library version.";
                    $no      = new-Object System.Management.Automation.Host.ChoiceDescription "&No","No, you will do this later.";
                    $choices = [System.Management.Automation.Host.ChoiceDescription[]]($yes,$no);
                    $answer  = $host.ui.PromptForChoice($caption,$message,$choices,0) 

                    switch ($answer)
					{

                        0 
						{

                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Launching users browser to '$($newerVersionObj.html_url)'"
                            
							start "$($newerVersionObj.html_url)"
        
                        }

                    }     
    
                }

                else 
				{ 
                
                    Write-Host " "
                    Write-Host "Library is already up-to-date." 
                    
                }

            }

            catch 
			{

                $errorMessage = "$($_[0].exception.message). $($_[0].exception.InnerException.message)"
                $errorRecord = New-ErrorRecord HPOneView.Library.UpdateConnectionError $_.exception.status ConnectionError 'CheckOnline' -TargetType 'Switch' -Message "$($_[0].exception.message)." -InnerException $_.exception.InnerException
                $PSCmdlet.ThrowTerminatingError($errorRecord)

            }

        }

    }

}

function Get-HPOVHealthStatus 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding()]
	Param 
	(

		[parameter(Position = 0, Mandatory = $false)]
		[Alias('appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

	)

    Begin 
	{ 

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if  ($ApplianceConnection.Count -eq 0)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoAuthSessionFound InvalidArgument 'ApplianceConnection' -Message 'No ApplianceConnections were found.  Please use Connect-HPOVMgmt to establish an appliance connection.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{

				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_HealthStatusCollection = New-Object System.Collections.ArrayList

	}

    Process 
	{

		ForEach ($_connection in $ApplianceConnection)
		{

			$healthStatus = Send-HPOVRequest $applHealthStatus -Hostname $_connection

			$healthStatus.members  | % { 
				
				$_.PSObject.TypeNames.Insert(0,"HPOneView.Appliance.HealthStatus") 
			
				[void]$_HealthStatusCollection.Add($_)

			}

		}
    
    }

    End 
	{

        Return $_HealthStatusCollection | Sort-Object ApplianceConnection.Name,resourceType

    }

}

function Get-HPOVXApiVersion 
{
	
    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding()]
	Param 
	(

		[parameter(Position = 0, Mandatory = $false)]
		[ValidateNotNullorEmpty()]
		[Alias('appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

	)

    Begin 
	{ 

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		$_Connections = New-Object System.Collections.ArrayList

		ForEach ($_connection in $ApplianceConnection)
		{

			switch ($_connection.GetType().Name)
			{

				'Connection' 
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing HPOneView.Appliance.Connection: $($_Connection.Name)"
				
					[void]$_Connections.Add($_connection.Name)
				
				}

				'String'
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing: $_Connection"

					[void]$_Connections.Add($_connection)

				}

			}

		}

		$_XAPICollection = New-Object System.Collections.ArrayList

	}

    Process 
	{

		ForEach ($_connection in $_Connections)
		{

			$_XAPIVersion = Send-HPOVRequest $ApplianceXApiVersionUri -Hostname $_connection

			$_XAPIVersion | % { $_.PSObject.TypeNames.insert(0,'HPOneView.Appliance.XAPIVersion') }

			[void]$_XAPICollection.Add($_XAPIVersion)
        
		}

    }

    End 
	{ 
	
		Return $_XAPICollection
	
	}

}

function Get-HPOVEulaStatus 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding()]
    Param
    (

		[parameter(Position = 0, Mandatory, HelpMessage = "Provide the IP Address or FQDN of the Appliance to connect to.")]
        [ValidateNotNullOrEmpty()]
		[string]$Appliance = $null

    )

	Begin 
	{ 

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		# // TODO Need to create temporary Global:ConnectedSessions after validating it doesn't exist for appliance connection being created.
		# otherwise, cmdlet will fail when making call to REstClient and it performs the SSL validation and flag value in SSLChecked property
		# need to do the same with Set-HPOVEulaStatus
		#Check to see if a connection to the appliance exists
        if (-not(${Global:ConnectedSessions}.Name -contains $Appliance) -and (-not(${Global:ConnectedSessions} | ? Name -eq $Appliance).SessionID))
        {

			write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Appliance Session not found. Running FTS sequence?"

            write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Creating temporary Session object"

            [HPOneView.Appliance.Connection]$_ApplianceConnection = New-Object HPOneView.Appliance.Connection

            $_ApplianceConnection.ConnectionId = 99
			$_ApplianceConnection.Name         = $Appliance
			$_ApplianceConnection.SessionID    = 'TemporaryConnection'
			$_ApplianceConnection.SslChecked   = $true

			[void]${Global:ConnectedSessions}.Add($_ApplianceConnection)

			write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $($_ApplianceConnection | out-string)"
            
        }

		else
		{

			$_ApplianceConnection = ${Global:ConnectedSessions} | ? Name -eq $Appliance

		}

    }

    Process 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting EULA Status from '$($_ApplianceConnection.Name)'."

		Try
		{

			$_eulastatus = Send-HPOVRequest $applEulaStatus -Hostname $_ApplianceConnection.Name

		}

		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

		if ((${Global:ConnectedSessions} | ? Name -eq $_ApplianceConnection.Name).SessionID -eq 'TemporaryConnection')
		{

			write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Removing temporary Session object"

			[void]${Global:ConnectedSessions}.Remove($_ApplianceConnection)

		}
		
	}

    End 
	{ 

        Return $_eulastatus
	
    }

}

function Set-HPOVEulaStatus 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding()]
    Param
    (

		[parameter(Position = 0, Mandatory, HelpMessage = "Provide the IP Address or FQDN of the Appliance to connect to.")]
        [ValidateNotNullOrEmpty()]
		[string]$Appliance = $null,

        [parameter(Position = 1, Mandatory, HelpMessage = "Set to 'yes' to allow HP support access to the appliance, otherwise set to 'no'.")]
        [ValidateNotNullOrEmpty()]
		[ValidateSet('Yes', 'No')]
        [string]$SupportAccess

    )

	Begin 
	{ 

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		#Check to see if a connection to the appliance exists
        if (-not(${Global:ConnectedSessions}.Name -contains $Appliance) -and (-not(${Global:ConnectedSessions} | ? Name -eq $Appliance).SessionID))
        {

			write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Appliance Session not found. Running FTS sequence?"

            write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Creating temporary Session object"

            [HPOneView.Appliance.Connection]$_ApplianceConnection = New-Object HPOneView.Appliance.Connection

			$_ApplianceConnection.ConnectionId = 99
			$_ApplianceConnection.Name         = $Appliance
			$_ApplianceConnection.SessionID    = 'TemporaryConnection'
			$_ApplianceConnection.SslChecked   = $true

            [void]${Global:ConnectedSessions}.Add($_ApplianceConnection)

			write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $($_ApplianceConnection | out-string)"
            
        }

		else
		{

			$_ApplianceConnection = ${Global:ConnectedSessions} | ? Name -eq $Appliance

		}
    
    }

    Process 
	{

		$body = [PSCustomObject]@{
			
			supportAccess = $supportAccess
		
		}

		Try
		{

			$_eulastatus = Send-HPOVRequest $ApplianceEulaSaveUri POST $body -Hostname $_ApplianceConnection.Name

		}

		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

		if ((${Global:ConnectedSessions} | ? Name -eq $_ApplianceConnection.Name).SessionID -eq 'TemporaryConnection')
		{

			write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Removing temporary Session object"

			[void]${Global:ConnectedSessions}.Remove($_ApplianceConnection)

		}
		
	}

    End 
	{ 
	
		Return $_eulastatus
	
    }

}

function Get-HPOVApplianceNetworkConfig 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml
    
    [CmdLetBinding()]
    Param 
	(

        [parameter(Mandatory = $false)]
        [alias("x", "export", 'exportFile')]
        [ValidateScript({split-path $_ | Test-Path})]
        [String]$Location,
		
		[parameter(Mandatory = $false)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}
    
	)

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if  ($ApplianceConnection.Count -eq 0)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoAuthSessionFound InvalidArgument 'ApplianceConnection' -Message 'No ApplianceConnections were found.  Please use Connect-HPOVMgmt to establish an appliance connection.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$ApplianceNetworkConfiguration = New-Object System.Collections.ArrayList
        
	}
	
	Process 
	{

		ForEach ($_connection in $ApplianceConnection)
		{
		
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Appliance Connection $($_connection.Name)"

			Try
			{
			
				$_appliancenetconfig = Send-HPOVRequest $ApplianceConfigUri -Hostname $_connection.Name

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}
		
		
			$_appliancenetconfig | % { $_.PSObject.TypeNames.Insert(0,"HPOneView.Appliance.ApplianceServerConfiguration") }
			$_appliancenetconfig.applianceNetworks | % { $_.PSObject.TypeNames.Insert(0,"HPOneView.Appliance.ApplianceServerConfiguration.ApplianceNetworks") }
		
			[void]$ApplianceNetworkConfiguration.Add($_appliancenetconfig)

		}
    
	}

	End 
	{

		If ($PSBoundParameters['exportFile']) 
		{

			ForEach ($ApplianceConfig in $ApplianceNetworkConfiguration)
			{

				$_filename = $ApplianceConfig.ApplianceConnection.Name + ".json"

				ForEach ($nic in $ApplianceConfig.applianceNetworks) 
				{

					if ($nic.ipv4Type -eq "DHCP") { $nic.app1Ipv4Addr = $null }

					if ($nic.ipv6Type -eq "DHCP") { $nic.app1Ipv6Addr = $null }
				
				}

				$ApplianceConfig = $ApplianceConfig | Select * -ExcludeProperty ApplianceConnection

				$ApplianceConfig | convertto-json  > ($Location + '\' + $_filename)

			}

			
		}
		
		Else 
		{
		
			Return $ApplianceNetworkConfiguration

		}

    }

}

function Get-HPOVApplianceDateTime
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml
    
    [CmdLetBinding()]
    Param 
	(
		
		[parameter(Mandatory = $false)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}
    
	)

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_ApplianceDateTimeCol = New-Object System.Collections.ArrayList
        
	}
	
	Process 
	{

		ForEach ($_connection in $ApplianceConnection)
		{
		
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Appliance Connection $($_connection.Name)"

			Try
			{
			
				$_appliancedatetime = Send-HPOVRequest $ApplianceDateTimeUri -Hostname $_connection.Name

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}
		
		
			$_appliancedatetime | % { $_.PSObject.TypeNames.Insert(0,"HPOneView.Appliance.DateTime") }
		
			[void]$_ApplianceDateTimeCol.Add($_appliancedatetime)

		}
    
	}

	End 
	{

		Return $_ApplianceDateTimeCol	

    }

}

function Set-HPOVApplianceNetworkConfig 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml
       
    [CmdletBinding(DefaultParameterSetName="primary")]
	Param 
	(
        
		[parameter(Position = 0, mandatory=$true, ParameterSetName="secondary")]
        [ValidateScript({$_ -ne "eth0"})]
		[string]$Device,

        [parameter(Position = 1, mandatory=$true, ParameterSetName="secondary")]
        [ValidateSet("Management", "Deployment")]
		[string]$InterfaceName,

		[parameter(Position = 0,mandatory=$false, ParameterSetName="primary")]
        [parameter(Position = 2,mandatory=$true, ParameterSetName="secondary")]
		[string]$Hostname = $null,

		[parameter(Position = 1,mandatory=$false, ParameterSetName="primary")]
        [parameter(Position = 3,mandatory=$false, ParameterSetName="secondary")]
		[string]$Ipv4Type = $null,

		[parameter(Position = 2,mandatory=$false, ParameterSetName="primary")]
        [parameter(Position = 4,mandatory=$false, ParameterSetName="secondary")]
		[string]$Ipv4Addr = $null,

		[parameter(Position = 3,mandatory=$false, ParameterSetName="primary")]
        [parameter(Position = 5,mandatory=$false, ParameterSetName="secondary")]
		[string]$Ipv4Subnet = $null,

		[parameter(Position = 4,mandatory=$false, ParameterSetName="primary")]
        [parameter(Position = 6,mandatory=$false, ParameterSetName="secondary")]
		[string]$Ipv4Gateway = $null,

		[parameter(Position = 5,mandatory=$false, ParameterSetName="primary")]
        [parameter(Position = 7,mandatory=$false, ParameterSetName="secondary")]
		[string]$Ipv6Type = $null,

		[parameter(Position = 6,mandatory=$false, ParameterSetName="primary")]
        [parameter(Position = 8,mandatory=$false, ParameterSetName="secondary")]
		[string]$Ipv6Addr = $null,

		[parameter(Position = 7,mandatory=$false, ParameterSetName="primary")]
        [parameter(Position = 9,mandatory=$false, ParameterSetName="secondary")]
		[string]$ipv6Subnet = $null,

		[parameter(Position = 8,mandatory=$false, ParameterSetName="primary")]
        [parameter(Position = 10,mandatory=$false, ParameterSetName="secondary")]
		[string]$Ipv6Gateway = $null,

		[parameter(mandatory=$false, ParameterSetName="primary")]
        [parameter(mandatory=$false, ParameterSetName="secondary")]
        [alias('overrideDhcpDns')]
		[switch]$OverrideIpv4DhcpDns,

		[parameter(mandatory=$false, ParameterSetName="primary")]
        [parameter(mandatory=$false, ParameterSetName="secondary")]
		[switch]$OverrideIpv6DhcpDns,

		[parameter(Position = 9,mandatory=$false, ParameterSetName="primary")]
        [parameter(Position = 11,mandatory=$false, ParameterSetName="secondary")]
		[string]$DomainName = $null,

		[parameter(Position = 10,mandatory=$false, ParameterSetName="primary")]
        [parameter(Position = 12,mandatory=$false, ParameterSetName="secondary")]
		[Array]$SearchDomains = @(),

		[parameter(Position = 11,mandatory=$false, ParameterSetName="primary")]
        [parameter(Position = 13,mandatory=$false, ParameterSetName="secondary")]
        [alias('nameServers')]
		[Array]$IpV4nameServers = @(),

		[parameter(Position = 12,mandatory=$false, ParameterSetName="primary")]
        [parameter(Position = 14,mandatory=$false, ParameterSetName="secondary")]
		[Array]$IpV6nameServers = @(),

		[parameter(Position = 13,mandatory=$false, ParameterSetName="primary")]
        [parameter(Position = 15,mandatory=$false, ParameterSetName="secondary")]
        [Array]$NtpServers = @(),

        [parameter(mandatory=$true, ParameterSetName="importFile", HelpMessage="Enter the full path and file name for the input file.")]
        [alias("i", "import")]
        [ValidateScript({Test-Path $_})]
        [Object]$importFile,

		[parameter(Mandatory = $true)]
		[ValidateNotNullorEmpty()]
		[object]$ApplianceConnection = $null

    )

	Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if (-not($ApplianceConnection -is [HPOneView.Appliance.Connection]) -and (-not($ApplianceConnection -is [System.String])))
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException InvalidApplianceConnectionDataType InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter is not type [HPOneView.Appliance.Connection] or [System.String].  Please correct this value and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif  ($ApplianceConnection.Count -gt 1)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException MultipleApplianceConnections InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter contains multiple Appliance Connections.  This CMDLET only supports 1 Appliance Connection in the ApplianceConnect parameter value.  Please correct this and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		else
		{

			Try 
			{
	
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError 'ApplianceConnection' -TargetType $ApplianceConnection.GetType().Name -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}

		$colStatus = New-Object System.Collections.ArrayList

    }

    Process 
	{

        #Locate the Enclosure Group specified
        write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Starting"

        # Get the current config (to get ETag & ensure we don't overwrite anything):
		Try
		{

			$_currentconfig = Get-HPOVApplianceNetworkConfig -ApplianceConnection $ApplianceConnection

		}
        
		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

        Switch ($PsCmdlet.ParameterSetName) 
		{
    
            "primary" 
			{

				 Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Looking for Primary interface configuration."
                
				[int]$i = 0
                
				$_deviceIndex = $null
                
				For ($i -eq 0; $i -le ($_currentconfig.applianceNetworks.Count - 1); $i++)
                {

                    if($_currentconfig.applianceNetworks[$i].interfaceName -eq "Appliance")
					{
                        
                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Found interface: $($_currentconfig.applianceNetworks[$i].interfaceName)"
                        
						$_deviceIndex = $i

                        $_configured = $true
                        
                        #break out of for loop
                        break

                    }

                }

            }

            "secondary" 
			{

				[int]$i = 0
				
				$deviceIndex = $NULL
				
				$_configured = $false

                For ($i -eq 0; $i -le ($_currentConfig.applianceNetworks.Count - 1); $i++)
                {
                    
					if($_currentConfig.applianceNetworks[$i].device -eq $device)
					{

						$_deviceIndex = $i
						
						$_configured = $true
						
						break
                    
					}
                
				}

				if (-not($_configured)) 
				{

					Try
					{

						$_freeMacs = Send-HPOVRequest $script:applMacAddresses

					}
					
					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

					if ($_freeMacs.members | ? {$_.device -eq $device})
					{

					    $_macAddr = ($_freeMacs.members | ? {$_.device -eq $device}).macAddress

					    # Update any non-null values that were passed-in:
					    $_secondaryNet = [PSCustomObject]@{

							device     = $device;
							macAddress = $_macAddr

						}

					    if ($hostname)     { $_secondaryNet | Add-Member -NotePropertyName hostname -NotePropertyValue $hostname }
					    if ($ipv4Type)     
						{ 
							
							$_secondaryNet | Add-Member -NotePropertyName ipv4Type -NotePropertyValue $ipv4Type.ToUpper()
					        
							# If setting DHCP, clear any existing IP address:
					        if ($ipv4Type -ieq "DHCP") {$_secondaryNet | Add-Member -NotePropertyName app1Ipv4Addr -NotePropertyValue $null }
					    
						}

					    if ($ipv4Addr)     { $_secondaryNet | Add-Member -NotePropertyName app1Ipv4Addr -NotePropertyValue $ipv4Addr }
					    if ($ipv4Subnet)   { $_secondaryNet | Add-Member -NotePropertyName ipv4Subnet   -NotePropertyValue $ipv4Subnet }
					    if ($ipv4Gateway)  { $_secondaryNet | Add-Member -NotePropertyName ipv4Gateway  -NotePropertyValue $ipv4Gateway }
					    if ($ipv6Type)     
						{ 
							
							$_secondaryNet | Add-Member -NotePropertyName ipv6Type -NotePropertyValue $ipv6Type.ToUpper() 
							
							# If setting DHCP, clear any existing IP address:
							if ($ipv6Type -ieq "DHCP") { $_secondaryNet | Add-Member -NotePropertyName app1Ipv6Addr = $null }
					    
						}

					    if ($ipv6Addr)        { $_secondaryNet | Add-Member -NotePropertyName app1Ipv6Addr -NotePropertyValue $ipv6Addr }
					    if ($ipv6Subnet)      { $_secondaryNet | Add-Member -NotePropertyName ipv6Subnet -NotePropertyValue $ipv6Subnet }
					    if ($ipv6Gateway)     { $_secondaryNet | Add-Member -NotePropertyName ipv6Gateway -NotePropertyValue $ipv6Gateway }
					    if ($overrideDhcpDns) { $_secondaryNet | Add-Member -NotePropertyName overrideDhcpDnsServers -NotePropertyValue $overrideDhcpDns }
					    if ($domainName)      { $_secondaryNet | Add-Member -NotePropertyName domainName -NotePropertyValue $domainName }
					    if ($searchDomains)   { $_secondaryNet | Add-Member -NotePropertyName searchDomains -NotePropertyValue $searchDomains }
					    if ($nameServers)     { $_secondaryNet | Add-Member -NotePropertyName nameServers -NotePropertyValue $nameServers }
					    if ($ntpServers)      { $_currentConfig.time.ntpServers = $ntpServers }

					    # Hard code the following settings, for now:
					    $_secondaryNet | Add-Member -NotePropertyName allowTransientValidationErrors -NotePropertyValue "false" # "true" or "false"
					    $_secondaryNet | Add-Member -NotePropertyName confOneNode -NotePropertyValue "true"  # Always "true", for now
					    $_secondaryNet | Add-Member -NotePropertyName activeNode -NotePropertyValue "1"      # Always "1", for now

					    [void]$_currentConfig.applianceNetworks.Add($_secondaryNet)

					}

					else
					{


					    $errorRecord = New-ErrorRecord InvalidOperationException UnknownNetworkInterface ObjectNotFound 'Device' -Message $device + " does not exist on the appliance."
					    $pscmdlet.ThrowTerminatingError($errorRecord)
					    
                    }

                }

            }
             
			"importFile" 
			{

                try 
				{

                    $_importConfig = [string]::Join("", (gc $importfile -ErrorAction Stop))

                    $_importConfig = $_importConfig -replace "\s","" | convertfrom-json -ErrorAction Stop

				}

				catch [System.Management.Automation.ItemNotFoundException] 
				{
    
                    $errorRecord = New-ErrorRecord System.Management.Automation.ItemNotFoundException ImportFileNotFound ObjectNotFound 'Set-HPOVApplianceNetworkConfig' -Message "$importFile not found!"
                    $pscmdlet.ThrowTerminatingError($errorRecord)
    
                }
    
                catch [System.ArgumentException] 
				{
    
                    $errorRecord = New-ErrorRecord System.ArgumentException InvalidJSON ParseErrror 'Set-HPOVApplianceNetworkConfig' -Message "Input JSON format incorrect!"
                    $pscmdlet.ThrowTerminatingError($errorRecord)    

                }

                Try
				{

					$_freeMacs = Send-HPOVRequest $ApplianceNetworkMacAddrUri -Hostname $ApplianceConnection

				}
					
				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}
    
                [int]$i = 0

                For ($i -eq 0; $i -le ($_importConfig.applianceNetworks.Count - 1); $i++)
                {

                    if ($_importConfig.applianceNetworks[$i].ipv4Gateway -eq "127.0.0.1")
					{

                        $_importConfig.applianceNetworks[$i].ipv4Gateway = $null

                    }

                    if ($_importConfig.applianceNetworks[$i].nameServers -is "String")
					{

                        $_importConfig.applianceNetworks[$i].nameServers = New-Object.System.Collections.ArrayList

                    }

                    if ($_importConfig.applianceNetworks[$i].searchDomains -is "String")
					{

                        $importConfig.applianceNetworks[$i].searchDomains = New-Object.System.Collections.ArrayList

                    }

                    if (-not($_importConfig.applianceNetworks[$i].macAddress)) 
					{

                        $_macAddr = ($_importConfig.applianceNetworks | ? {$_.device -eq $_importConfig.applianceNetworks[$i].device}).macAddress

                        if(-not($_macAddr)) 
						{

                            $_macAddr = ($_freeMacs.members | ? {$_.device -eq $_importConfig.applianceNetworks[$i].device}).macAddress

                        }

                        if(-not($_macAddr))
						{

                            $errorRecord = New-ErrorRecord InvalidOperationException ApplianceNICResourceNotFound ObjectNotFound 'Device' -Message ($_importConfig.applianceNetworks[$i].device + "does not exist on the appliance.")
                            $PsCmdlet.ThrowTerminatingError($errorRecord)

                        }

                        $_importConfig.applianceNetworks[$i] | Add-Member -NotePropertyName macAddress -NotePropertyValue $_macAddr
    
                    }

                }

                #zero the $currentConfig.applianceNetworks array so we can send it all new values
                $_currentConfig.applianceNetworks = New-Object System.Collections.ArrayList

                [void]$_currentConfig.applianceNetworks.Add($_importConfig.applianceNetworks)

            }

        }

        if ($_configured)
		{

            # Update any non-null values that were passed-in:
            
            if ($hostname) 
			{

				 $_currentconfig.applianceNetworks[$_deviceIndex].hostname = $Hostname 

			}

            if ($ipv4Type) 
			{ 
				
				$_currentconfig.applianceNetworks[$_deviceIndex].ipv4Type = $ipv4Type.ToUpper()
                
                # If setting DHCP, clear any existing IP address:
                if ($ipv4Type -ieq "DHCP") 
				{ 

                    $_currentconfig.applianceNetworks[$_deviceIndex].app1Ipv4Addr = $null

                    # If $overrideIPv4DhcpDns is true, set it, if not make sure it is fale
                    if ($overrideIpv4DhcpDns) 
					{ 
						
						$_currentconfig.applianceNetworks[$_deviceIndex].overrideIpv4DhcpDnsServers = [bool]$overrideIpv4DhcpDns 
					
					}

                    else 
					{ 
						
						$_currentconfig.applianceNetworks[$_deviceIndex].overrideIpv4DhcpDnsServers = $false 
					
					}

                }

                elseif ($IPv4Type -ieq "STATIC") 
				{
                    
					#Make sure override.. is false if STATIC ip addresses are in use.
                    $_currentconfig.applianceNetworks[$_deviceIndex].overrideIpv4DhcpDnsServers = $false 

                }

            }

            if ($ipv4Addr)    { $_currentconfig.applianceNetworks[$_deviceIndex].app1Ipv4Addr = $ipv4Addr }
            if ($ipv4Subnet)  { $_currentconfig.applianceNetworks[$_deviceIndex].ipv4Subnet   = $ipv4Subnet }
            if ($ipv4Gateway) { $_currentconfig.applianceNetworks[$_deviceIndex].ipv4Gateway  = $ipv4Gateway }
            if ($ipv6Type)    
			{ 
				
				$_currentconfig.applianceNetworks[$_deviceIndex].ipv6Type     = $ipv6Type.ToUpper() 
                                      
                # If setting DHCP, clear any existing IP address:
                if ($ipv6Type -ieq "DHCP") { $_currentconfig.applianceNetworks[$_deviceIndex].app1Ipv6Addr = $null }

            }
            if ($ipv6Addr)            { $_currentconfig.applianceNetworks[$_deviceIndex].app1Ipv6Addr               = $ipv6Addr }
            if ($ipv6Subnet)          { $_currentconfig.applianceNetworks[$_deviceIndex].ipv6Subnet                 = $ipv6Subnet }
            if ($ipv6Gateway)         { $_currentconfig.applianceNetworks[$_deviceIndex].ipv6Gateway                = $ipv6Gateway }
            if ($overrideIpv4DhcpDns) { $_currentconfig.applianceNetworks[$_deviceIndex].overrideIpv4DhcpDnsServers = [bool]$overrideIpv4DhcpDns }
            if ($overrideIpv6DhcpDns) { $_currentconfig.applianceNetworks[$_deviceIndex].overrideIpv6DhcpDnsServers = [bool]$overrideIpv6DhcpDns }
            if ($domainName)          { $_currentconfig.applianceNetworks[$_deviceIndex].domainName                 = $domainName }
            if ($searchDomains)       { $_currentconfig.applianceNetworks[$_deviceIndex].searchDomains              = $searchDomains }
            if ($ipV4nameServers)     { $_currentconfig.applianceNetworks[$_deviceIndex].ipv4NameServers            = $ipV4nameServers }
            if ($ipV6nameServers)     { $_currentconfig.applianceNetworks[$_deviceIndex].ipv6NameServers            = $ipV6nameServers }
            if ($ntpServers)          { $_currentconfig.time.ntpServers                                             = $ntpServers }

            # Hard code the following settings, for now:
            $_currentconfig.applianceNetworks[$_deviceIndex].confOneNode = "true"  # Always "true", for now
            $_currentconfig.applianceNetworks[$_deviceIndex].activeNode = "1"      # Always "1", for now
        
		}

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Configuration to be applied: $($_currentconfig | fl * | out-string)"

        #Remove MAC Address value or DHCP setting will break
        if ($_currentconfig.macAddress) 
		{ 
			
			$_currentconfig.macAddress = $null 
		
		}

        # This is an asynch method, so get the returned Task object
		Try
		{

			$_task = Send-HPOVRequest $ApplianceNetworkConfigUri POST $_currentconfig -Hostname $ApplianceConnection | Wait-HPOVTaskStart

		}

		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

        #validate status code 200, even though it should be HTTP/202
        if ($_task.type -eq "TaskResourceV2" -and $_task.taskState -eq "Running") 
		{
        
            #Start a new stopwatch object
            $sw = [diagnostics.stopwatch]::StartNew()
                
            Do 
			{

                $_PercentComplete = [Math]::Round(((($sw.Elapsed.Minutes * 60) + $sw.Elapsed.Seconds) / 90) * 100,$MathMode)
                
                if ($PSBoundParameters['Verbose'] -or $VerbosePreference -eq 'Continue') 
				{ 
                    
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Skipping Write-Progress display."
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Percent Complete: $_PercentComplete"
                    Start-Sleep -s 1

                }
                  
                else 
				{

                    #Display progress-bar
                    Write-Progress -activity "Update Appliance Network Configuration" -Status "Processing $_PercentComplete%" -percentComplete $_PercentComplete 

                }

            } until ($_PercentComplete -eq 100)

            #Stop the stopwatch
            $sw.stop()
            
            Write-Progress -activity "Update Appliance Network Configuration" -Completed
        
        }

        #task failed validation
        elseif ($_task.taskState -eq "Error") 
		{

            if ($_task.taskErrors -is [Array] -and $_task.taskErrors.count -gt 1 ) 
			{

                for ($e = 0; $e -gt $_task.taskErrors.count; $e++) 
				{

                    if ($e -ne $_task.taskErrors.length) 
					{
                        
                        $errorRecord = New-ErrorRecord HPOneView.Appliance.NetworkConfigurationException NoAuthSession AuthenticationError 'Set-HPOVApplianceNetworkConfig' -Message "No valid session ID found.  Please use Connect-HPOVMgmt to connect and authenticate to an appliance."
                        $PsCmdlet.WriteError($errorRecord)    

                    }

                    else 
					{

                        $errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoAuthSession AuthenticationError 'Set-HPOVApplianceNetworkConfig' -Message "No valid session ID found.  Please use Connect-HPOVMgmt to connect and authenticate to an appliance."
                        $PsCmdlet.ThrowTerminatingError($errorRecord)    

                    }

                }

            }

        }

        if ($ipv4Type -eq "static") 
		{
            
            #Check to make sure we connect to a OneView appliance
			Try
			{
				
				#Temporarily disable SSL Cert verification to handle HTTP redirection to HTTPS
				#save the ServicePointManager configuration state to restore after our Invoke-WebRequest call
				$_originalcertpolicy = [System.Net.ServicePointManager]::CertificatePolicy
				[System.Net.ServicePointManager]::CertificatePolicy = new-object HPOneView.ITempPolicy 
				
				$_resp = Invoke-WebRequest -uri "https://$ipv4Addr"

				#Return the ServicePointManager state back to original state
				[System.Net.ServicePointManager]::CertificatePolicy = $_originalcertpolicy

			}

			Catch
			{

				#Return the ServicePointManager state back to original state
				[System.Net.ServicePointManager]::CertificatePolicy = $_originalcertpolicy

				$PSCmdlet.ThrowTerminatingError($_)

			}
            

            #If successful, update current POSH session
            if ($_resp.Content -match "OneView") 
			{ 

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Updating Global Connection Sessions appliance object with new appliance address: $ipv4Addr"

				($Global:ConnectedSessions | ? name -eq $ApplianceConnection.Name).Name = $ipv4Addr

            }

            else 
			{

                #Unable to connect to new appliance address or connection failed.  Need to generate error here.
				$errorRecord = New-ErrorRecord HPOneview.Appliance.NetworkConnectionException ApplianceUnreachable ConnectionError 'Set-HPOVApplianceNetworkConfig' -Message "Unable to reconnect to the appliance.  Please check to make sure there are no IP Address conflicts or your set the IP Address and Subnet Mask correctly."
                $PsCmdlet.ThrowTerminatingError($errorRecord)    

            }

        }

		#Check to see if we can get the final status of the task resource
		Try
		{

			$Task = Send-HPOVRequest $_task.uri -Hostname $ApplianceConnection.Name | Wait-HPOVTaskComplete 

		}

		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

        [void]$colStatus.Add($Task)

    }

	End
	{

		Return $colStatus

	}

}

function Get-HPOVSnmpReadCommunity 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml
    
	[CmdletBinding()]
	Param 
	(
	
		[parameter(Mandatory = $false)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}
	
	)

	Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if  ($ApplianceConnection.Count -eq 0)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoAuthSessionFound InvalidArgument 'ApplianceConnection' -Message 'No ApplianceConnections were found.  Please use Connect-HPOVMgmt to establish an appliance connection.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_ApplianceSnmpConfigCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_Connection.Name)' Appliance (of $($ApplianceConnection.Count))"

			Try
			{

				$_applSnmpReadCommunityStr = Send-HPOVRequest $applSnmpReadCommunity -Hostname $_Connection

				$_applSnmpReadCommunityStr.PSObject.TypeNames.Insert(0,'HPOneView.Appliance.SnmpCommunity')

				[void]$_ApplianceSnmpConfigCollection.Add($_applSnmpReadCommunityStr)

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}
			

		}
    
    }

	End
	{

		Return $_ApplianceSnmpConfigCollection

	}

}

function Set-HPOVSnmpReadCommunity 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding()]
	Param 
	(

		[parameter(Position= 0, Mandatory)]
		[string]$name = $null,
			
		[parameter(Mandatory = $false)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}
	
	)

	Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if  ($ApplianceConnection.Count -eq 0)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoAuthSessionFound InvalidArgument 'ApplianceConnection' -Message 'No ApplianceConnections were found.  Please use Connect-HPOVMgmt to establish an appliance connection.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_ApplianceSnmpConfigCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_Connection.Name)' Appliance (of $($ApplianceConnection.Count))"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] New SNMP Read Community Value: $($name)"
			
			$_NewApplSnmpReadCommunityStr = [PsCustomObject]@{ "communityString" = $name }

			Try
			{

				$_rspNewApplSnmpReadCommunity = Send-HPOVRequest $applSnmpReadCommunity PUT $_NewApplSnmpReadCommunityStr -Hostname $_Connection

				$_rspNewApplSnmpReadCommunity.PSObject.TypeNames.Insert(0,'HPOneView.Appliance.SnmpCommunity')

				[void]$_ApplianceSnmpConfigCollection.Add($_rspNewApplSnmpReadCommunity)

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}
    
    }

	End
	{

		Return $_ApplianceSnmpConfigCollection

	}

}

function Get-HPOVApplianceGlobalSetting 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding()]
	Param 
	(

		[parameter(Position = 0, Mandatory = $false)]
		[string]$name = $null,
			
		[parameter(Mandatory = $false)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}
	
	)

	Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if  ($ApplianceConnection.Count -eq 0)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoAuthSessionFound InvalidArgument 'ApplianceConnection' -Message 'No ApplianceConnections were found.  Please use Connect-HPOVMgmt to establish an appliance connection.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_ApplianceGlobalSettingCol = New-Object System.Collections.ArrayList

    }

    Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_Connection.Name)' Appliance (of $($ApplianceConnection.Count))"

			Try
			{

				$_settings = Send-HPOVRequest $ApplianceGlobalSettingsUri -Hostname $_Connection

				if ($Name)
				{

					$_settings.members = $settings.members | Where-Object name -like $Name

				}

				$_settings.members | % {

					[void]$_ApplianceGlobalSettingCol.Add($_)

				}

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}
			
		}

    }

	End
	{

		Return $_ApplianceGlobalSettingCol

	}

}

function Set-HPOVApplianceGlobalSetting 
{

   # .ExternalHelp HPOneView.200.psm1-help.xml
      
    [CmdletBinding(DefaultParameterSetName = 'Default')]
	Param
	(

		[parameter(Position = 0, Mandatory, ValueFromPipeline, HelpMessage = "Enter the name of the global parameter", ParameterSetName = 'Pipeline')]
		[string]$Object,

		[parameter(Position = 0, Mandatory, HelpMessage = "Enter the name of the global parameter", ParameterSetName = 'Default')]
		[string]$Name,

        [parameter(Position = 1, Mandatory = $true, HelpMessage = "Enter the new value for the global parameter", ParameterSetName = 'Default')]
        [string]$Value,

		[parameter(Mandatory = $false, ValueFromPipelinebyPropertyName, ParameterSetName = 'Default')]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

	)

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if ($PSCmdlet.ParameterSetName -eq 'Pipeline')
		{

			$PipelineInput - $True

		}

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_ApplianceGlobalSettingCol = New-Object System.Collections.ArrayList

    }

    Process 
	{

		if ($PipelineInput)
		{

			#Error due to invalid object from pipeline
			if ($Object.category -ne 'global-settings')
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.GlobalSettingException InvalidGlobalSettingObject InvalidArgument 'Object' -TargetType 'PSObject' -Message "The '$(Object.name)' is an invalid Global Setting object.  Please check the value and try again."
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			#Error because Connection object doesn't exist
			if (-not($Object.category.ApplianceConnection.Name.Legth -gt 0))
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.GlobalSettingException InvalidGlobalSettingObject InvalidArgument 'Object' -TargetType 'PSObject' -Message "The Global Setting '$(Object.name)' object is missing a required property, ApplianceConnection. Please validate the input object contains the 'ApplianceConnection' property and it contains a valid Appliance Connection Name."
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing object: $($Object.Name)"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing object: $($Object | FL * | Out-String)"

			Try
			{

				$Object.value = $Value

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Updated Global Setting: $($Object | out-string)"

				$_results = Send-HPOVRequest $Object.uri PUT $Object -Hostname $Object.ApplianceConnection.Name

				[void]$_ApplianceGlobalSettingCol.Add($_results)

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}

		else
		{

			ForEach ($_Connection in $ApplianceConnection)
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_Connection.Name)' Appliance (of $($ApplianceConnection.Count))"

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting current global setting value for $Name"

				Try
				{

					$setting = Get-HPOVApplianceGlobalSetting($name)

					$setting.value = $Value

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Updated Global Setting: $($setting | out-string)"

					$_results = Send-HPOVRequest $setting.uri PUT $setting -Hostname $_Connection

					[void]$_ApplianceGlobalSettingCol.Add($_results)

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

				
			}

		}

    }

	End
	{

		Return $_ApplianceGlobalSettingCol

	}

}

function Get-HPOVBaseline 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

   	[CmdletBinding(DefaultParameterSetName = "ISOFileName" )]
	Param 
	(

		[parameter(Position = 0, Mandatory = $false, ParameterSetName = "ISOFileName")]
        [ValidateNotNullOrEmpty()]
        [Alias('isoFileName')]
		[string]$FileName,

		[parameter(position = 0, Mandatory = $false, ParameterSetName = "SppName")]
		[Alias('name')]
        [string]$SppName,

		[parameter(Position = 1, Mandatory = $false, ParameterSetName = "SppName")]
        [ValidateNotNullOrEmpty()]
		[string]$Version,

		[parameter(Position = 1, Mandatory = $false, ParameterSetName = "HotFixesOnly")]
		[switch]$HotfixesOnly,

		[parameter(Mandatory = $false, HelpMessage = "Enter the Appliance Name or Object")]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

	)

    Begin 
    {
        
        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if  ($ApplianceConnection.Count -eq 0)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoAuthSessionFound InvalidArgument 'ApplianceConnection' -Message 'No ApplianceConnections were found.  Please use Connect-HPOVMgmt to establish an appliance connection.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$BaselineCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{
        
		ForEach($_Connection in $ApplianceConnection)
		{

			Try
			{

				$_baselines = Send-HPOVRequest $fwDriversUri -appliance $_Connection

			}

			Catch
			{

				$PScmdlet.ThrowTerminatingError($_)

			}

			switch ($PSCmdlet.ParameterSetName) 
			{
			    
			    "SppName" 
				{
			    
			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] SppName parameter provided: $($SppName)"

			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Version parameter provided: $($version)"

			        if ($version) 
					{
						
						$_baselines.members = $_baselines.members | ? version -eq $version
					
					}

			        else 
					{
						
						$_baselines.members = $_baselines.members | ? name -like $SppName 
					
					}

			        if ((-not ($_baselines.members)) -and $SppName) 
					{

			            $errorRecord = New-ErrorRecord HPOneView.BaselineResourceException BaselineResourceNotFound ObjectNotFound 'SppName' -Message "The Baseline name '$SppName' was not found."
			            $PSCmdlet.ThrowTerminatingError($errorRecord)

			        }
			        elseif ((-not ($_baselines.members)) -and $version) 
					{

			            $errorRecord = New-ErrorRecord HPOneView.BaselineResourceException BaselineResourceNotFound ObjectNotFound 'SppName' -Message "The Baseline name '$SppName' with version $version was not found."
			            $PSCmdlet.ThrowTerminatingError($errorRecord)

			        }
			
			    }
			
			    "ISOFileName" 
				{

			        if ($FileName) 
					{ 
						
						$_baselines.members = $_baselines.members | ? isoFileName -like $FileName
					
					}

			        if (-not ($_baselines.members)) 
					{

			            $errorRecord = New-ErrorRecord HPOneView.BaselineResourceException BaselineResourceNotFound ObjectNotFound 'isoFileName' -Message "The Baseline ISO '$isoFileName' was not found."
			            $PSCmdlet.ThrowTerminatingError($errorRecord)

			        }

			    }

				'HotfixesOnly'
				{

					$_baselines.members = $_baselines.members | ? bundleType -eq 'Hotfix'

				}
			
			    default 
				{
			
			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No parameter provided. Looking for all SPP Baselines."

			    }
			
			}

			foreach ($_baseline in $_baselines.members)
			{
			

				$_baseline.PSObject.TypeNames.Insert(0,'HPOneView.Appliance.Baseline')

				[void]$BaselineCollection.Add($_baseline)

			}

        }

    }

    End 
	{
        
        if ($BaselineCollection.count -eq 0) { Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No Baselines/SPP's found." }

		return $BaselineCollection

    }

}

function Add-HPOVBaseline 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding()]
	Param 
	(

		[parameter(Position = 0, Mandatory = $true, HelpMessage = "Enter the path and file name to the SPP iso file.")]
        [ValidateScript({Test-Path $_})]
		[Alias('sppFile')]
		[string]$File,

		[parameter(Mandatory = $false)]
		[switch]$Async,

		[parameter(Mandatory = $false, HelpMessage = "Enter the Appliance Name or Object")]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

	)

    Begin 
    {
        
        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if  ($ApplianceConnection.Count -eq 0)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoAuthSessionFound InvalidArgument 'ApplianceConnection' -Message 'No ApplianceConnections were found.  Please use Connect-HPOVMgmt to establish an appliance connection.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$TaskCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{
        
		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Appliance $($_Connection.Name)"

			#Start upload file
			Try
			{

				$task = Upload-File $fwUploadUri $File $_Connection

				if (-not($PSBoundParameters['Async']))
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Response is a task resource, calling Wait-HPOVTaskComplete"

					$task = $task | Wait-HPOVTaskComplete

				}
				
				[void]$TaskCollection.Add($task)

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}
        
		}

    }
	
	End 
	{
	
		Return $TaskCollection
	
	}

}

function New-HPOVCustomBaseline
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding()]
	Param 
	(

		[parameter(Position = 0, Mandatory, ValueFromPipeline, HelpMessage = "Enter the path and file name to the SPP iso file.")]
        [ValidateNotNullorEmpty()]
		[Object]$SourceBaseline,

		[parameter(Position = 1, Mandatory)]
		[Array]$Hotfixes,

		[parameter(Position = 2, Mandatory)]
		[String]$BaselineName,

		[parameter(Mandatory, ValueFromPipelineByPropertyName, HelpMessage = "Enter the Appliance Name or Object")]
		[Alias('Appliance')]
		[Object]$ApplianceConnection

	)

    Begin 
    {
        
        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSBoundParameters['SourceBaseline']))
		{

			$PipelineInput = $True

		}

		else
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

			Try 
			{
	
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}

		$TaskCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{
        
		$_CustomBaseline = NewObject -CustomBaseline

		#Validate Source Baseline
		switch ($SourceBaseline.GetType().Name)
		{

			'PSCustomObject'
			{
				
				if ($SourceBaseline.category -ne 'firmwware-drivers')
				{

					$errorRecord = New-ErrorRecord HPOneView.BaselineResourceException InvalidBaselineResource InvalidArgument 'SourceBaseline' -TargetObject 'PSObject' -Message "The provided SourceBaseline object is not the required category, 'firmware-drivers'. Please correct the input parameter."
			        $PSCmdlet.ThrowTerminatingError($errorRecord)

				}
				
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Baseline Object Provided"
				"[$($MyInvocation.InvocationName.ToString().ToUpper())] Baseline Name: {0}" -f $SourceBaseline.shortName | Write-Verbose
				"[$($MyInvocation.InvocationName.ToString().ToUpper())] Baseline URI: {0}" -f $SourceBaseline.uri | Write-Verbose

			}

			'String'
			{

				"[$($MyInvocation.InvocationName.ToString().ToUpper())] Baseline Name Provided: {0}" -f $SourceBaseline | Write-Verbose

				#Get Source Baseline from Basline Name
				Try
				{

					$SourceBaseline = Get-HPOVBaseline -SppName $SourceBaseline -ApplianceConnection $ApplianceConnection

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}
				
			}

		}
		
		#Loop through Hotfixes
		ForEach ($_HotFix in $Hotfixes)
		{

			"[$($MyInvocation.InvocationName.ToString().ToUpper())] Hotfix Name Provided: {0}" -f $_HotFix | Write-Verbose

			#Get Source Baseline from Basline Name
			Try
			{

				$_HotfixResourceName = ($_Hotfix.ToLower().Split('\.'))[0]
				$_HotFixObj = Send-HPOVRequest /rest/firmware-drivers/$_HotfixResourceName -Hostname $ApplianceConnection.Name

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			[void]$_CustomBaseline.hotfixUris.Add($_HotFixObj.uri)

		}

		$_CustomBaseline.baselineUri        = $SourceBaseline.uri
		$_CustomBaseline.customBaselineName = $BaselineName
		
		#Post the new object to the appliancenvocationName.ToString().ToUpper())] Processing Appliance $($_Connection.Name)"
		Try
		{

			$_Resp = Send-HPOVRequest $fwDriversUri POST $_CustomBaseline -Hostname $ApplianceConnection.Name

			[void]$TaskCollection.Add($_Resp)

		}

		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

    }
	
	End 
	{
	
		Return $TaskCollection
	
	}

}

function Restore-HPOVCustomBaseline
{

	# .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding()]
	param 
	(
	
		[parameter(Mandatory = $False, position = 0)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectionSessions}
	
	)

    Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if  ($ApplianceConnection.Count -eq 0)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoAuthSessionFound InvalidArgument 'ApplianceConnection' -Message 'No ApplianceConnections were found.  Please use Connect-HPOVMgmt to establish an appliance connection.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_TaskCollection     = New-Object System.Collections.ArrayList
		$_BaselineCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Appliance $($_Connection.Name) (of $($ApplianceConnection.Count))"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting all baseline resources"

			Try
			{

				$_baselineresources = Send-HPOVRequest $fwUploadUri -Hostname $_Connection

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}
			
			foreach ($_baseline in ($_baselineresources.members | ? bundleType -eq 'Custom' -and state -eq 'Removed'))
			{

				$_CustomBaselineRestore = NewObject -CustomBaselineRestore

				$_CustomBaselineRestore.baselineUri        = $_baseline.uri	
				$_CustomBaselineRestore.customBaselineName = $_baseline.name

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper()) Looking up Associations for '$($_baseline.name) [$($_baseline.uuid)]' custom baseline."

				Try
				{

					$_baselineassociations = Send-HPOVRequest "/rest/index/associations/?parentUri=$($_baseline.uri)" -Hostname $_Connection

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

				foreach ($_association in $_baselineassociations.members)
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper()) Adding '$($_association.childUri)' to object collection."

					[void]$_CustomBaselineRestore.hotfixUris.Add($_association.childUri)

				}

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper()) Sending request to recreate '$_CustomBaselineRestore.customBaselineName' custom baseline."

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper()) Custom Baseline object: $($_CustomBaselineRestore | FL * | Out-String)"

				Try
				{

					$_resp = Send-HPOVRequest $fwUploadUri $_CustomBaselineRestore -Hostname $_Connection

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

				[void]$_TaskCollection.Add($_resp)
				
			}				

		}
        
    }

	End
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] done."

		Return $_TaskCollection

	}


}

function Remove-HPOVBaseline
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding(DefaultParameterSetName = "default", SupportsShouldProcess = $True, ConfirmImpact = 'High')]
	param
	(

		[parameter(Mandatory, ValueFromPipeline, HelpMessage = "Enter the Baseline name", Position = 0, ParameterSetName = "default")]
		[ValidateNotNullOrEmpty()]
		[alias("b")]
		[Object]$Baseline,
	
		[parameter(Mandatory = $False, ValueFromPipelineByPropertyName, ParameterSetName = "default", position = 1)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

    )

    Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		if (-not($PSBoundParameters['Baseline'])) { $PipelineInput = $True }

		$_TaskCollection     = New-Object System.Collections.ArrayList
		$_BaselineCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{

		if ($PipelineInput) 
		{ 

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Pipeline input"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Directory Object provided: $($Baseline | FL * | Out-String)"

			If ($Baseline.category -eq 'firmware-drivers')
			{

				If (-not($Baseline.ApplianceConnection))
				{

					$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument "Baseline:$($Baseline.Name)" -TargetType PSObject -Message "The Baseline resource provided is missing the source ApplianceConnection property.  Please check the object provided and try again."
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				[void]$_BaselineCollection.Add($Baseline)

			}

			else
			{

				$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument "Baseline:$($Baseline.Name)" -TargetType PSObject -Message "The Baseline resource is not an expected category type [$($Baseline.category)].  Allowed resource category type is 'firmware-drivers'.  Please check the object provided and try again."
                $PSCmdlet.ThrowTerminatingError($errorRecord)

			}
        
		}

		else 
		{

			ForEach ($_Connection in $ApplianceConnection)
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Appliance $($_Connection.Name) (of $($ApplianceConnection.Count))"

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Baseline Name $($Baseline)"

				if ($Baseline -is [String])
				{

					Try
					{

						$Baseline = Get-HPOVBaseline -SppName $Baseline -ApplianceConnection $_Connection

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)					

					}

				}
				
				$Baseline | % {

					[void]$_BaselineCollection.Add($_)

				}

			}

		}
        
    }

	End
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing $($_BaselineCollection.count) Baseline resources to remove."

		#Process Directory Resources
		ForEach ($_Baseline in $_BaselineCollection)
		{

			if ($pscmdlet.ShouldProcess($_Baseline.ApplianceConnection.Name,"remove baseline '$($_Baseline.name)'")) 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Removing Baseline '$($_Baseline.name)' from appliance '$($_Baseline.ApplianceConnection.Name)'."

				Try
				{
					
					$_resp = Send-HPOVRequest $_Baseline.Uri DELETE -Hostname $_Baseline.ApplianceConnection.Name

					[void]$_TaskCollection.Add($_resp)

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

			}

			elseif ($PSBoundParameters['WhatIf'])
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] WhatIf parameter was passed."

			}

		}

		Return $_TaskCollection

	}

}

function New-HPOVSupportDump 
{

	# .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "values")]
    Param 
	(

        [parameter(Mandatory = $false,ValueFromPipeline = $false, ParameterSetName = "values", HelpMessage = "Specify the folder location to save the Support Dump.",Position=0)]
		[parameter(Mandatory = $false,ValueFromPipeline = $false, ParameterSetName = "Object", HelpMessage = "Specify the folder location to save the Support Dump.",Position=0)]
        [Alias("save")]
        [string]$Location = (get-location).Path,

        [parameter(Mandatory = $true,ValueFromPipeline = $false, ParameterSetName = "values", HelpMessage = "Specify the Type of Support Dump (appliance | li) you wish to generate.", Position = 1)]
        [ValidateSet("Appliance","LI")]
        [string]$Type = $null,

		[parameter(Mandatory = $false,ValueFromPipeline = $false, ParameterSetName = "values", HelpMessage = "Specfy to encrypt the Appliance Support Dump.")]
		[switch]$Encrypted,

		[parameter(Mandatory = $true,ValueFromPipeline = $true, ParameterSetName = "Object", HelpMessage = "Specify the Logical Interconnect URI the Support Dump will be generated for.", Position = 3)]
        [Alias('liobject','li','name')]
        [object]$LogicalInterconnect,
	
		[parameter(Mandatory = $False, ValueFromPipelineByPropertyName, ParameterSetName = "Object")]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

    )

    Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

        if (-not($PSBoundParameters["LogicalInterconnect"]) -and $PSCmdlet.ParameterSetName -eq "Object") 
		{ 
			
			$PipelineInput = $true 
		
		}
		
		#Validate the path exists.  If not, create it.
        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Validating $($Location) exists"

		if (-not(Test-Path $Location)) 
		{ 
			
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $($Location) Directory does not exist.  Creating directory..."
			
			New-Item -ItemType directory -path $Location 
		
		}

    }

    Process
	{

		if ($PipelineInput -and $LogicalInterconnect)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Pipeline object: $($LogicalInterconnect.name)"

			#Validate input object is a Logical Interconnect resource
			if ($LogicalInterconnect.category -ne 'logical-interconnects')
			{

				$errorRecord = New-ErrorRecord HPOneView.LogicalInterconnectResourceException InvalidLogicalInterconnectResource InvalidArgument 'LogicalInterconnect' -TargetType $LogicalInterconnect.GetType().Name -Message "The LogicalInterconnect parameter value is invalid.  Resource category provided '$($LogicalInterconnect.category)', expected 'logical-interconnects'.  Please check the value and try again."
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}
			
            $Request = @{errorCode = $LogicalInterconnect.name}

			$targetURI = $LogicalInterconnect.uri + "/support-dumps"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Recieved information from pipeline"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Request : $($request | out-string) "

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] URI: $($targetURI)"

			#Send the request
			Write-Host "Please wait while the Support Dump is generated.  This can take a few minutes..."

			Try
			{

				$resp = Send-HPOVRequest $targetUri POST $Request -Hostname $LogicalInterconnect.ApplianceConnection.Name

			}
			
			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			#Now that the Support Dump has been requested, download the file
			Try
			{

				Download-File $resp.uri $LogicalInterconnect.ApplianceConnection.Name $Location

			}
			
			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}

        else 
		{

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Support Dump Type: $($type)"

			switch ($Type)
			{
				        
				"appliance" 
				{

					ForEach ($_Connection in $ApplianceConnection)
					{

						#Build the request and specify the target URI. Do not change errorCode value.
						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Requesting Appliance Support Dump..."

						$request = @{
								
							errorCode = "CI";
							encrypt   = [bool]$Encrypted.IsPresent
							
						}

						$targetURI = $applSupportDump
							
						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Request : $($request | out-string) "

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] URI: $($targetURI)"

						#Send the request
						Write-Host "Please wait while the Support Dump is generated.  This can take a few minutes..."

						Try
						{

							$resp = Send-HPOVRequest $targetUri POST $Request -Hostname $_Connection

						}
							
						Catch
						{

							$PSCmdlet.ThrowTerminatingError($_)

						}

						#Now that the Support Dump has been requested, download the file
						Try
						{

							Download-File $resp.uri $_Connection.Name $Location

						}
							
						Catch
						{

							$PSCmdlet.ThrowTerminatingError($_)

						}

					}					

				}
							
				"li" 
				{ 

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Requesting $LogicalInterconnect Support Dump..."
							
					if ($LogicalInterconnect -is [String]) 
					{

						Try
						{

							$resp = Get-HPOVLogicalInterconnect $LogicalInterconnect -Hostname $ApplianceConnection

						}
							
						Catch
						{

							$PSCmdlet.ThrowTerminatingError($_)

						}
					
						$request = @{errorCode = $resp.name.Substring(0,10)}
					    
						$targetURI = $resp.uri + "/support-dumps"
						
						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($resp.name) Logical Interconnect"


					}

                    elseif ($LogicalInterconnect -is [PSCustomObject]) 
					{
                            
                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Logical Interconnect Object provided."

                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($LogicalInterconnect.name) Logical Interconnect"

                        $request = @{errorCode = $LogicalInterconnect.name.Substring(0,10)}

                        $targetUri = $LogicalInterconnect.uri

                    }

					#Send the request
					Write-Host "Please wait while the Support Dump is generated.  This can take a few minutes..."

					Try
					{

						$resp = Send-HPOVRequest $targetUri POST $Request -Hostname $ApplianceConnection

					}
							
					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

					#Now that the Support Dump has been requested, download the file
					Try
					{

						Download-File $resp.uri $ApplianceConnection.Name $Location

					}
							
					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

				}

			} 
					
		}

	}

	End 
	{
		
			
	}

}

Function New-HPOVBackup 
{
	
    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "default")]
    Param 
	(

        [parameter(Mandatory = $false, ValueFromPipeline = $false, ParameterSetName = "default", HelpMessage = "Specify the folder location to save the appliance backup file.",Position=0)]
        [ValidateNotNullOrEmpty()]
        [Alias("save")]
        [string]$Location = (get-location).Path,
			
		[parameter(Mandatory = $false)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

    )

	Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if  ($ApplianceConnection.Count -eq 0)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoAuthSessionFound InvalidArgument 'ApplianceConnection' -Message 'No ApplianceConnections were found.  Please use Connect-HPOVMgmt to establish an appliance connection.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		#Validate the path exists.  If not, create it.
		if (-not(Test-Path $Location))
		{
			 
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Directory does not exist.  Creating directory..."
            
			New-Item $Location -itemtype directory

        }

		$_BackupFileStatusCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_Connection.Name)' Appliance (of $($ApplianceConnection.Count))"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Please wait while the appliance backup is generated.  This can take a few minutes..."

			Try
			{
				
				$_taskStatus = Send-HPOVRequest $script:applBackup POST -Hostname $_Connection | Wait-HPOVTaskComplete -timeout (New-Timespan -minutes 45)

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Response: $($_taskStatus | out-string)"
				
			}   

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			Try
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting backup file location."

				$_backupUri     = (Send-HPOVRequest $_taskStatus.uri -Hostname $_Connection).associatedResource.resourceUri
				$_backupFileUri = (Send-HPOVRequest $_backupUri -Hostname $_Connection).downloadUri

			}
			
			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Backup File URI $($_backupFileUri)"

			#Now that the Support Dump has been requested, download the file
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Downloading $($_backupFileUri) to $($Location)"

			Try
			{

				$_resp = Download-File $_backupFileUri $_Connection $Location

				$_BackupFileStatusCollection.Add($_resp)

			}
		    
			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}
		
    }

	End
	{

		Return $_BackupFileStatusCollection

	}

}

Function New-HPOVRestore 
{
	
    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdLetBinding(DefaultParameterSetName = "default",SupportsShouldProcess = $True,ConfirmImpact = 'High')]
	Param 
	(

		[parameter(Mandatory, ValueFromPipeline = $false, ParameterSetName = "default", HelpMessage = "Specify the file to restore.", Position = 0)]
		[ValidateNotNullOrEmpty()]
		[Alias("File")]
		[string]$FileName = $null,

		[parameter(Mandatory = $false)]
		[ValidateNotNullOrEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

	)
    
    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if  ($ApplianceConnection.Count -eq 0)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoAuthSessionFound InvalidArgument 'ApplianceConnection' -Message 'No ApplianceConnections were found.  Please use Connect-HPOVMgmt to establish an appliance connection.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_ApplianceStatus = New-Object System.Collections.ArrayList

    }

    Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_Connection.Name)' Appliance (of $($ApplianceConnection.Count))"
			
			#Validate the path exists.  If not, create it.
			if (-not(Test-Path $FileName))
			{
				 
			    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Backup file specified does not exist."
			    
				$errorRecord = New-ErrorRecord HPOneview.Appliance.RestoreException BackupFileNotFound ObjectNotFound 'FileName' -Message "'$FileName' was not found. Please check the directory and/or name and try again."
			    $PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			if ($pscmdlet.ShouldProcess($_Connection.Name,'restore backup to appliance')) 
			{    
			
			    #Send the request
			    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Please wait while the appliance backup is uploaded.  This can take a few minutes..."

				Try
				{

					$resp = Upload-File $applRestoreFile $FileName -Hostname $_Connection

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}
			    
			    if ($resp.id)
				{

			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request to restore appliance"

					$_restoreObject = [PSCustomObject]@{

						type                 = "RESTORE"
						uriOfBackupToRestore = $resp.uri

					}

					Try
					{
					
						$_restoreStatus = Send-HPOVRequest $applRestore POST $_restoreObject -Hostname $_Connection
					
						Write-warning "Appliance restore in progress.  All users are now logged off."
					
					}
					
					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

					$sw = [System.Diagnostics.Stopwatch]::StartNew()

					While ($_restoreStatus.status -eq "IN_PROGRESS") 
					{

						$_statusMessage = "{0} {1}% [{2}min {3}sec]" -f $script:progressStepEnum[$_restoreStatus.progressStep],$_restoreStatus.percentComplete, $sw.Elapsed.Minutes, $sw.Elapsed.Seconds

						#Handle the call from -Verbose so Write-Progress does not get borked on display.
						if ($PSBoundParameters['Verbose'] -or $VerbosePreference -eq 'Continue') 
						{ 

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - $_statusMessage"

						}

						else 
						{ 

							Write-Progress -id 1 -activity "Restoring Appliance Backup $($_restoreStatus.id)" -status $_statusMessage -percentComplete $_restoreStatus.percentComplete
						
						}


						Try
						{
					
							$_restoreStatus = Send-HPOVRequest $_restoreStatus.uri -Hostname $_Connection
									
						}
					
						Catch
						{

							$PSCmdlet.ThrowTerminatingError($_)

						}

					} #Until ($restoreStatus.percentComplete -eq 100 -or $restoreStatus -ne "IN_PROGRESS")

					$sw.Stop()

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Operation took $($sw.elapsed.minutes)min $($sw.elapsed.seconds)sec"

					Write-Progress -id 1 -activity "Restoring Appliance Backup $($_restoreStatus.id)" -status $_statusMessage -Completed

					Write-warning "Appliance restore in has completed for $($_Connection.Name). Address Pool ranges will need to be re-enabled, and verify the managed or monitored resources do not need a refresh."

			    }

				[void]$_ApplianceStatus.Add($_restoreStatus)

			}

		}
    
    }

	End 
	{

		Return $_ApplianceStatus
	
	}

}

function Download-File 
{

<#
    .DESCRIPTION
    Helper function to download files from appliance.  
                
    .PARAMETER uri
    The location where the Support Dump or backup will be downloaded from
        
    .PARAMETER SaveLocation
    The full path to where the Support Dump or backup will be saved to.  This path will not be validated in this helper function

	.PARAMETER ApplianceConnection
    The Appliance Connection Object, Name or ConnectionID

    .INPUTS
    None.  You cannot pipe objects to this cmdlet.
                
    .OUTPUTS
    Downloads the requested file using net.WebRequest
	
	.LINK
	https://hponeview.codeplex.com/wikipage?title=Download-File

    .EXAMPLE
    PS C:\> Download-File /rest/appliance/support-dumps/ci5401AB76-CI-2013_09_04-04_52_00.014786.sdmp -ApplianceConnection MyAppliance.domain.com c:\temp
			
#>

    [CmdLetBinding()]
    Param 
	(

		[parameter(Mandatory, HelpMessage = "Specify the URI of the object to download.", Position = 0)]
		[ValidateNotNullOrEmpty()]
		[string]$uri,
		
		[parameter(Mandatory, HelpMessage = "Specify the Appliance Connection Name or OBject.", Position = 1)]
		[ValidateNotNullorEmpty()]
		[object]$ApplianceConnection = $null,

		[parameter(Mandatory, HelpMessage = "Specify the location where to save the file to.", Position = 2)]
		[Alias("save")]
		[ValidateNotNullOrEmpty()]
		[string]$SaveLocation

    )

	Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if (-not($ApplianceConnection -is [HPOneView.Appliance.Connection]) -and (-not($ApplianceConnection -is [System.String])))
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException InvalidApplianceConnectionDataType InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter is not type [HPOneView.Appliance.Connection] or [System.String].  Please correct this value and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif  ($ApplianceConnection.Count -gt 1)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException MultipleApplianceConnections InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter contains multiple Appliance Connections.  This CMDLET only supports 1 Appliance Connection in the ApplianceConnect parameter value.  Please correct this and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		else
		{

			Try 
			{
	
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError 'ApplianceConnection' -TargetType $ApplianceConnection.GetType().Name -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}

    }

    Process 
	{

		$_downloadfilestatus = NewObject -DownloadFileStatus
    
        $fsCreate = [System.IO.FileAccess]::Create
        $fsWrite = [System.IO.FileAccess]::Write

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Download URI: $uri"
  
        [System.Net.httpWebRequest]$_fileDownload = RestClient GET $uri $ApplianceConnection.Name

	    $_fileDownload.accept               = "application/zip,application/octet-stream,*/*"
		$_fileDownload.Headers.Item("auth") = $ApplianceConnection.SessionID

        $i = 0

        ForEach ($_h in $_fileDownload.Headers) 
		{
			
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Request Header $($i): $($_h) = $($_fileDownload.Headers[$i])"
			
			$i++
		
		}
		    
        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Request: GET $($_fileDownload | out-string)"
        
        #Get response
        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting response"
        [Net.httpWebResponse]$_rs = $_fileDownload.GetResponse()

        #Display the response status if verbose output is requested
        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Response Status: $([int]$_rs.StatusCode) $($_rs.StatusDescription)"

        $i = 0

        ForEach ($_h in $_rs.Headers) 
		{ 
			
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Response Header $($i): $($_h) = $($_rs.Headers[$i])"
			
			$i++ 
		
		}

        #Request is a redirect to download file contained in the response headers
        if (($_rs.headers["Content-Disposition"]) -and ($_rs.headers["Content-Disposition"].StartsWith("attachment; filename="))) 
		{
        
            $_fileName = ($_rs.headers["Content-Disposition"].Substring(21)) -replace "`"",""
        
        }
                		
        #Detect if the download is a Support Dump or Appliance Backup
        elseif ($uri.Contains("/rest/backups/archive"))
		{

            #Need to get the Appliance file name
	        $_fileName = $uri.split("/")
            
			$_fileName = $_fileName[-1] + ".bkp"
        
		}

        else 
		{
		    #Need to get the Support Dump file name
	        $_fileName = $uri.split("/")

            $_fileName = $ApplianceConnection.Name + "_" + $_fileName[-1]

        }

		if ($_rs.headers['Content-Length']) 
		{ 
			
			$_fileSize = $_rs.headers['Content-Length'] 
		
		}

		elseif ($_rs.ContentLength -and $_rs.ContentLength -gt 0) 
		{ 
			
			$_fileSize = $_rs.ContentLength 
		
		}

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Filename: $($_fileName)"
	    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Filesize: $($_fileSize)"
		
		Try
		{

			#Read from response and write to file
			$_stream = $_rs.GetResponseStream() 
			    
			#Define buffer and buffer size
			[int] $_bufferSize = (4096*1024)
			[byte[]]$_buffer   = New-Object byte[] ($_bufferSize)
			[int] $_bytesRead  = 0

			#This is used to keep track of the file upload progress.
			$_numBytesRead     = 0
			$_numBytesWrote    = 0
	 
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Saving to $($saveLocation)\$($_fileName)"

			$_fs = New-Object IO.FileStream ($saveLocation + "\" + $_fileName),'Create','Write','Read'

			do
			{

				$_bytesRead = $_stream.Read($_buffer, 0, $_bufferSize)

			    #Write from buffer to file
				$_byteCount = $_fs.Write($_buffer, 0, $_bytesRead);
				
				#Keep track of bytes written for progress meter
				$_numBytesWrote += $_bytesRead

			    #Use the Write-Progress cmd-let to show the progress of uploading the file.
			    [int]$_percent = (($_numBytesWrote / $_fileSize)  * 100)

			    if ($_percent -gt 100) 
				{ 
					
					$_percent = 100 
				
				}

			    $_status = "(" + $_numBytesWrote + " of " + $_fileSize + ") Completed " + $_percent + "%"

			    #Handle the call from -Verbose so Write-Progress does not get borked on display.
			    if ($PSBoundParameters['Verbose'] -or $VerbosePreference -eq 'Continue') 
				{ 
			    
			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Skipping Write-Progress display."
			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Downloading file $_fileName, status: $_status, percentComplete: $_percent"
			        
			    }
			      
			    else 
				{ 
					
					Write-Progress -activity "Downloading file $_fileName" -status $_status -percentComplete $_percent 
				
				}

			} while ($_bytesRead -ne 0)

			Write-Progress -activity "Downloading file $_fileName" -Completed

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] File saved to $($saveLocation)"

			#Clean up our work
			$_stream.Close()
			$_rs.Close()
			$_fs.Close()

			$_downloadfilestatus.status              = 'Completed'
			$_downloadfilestatus.file                = "$saveLocation\$_fileName"
			$_downloadfilestatus.ApplianceConnection = $ApplianceConnection.Name

			Return $_downloadfilestatus

		}

		Catch
		{

			#Clean up
			if ($_rs)
			{

				$_rs.Close()

			}

			#Clean up
			if ($_fs)
			{

				$_fs.Close()

			}

			$PSCmdlet.ThrowTerminatingError($_)

		}
	    
    }

 }

function Upload-File 
{

<#

	.SYNOPSIS
	Upload a file to the appliance.

	.DESCRIPTION
	This cmdlet will upload a file to the appliance that can accepts file uploads (SPP firmware bundle, Appliance Restore, and Appliance Updates.)

	.PARAMETER URI
	Location where to upload file to.

	.PARAMETER File
	Full path to the file to be uploaded.
	 
	.PARAMETER ApplianceConnection
	Appliance Connection

	.INPUTS
	None.  You cannot pipe objects to this cmdlet.

	.OUTPUTS
	Write-Progress
	The progress of uploading the file to the appliance.

	.LINK
	Add-HPOVSppFile

	.LINK
	New-HPOVRestore
	
	.LINK
	https://hponeview.codeplex.com/wikipage?title=Upload-File

	.EXAMPLE
	PS C:\> Upload-File "/rest/firmware-bundles" "C:\Users\me\Documents\SPP2012060B.2012_0525.1.iso"
	Upload a new SPP into the appliance.

	.EXAMPLE
	PS C:\> Upload-File "/rest/restores" "C:\Users\me\Documents\appliance.bak"
	Upload a backup file to restore in the appliance.

#>

	[CmdletBinding()]

	Param 
	(

        [parameter(Mandatory = $true, HelpMessage = "Specify the upload URI.", Position = 0)]
        [ValidateNotNullOrEmpty()]
        [Alias('u')]
        [string]$uri,

		[parameter(Mandatory = $true, HelpMessage = "Enter the path and file name to upload.", Position = 1)]
        [Alias('f')]
        [ValidateScript({Test-Path $_})]
		[string]$File,
		
		[parameter(Mandatory, HelpMessage = "Specify the Appliance Connection Name or OBject.", Position = 2)]
		[Alias('Hostname')]
		[ValidateNotNullorEmpty()]
		[object]$ApplianceConnection = $null

    )

	Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if (-not($ApplianceConnection -is [HPOneView.Appliance.Connection]) -and (-not($ApplianceConnection -is [System.String])))
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException InvalidApplianceConnectionDataType InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter is not type [HPOneView.Appliance.Connection] or [System.String].  Please correct this value and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif  ($ApplianceConnection.Count -gt 1)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException MultipleApplianceConnections InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter contains multiple Appliance Connections.  This CMDLET only supports 1 Appliance Connection in the ApplianceConnect parameter value.  Please correct this and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		else
		{

			Try 
			{
	
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError 'ApplianceConnection' -TargetType $ApplianceConnection.GetType().Name -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}


    }
    
    Process 
	{

		$_fileObj = Get-Item -path $File
		
		$fs = New-Object IO.FileStream ($File, $FSOpenMode, $FSRead)

        [string]$filename = $_fileObj.name

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Uploading $($filename) file to appliance, this may take a few minutes..."

        try 
		{

            [System.Net.httpWebRequest]$uploadRequest = RestClient POST $uri -Appliance $ApplianceConnection.Name
           
            $boundary                                     = "--" + (-join(48..57+65..90+97..122 | ForEach-Object {[char]$_} | Get-Random -Count 20))
            $uploadRequest.Timeout                        = 1200000
            $uploadRequest.ContentType                    = "multipart/form-data; boundary=$boundary"
            $uploadRequest.Headers.Item("auth")           = $ApplianceConnection.SessionID
            $uploadRequest.Headers.Item("uploadfilename") = $filename
            $uploadRequest.AllowWriteStreamBuffering      = $false
            $uploadRequest.SendChunked                    = $true
            $uploadRequest.ContentLength                  = $fs.length

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Request: POST $($uri )"

            $i = 0

            foreach ($h in $uploadRequest.Headers) 
			{
				
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Request Header {$i} $($h) : $($uploadRequest.Headers[$i])"
				
				$i++
			
			}

            $rs = $uploadRequest.getRequestStream()

            $disposition = 'Content-Disposition: form-data; name="file"; filename="' + $_fileObj.Name + '"'

            $conType = "Content-Type: application/octet-stream"

            [byte[]]$readbuffer = New-Object byte[] 4194304 #1048576

            [byte[]]$BoundaryBytes = [System.Text.Encoding]::UTF8.GetBytes("--" + $boundary + "`r`n");
            $rs.write($BoundaryBytes,0,$BoundaryBytes.Length);

            [byte[]]$contentDisp = [System.Text.Encoding]::UTF8.GetBytes($disposition + "`r`n");
            $rs.write($contentDisp,0,$contentDisp.Length);

            [byte[]]$contentType = [System.Text.Encoding]::UTF8.GetBytes($conType + "`r`n`r`n");
            $rs.write($contentType,0,$contentType.Length);

            #This is used to keep track of the file upload progress.
            $numBytesToRead = $fs.Length    
            [int64]$numBytesRead = 0

            if ($PSBoundParameters['Verbose'] -or $VerbosePreference -eq 'Continue') 
			{ 
			
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Skipping Write-Progress display." 
			
			}

            do 
			{

		        $byteCount = $fs.Read($readbuffer,0,4194304)

		        $rs.write($readbuffer,0,$byteCount)
	        
		        #Keep track of where we are at clearduring the read operation
		        $numBytesRead += $bytecount

		        #Use the Write-Progress cmd-let to show the progress of uploading the file.
                [int]$percent = [math]::floor(($numBytesRead / $fs.Length) * 100)
                
                $status = "(" + $numBytesRead + " of " + $numBytesToRead + " transferred) Completed " + $percent + "%"

                #Handle the call from -Verbose so Write-Progress does not get borked on display.
                if ($PSBoundParameters['Verbose'] -or $VerbosePreference -eq 'Continue') 
				{ 

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Uploading file $fileName, status: $status, percentComplete: $percent"
                    
                }
                  
                else 
				{ 

					Write-Progress -activity "Upload File" -status "Uploading $Filename" -CurrentOperation $status -percentComplete $percent 

				}

            } while ($bytecount -gt 0)

            $fs.close()

            [byte[]]$endBoundaryBytes = [System.Text.Encoding]::UTF8.GetBytes("`n`r`n--" + $boundary + "--`r`n");

            $rs.write($endBoundaryBytes,0,$endBoundaryBytes.Length);

            $rs.close()

        }

        catch [System.Exception] 
		{

            #dispose if still exist
			if ($rs) { $rs.close() }
            if ($fs) { $fs.close() }

            $PSCmdlet.ThrowTerminatingError($_)

        }

        try 
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Upload Request completed."
		
			if ($PSBoundParameters['Verbose'] -or $VerbosePreference -eq 'Continue') {

				 Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Waiting for completion response from appliance."

			}

			else 
			{ 

				Write-Progress -activity "Upload File" -status "Uploading $Filename" -CurrentOperation "Waiting for completion response from appliance." -percentComplete $percent 
			
			}

            [net.httpWebResponse]$WebResponse = $uploadRequest.getResponse()
			
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Response Status: ($([int]$WebResponse.StatusCode)) $($WebResponse.StatusDescription)"
			
            $uploadResponseStream = $WebResponse.GetResponseStream()

            #Read the response & convert to JSON
            $reader       = New-Object System.IO.StreamReader($uploadResponseStream)
			$responseJson = $reader.ReadToEnd()

            $uploadResponse = $responseJson | convertFrom-Json

            $uploadResponseStream.Close()
            #$responseJson.Close()
            

            #need to parse the output to know when the upload is truly complete
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Response: $($uploadResponse | out-string)"

            Write-Progress -activity "Upload File" -Completed

            $uploadRequest = $Null
            
			#dispose if still exist
			if ($rs) { $rs.close() }
            if ($fs) { $fs.close() }
			Write-Progress -activity "Upload File" -CurrentOperation "Uploading $Filename " -Completed

        }

        catch [Net.WebException] 
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] WebException caught. Getting exception response from API."
 
			Try
			{

				$sr = New-Object IO.StreamReader ($_.Exception.Response.GetResponseStream())

			}
            
			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}
            
            $errorObject = $sr.readtoend() | ConvertFrom-Json
			
			"[$($MyInvocation.InvocationName.ToString().ToUpper())] Error Response from API: {0}" -f ($errorObject | Out-String) | Write-Verbose

			#dispose if still exist
            if ($rs) { $rs.close() }
            if ($fs) { $fs.close() }

			#$errorResponse.close()
			$sr.close()

			$errorRecord = New-ErrorRecord HPOneview.Appliance.UploadFileException $errorObject.ErrorCode InvalidResult 'Upload-File' -Message $errorObject.Message -InnerException $_.Exception

			$PSCmdlet.ThrowTerminatingError($errorRecord)
            #Write-Error "$([int]$errorObject.ErrorCode)) $($errorObject.message)" -ErrorAction Stop
            
        }

    }

    end 
	{

        #Handle file uploads that generate task resource (i.e. Upload SPP Baseline)
        if ($uploadResponse.category -eq "tasks") 
		{
			
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Response is a task resource"			

			$uploadResponse | % { $_.PSObject.TypeNames.Insert(0,”HPOneView.Appliance.TaskResource") }

        }

		Add-Member -InputObject $uploadResponse -NotePropertyName ApplianceConnection -NotePropertyValue ([PSCustomObject]@{ Name = $ApplianceConnection.Name; ConnectionId = $ApplianceConnection.ConnectionId }) -Force 

		Return $uploadResponse

    }

}

function Get-HPOVScmbCertificates 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding()]
	Param
	(

        [parameter(Mandatory = $false, ValueFromPipeline = $false, ParameterSetName = "default", HelpMessage = "Specify the folder location to save the SSL certificates.", Position = 0)]
	    [parameter(Mandatory = $false, ValueFromPipeline = $false, ParameterSetName = "convert", HelpMessage = "Specify the folder location to save the SSL certificates.", Position = 0)]
        [ValidateNotNullOrEmpty()]
        [Alias("save")]
        [string]$Location = ($pwd).path,

        [parameter(Mandatory = $false , ParameterSetName = "convert", HelpMessage = "Convert rabbitmq_readonly client certificate to PFX format.")]
        [ValidateNotNullOrEmpty()]
        [Alias("pfx")]
        [switch]$ConvertToPFx,
	    
		[parameter(Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = "convert", HelpMessage = "Password for PFX file")]
        [ValidateNotNullOrEmpty()]
		[SecureString]$Password,

		[parameter(Mandatory = $false, HelpMessage = "Enter the Appliance Name or Object")]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

    )
	
    Begin 
	{

		if ($PSBoundParameters['$ConvertToPFx'])
		{

			Write-Warning '-$ConvertToPFx is currently not enabled in this release until a proper solution can be found to convert the SCMB Public Cert and Private key to PKCS#12 (aka PFX) format.'

		}
        
        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{

				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}
		
		$TaskCollection = New-Object System.Collections.ArrayList
        
        #Validate the path exists.  If not, create it.
		if (-not(Test-Path $Location))
		{ 

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Directory does not exist.  Creating directory..."

            New-Item -path $Location -ItemType Directory

        }

    }

    Process
	{
		
		ForEach ($_connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_connection.Name)' appliance connection (of $($ApplianceConnection.count))"

			if ($Password)
			{

				$_dp = [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($password))

			}

			#Appliance CA
			$caFile = $Location + "\" + "$($_connection.Name)_ca.cer"
        
			#Appliance Public Key
			$publicKeyFile = $Location + "\" + "$($_connection.Name)_cert.cer"
        
			#Rabbit Client Private Key
			$privateKeyFile = $Location + "\" + "$($_connection.Name)_privateKey.key"

			#Check to see if the Rabbit client cert was already created
			Try
			{

				$_keys = Send-HPOVRequest $applKeypairURI -Hostname $_connection.Name

			}

			Catch [HPOneView.ResourceNotFoundException]
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] RabbitMQ SSL cert key pair does not exist."

				Try
				{

					$_rabbitbody = NewObject -RabbitmqCertReq

					#Generate the client private key request
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Body: $($_rabbitbody | out-string)"

					$_task = Send-HPOVRequest $applRabbitmqUri POST $_rabbitbody -Hostname $_connection.Name | Wait-HPOVTaskComplete

					#Retrieve generated keys
					$_keys = Send-HPOVRequest $applKeypairURI -Hostname $_connection.Name

				}

				Catch
				{
			
					$PSCmdlet.ThrowTerminatingError($_)
			
				}

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}
        
			try 
			{

				New-Item $privateKeyFile -type file -force -value $_keys.base64SSLKeyData | Out-Null

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Created rabbitmq_readonly user $($privateKeyFile)"

				#If ($ConvertToPFx)
				#{
				#
				#	$_privatecert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2($privateKeyFile)
				#
				#	$bytes = $_privatecert.Export("Pfx",$decryptPassword)
				#
				#	$privateKeyFile = $privateKeyFile.Replace(".cer",".pfx")
				#
				#	[System.IO.File]::WriteAllBytes($privateKeyFile, $bytes)
				#
				#	Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Created PFX certificate $($privateKeyFile)"
				#
				#}

			}

			catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)
		
			}

			try 
			{

				New-Item $publicKeyFile -type file -force -value $_keys.base64SSLCertData | Write-Verbose

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Created rabbitmq_readonly user $($publicKeyFile)"

				#If ($ConvertToPFx)
				#{
				#
				#	$c = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2($publicKeyFile)
				#
				#	$bytes = $c.Export("Pfx",$decryptPassword)
				#
				#	$publicKeyFile = $publicKeyFile.Replace(".pem",".pfx")
				#
				#	[System.IO.File]::WriteAllBytes($publicKeyFile, $bytes)
				#
				#	Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Created PFX certificate $($publicKeyFile)"
				#
				#}

			}

			catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			try 
			{

				$_ca = Send-HPOVRequest $applCaURI -Hostname $_connection.Name

				New-Item $caFile -type file -force -value $_ca | Write-Verbose

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Created $($caFile)"
        
			}

			catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}

    }

}

function Show-HPOVSSLCertificate {

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding()]
    param
	( 
    
        [parameter(Mandatory = $True)]
        [Object]$Appliance = $Null
    
    )

    Begin { 
    
        if (-not($Appliance)) {

            $errorRecord = New-ErrorRecord ArgumentNullException InvalidArgumentValue InvalidArgument 'Show-HPOVSslCertificate' -Message "You are not connected to an appliance.  Please specify the -appliance parameter and provide the appliance FQDN, Hostname or IP Address."
            $pscmdlet.ThrowTerminatingError($errorRecord)

        }
    
    }

    Process {

        $Chain      = $Null
        $Status     = $Null
        $Cert       = $Null
        $certObject = $Null

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Checking '$Appliance' appliance SSL Certificate"

        $ConnectString = "https://$Appliance"

        $WebRequest = [System.Net.HttpWebRequest]::Create($ConnectString)

        #Attempt connection to appliance.
        try { $Response = $WebRequest.GetResponse() }
		catch [System.Net.WebException] { 

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] [System.Net.WebException] code block."
            
            if ($_.Exception.Status -match "TrustFailure") { Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Certificate failed trust validation." }
            
			elseif ($_.Exception -match "The remote name could not be resolved") {
                
                $errorRecord = New-ErrorRecord System.Net.WebException ApplianceNotResponding ObjectNotFound 'Show-HPOVSslCertificate' -Message "Unable to resolve hostname '$Appliance'.  Please check the name and try again."
                $PSCmdlet.ThrowTerminatingError($errorRecord)

            }

			elseif ($_.Exception.Message -contains "Unable to connect to the remote server") {

                $errorRecord = New-ErrorRecord System.Net.WebException ApplianceNotResponding ConnectionError 'Show-HPOVSslCertificate' -Message "Unable to connect to '$Appliance' due to timeout or remote system didn't respond to the connection request."
                $PSCmdlet.ThrowTerminatingError($errorRecord)

            }

            else {

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Other error caught."

				$errorRecord = New-ErrorRecord System.Net.WebException WebExceptionInvalidResult InvalidResult 'Show-HPOVSslCertificate' -Message $_.Exception.Message
                $PSCmdlet.ThrowTerminatingError($errorRecord)

            }
        
        }

		catch {

			write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Non-Specific CATCH block."

			$errorRecord = New-ErrorRecord System.Net.WebException WebExceptionInvalidResult InvalidResult 'Show-HPOVSslCertificate' -Message $_.Exception.Message
            $PSCmdlet.ThrowTerminatingError($errorRecord)
        }
        
        #Close the response connection, as it is no longer needed, and will cause problems if left open.
        if ($response) { Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Closing response connection"; $Response.Close() }

        if ($WebRequest.ServicePoint.Certificate -ne $null) {

            $Cert = [Security.Cryptography.X509Certificates.X509Certificate2]$WebRequest.ServicePoint.Certificate.Handle

            try { $SAN = ($Cert.Extensions | Where-Object {$_.Oid.Value -eq "2.5.29.17"}).Format(0) -split ", " }
            catch { $SAN = $null }

            $chain = New-Object Security.Cryptography.X509Certificates.X509Chain 

            [void]$chain.ChainPolicy.ApplicationPolicy.Add("1.3.6.1.5.5.7.3.1")
            $Status = $chain.Build($Cert)

            $certObject = [HPOneView.PKI.SslCertificate] @{

                OriginalUri             = $ConnectString;
                #ReturnedUri             = $Response.ResponseUri;
                Certificate             = $WebRequest.ServicePoint.Certificate;
                Issuer                  = $WebRequest.ServicePoint.Certificate.Issuer;
                Subject                 = $WebRequest.ServicePoint.Certificate.Subject;
                SubjectAlternativeNames = $SAN;
                CertificateIsValid      = $Status;
                ErrorInformation        = if ($chain.ChainStatus) { $chain.ChainStatus | ForEach-Object { $_.Status.ToString() } } else { $Null }

            }

            #If the certificate is NOT valid, display it and warn user
            if ((-not($certObject.CertificateIsValid)) -and ($certObject.ErrorInformation -contains "UntrustedRoot")) { 
        
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Cert Root is NOT trusted"

                #Display the certificate output in Yellow
                $originalFGColor = [System.Console]::ForegroundColor
                [System.Console]::ForegroundColor = [System.ConsoleColor]::Yellow
            
                #Display certificate details
                $certObject | Out-Host

                #Restore the console ForegroundColor
                [System.Console]::ForegroundColor = [System.ConsoleColor]::$originalFGColor

                Write-Warning "The appliance SSL Certificate is UNTRUSTED.  Us0e the Import-HPOVSSLCertificate to import the appliance Self-Signed certificate to your user accounts local Trusted Root Certification Authorities store to not display this warning when you first connect to your appliance."
				Write-Host ""

                #Value will be False, in String format, not Bool
                $ignore = $True
            
            }

			#If Cert IS valid, but cannot validate with Root CA, can validate with Subordinate CA and unable to validate revocation, display warning
			elseif ((-not ($certObject.CertificateIsValid)) -and ($certObject.ErrorInformation -contains "PartialChain" -and $certObject.ErrorInformation -contains "RevocationStatusUnknown" -and $certObject.ErrorInformation -contains "OfflineRevocation")) { 

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Cert is NOT trusted and unable to validate CRL."

                #Display the certificate output in Yellow
                $originalFGColor = [System.Console]::ForegroundColor

                [System.Console]::ForegroundColor = [System.ConsoleColor]::Yellow

                #Display certificate details
                $certObject | Out-Host

                #Restore the console ForegroundColor
                [System.Console]::ForegroundColor = [System.ConsoleColor]::$originalFGColor

                Write-Warning "The appliance SSL Certificate is UNTRUSTED.  This system does not trust the CA issuer, and is unable to verify the Certificate Authorities Revocation List (CRL) or the Revocation List Destination (CLD) is not contained within the certificate."
				Write-Host ""
                
				#Value will be False, in String format, not Bool
                $ignore = $True

            }

			#If Cert IS valid, but cannot validate with Root CA and unable to validate revocation, display warning
			elseif ((-not ($certObject.CertificateIsValid)) -and ($certObject.ErrorInformation -contains "RevocationStatusUnknown" -and $certObject.ErrorInformation -contains "OfflineRevocation")) { 
                
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Cert is NOT trusted and unable to  validate CRL."
                
				#Display the certificate output in Yellow
                $originalFGColor = [System.Console]::ForegroundColor
                [System.Console]::ForegroundColor = [System.ConsoleColor]::Yellow
                
				#Display certificate details
                $certObject | Out-Host
                
				#Restore the console ForegroundColor
                [System.Console]::ForegroundColor = [System.ConsoleColor]::$originalFGColor
                
				Write-Warning "The appliance SSL Certificate is UNTRUSTED.  This system is unable to verify the Certificate Authorities Revocation List (CRL) or the Revocation List Destination (CLD) is not contained within the certificate.  If you are using an Enterprise Certificate Authority (i.e. Windows Server CA), please make sure the CRL is published as part of the issued certificate (CRL is an Extension that needs to be enabled prior to issuing certificates)."
				Write-Host ""
                
				#Value will be False, in String format, not Bool
                
				$ignore = $True
            
			}
			
			#Cert is valid
            elseif ($certObject.CertificateIsValid) {
                
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Cert is trusted"

                if ($VerbosePreference -eq "Continue") {

                    #Display the certificate output in Green
                    $originalFGColor = [System.Console]::ForegroundColor
                    [System.Console]::ForegroundColor = [System.ConsoleColor]::Green
            
                    #Display certificate details
                    $certObject | Out-Host

                    #Restore the console ForegroundColor
                    [System.Console]::ForegroundColor = [System.ConsoleColor]::$originalFGColor

                }

                $ignore = $True
            }

			#Remaining Invalid cases like appliance hostname/IP does not match Common Name (CN) or Subject Alternative Name (SAN)
            else {

				$certObject | Out-Host
	            $ignore = $False
                #Write-Error $Error[-1] -ErrorAction Stop
            }
            
            $chain.Reset()

        } 
        
        else {
        
            Write-Error $Error[-1] -ErrorAction Stop
        
        }
    
        $certObject = $Null
        $WebRequest = $Null
    }

    End {

        $ignore

    }

}

function Import-HPOVSslCertificate 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding()]

    Param 
	(
	
		[parameter(ValueFromPipeline, Mandatory = $false, HelpMessage = "Enter the Appliance Name or Object")]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}
	
	)

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSBoundParameters['ApplianceConnection'])) { $PipelineInput = $True }

    }

    Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Appliance '$($_Connection.Name)' (of $($ApplianceConnection.Count))"

			$_ConnectString = "https://$_Connection"
        
			$WebRequest = [Net.WebRequest]::Create($_ConnectString)

			try 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting response"
				
				$Response = $WebRequest.GetResponse()
			
			}
			
			catch [Net.WebException] 
			{ 

				if (-not($WebRequest.Connection) -and ([int]$Response.StatusCode -eq 0)) 
				{

					Write-Error $_.Exception.Message -Category ObjectNotFound -ErrorAction Stop

				} 

			}

			#Close the response connection, as it is no longer needed, and will cause problems if left open.
			if ($response) 
			{
				
				write-verbose "Closing response connection"
				
				$Response.Close() 
			
			}

			if ($WebRequest.ServicePoint.Certificate -ne $null) 
			{

				#Get certificate
				$Cert = [Security.Cryptography.X509Certificates.X509Certificate2]$WebRequest.ServicePoint.Certificate



				$StoreScope = "CurrentUser"
				$StoreName  = "Root" 

				#Save to users Trusted Root Authentication Hosts store
				$store = New-Object System.Security.Cryptography.X509Certificates.X509Store $StoreName, $StoreScope

				$store.Open([System.Security.Cryptography.X509Certificates.OpenFlags]::ReadWrite)

				try 
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Attempting to add cert to store"

					$store.Add($cert)
					$store.Close()

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Cert added successfully"

				}

				catch 
				{

					$store.Close()
					Write-Error $_.Exception.Message -Category InvalidResult -ErrorAction Stop

				}

			}

		}

    }
	
	End	
	{ 
		
		Write-Warning "Please note that the Subject Alternate Name (SAN) must match that of the Appliance hostname you use to connect to your appliance.  If it does not, an SSL connection failure will occur.  When creating a CSR on the appliance, make sure to include the additional FQDN and IP address(es) in the Alternative Name field." 
	
	}

}

function Restart-HPOVAppliance 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(SupportsShouldProcess = $True, ConfirmImpact = 'High')]
    Param 
	(
	
		[parameter(ValueFromPipeline, Mandatory = $false, HelpMessage = "Enter the Appliance Name or Object")]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}
	
	)

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSBoundParameters['ApplianceConnection'])) { $PipelineInput = $True }

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{

				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}
		
		$TaskCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{

		if  ($ApplianceConnection.Count -eq 0)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoAuthSessionFound InvalidArgument 'ApplianceConnection' -Message 'No ApplianceConnections were found.  Please use Connect-HPOVMgmt to establish an appliance connection.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Appliance '$($_Connection.Name)' (of $($ApplianceConnection.Count))"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Appliance Restart being request."

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Presenting confirmation prompt."

			Write-Warning "Restart of the appliance will cause all users to be disconnected and all ongoing tasks to be interrupted."

			if ($pscmdlet.ShouldProcess($script:HPOneViewAppliance,"restart appliance"))
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User confirmed appliance shutdown."    
				
				Try
				{

            
					$_resp = Send-HPOVRequest -uri $script:applianceRebootUri -method POST

				}
				
				Catch
				{

					$PScmdlet.ThrowTerminatingError($_)

				}

			}
            
			elseif ($PSBoundParameters['Whatif'])
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User passed -WhatIf."

			}

			else
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User cancelled shutdown request."

			}
		
		}
        
    }

	End
	{

		Return $TaskCollection

	}

}

function Stop-HPOVAppliance 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(SupportsShouldProcess = $True, ConfirmImpact = 'High')]
    Param 
	(
	
		[parameter(ValueFromPipeline, Mandatory = $false, HelpMessage = "Enter the Appliance Name or Object")]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}
	
	)

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not $PSBoundParameters['ApplianceConnection']) { $PipelineInput = $True }

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{

				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}
		
		$TaskCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{

		if  ($ApplianceConnection.Count -eq 0)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoAuthSessionFound InvalidArgument 'ApplianceConnection' -Message 'No ApplianceConnections were found.  Please use Connect-HPOVMgmt to establish an appliance connection.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Appliance '$($_Connection.Name)' (of $($ApplianceConnection.Count))"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Appliance SHUTDOWN being requested..."

			write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Presenting confirmation prompt."

			Write-Warning "Shutdown of the appliance will cause all users to be disconnected and all ongoing tasks to be interrupted."

			if ($pscmdlet.ShouldProcess($_Connection.Name,"shutdown appliance"))		
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User confirmed appliance shutdown."    
				
				Try
				{

					$_resp = Send-HPOVRequest -uri $applianceShutDownUri POST -Hostname $_Connection

				}
				
				Catch
				{

					$PScmdlet.ThrowTerminatingError($_)

				}

				[void]$TaskCollection.Add($_resp)

			}

			elseif ($PSBoundParameters['Whatif'])
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User passed -WhatIf."

			}

			else
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User cancelled shutdown request."

			}
		
		}
        
    }

	End
	{

		Return $TaskCollection

	}

}

#######################################################
# Server Hardware and Enclosures: 
#

function Get-HPOVServer 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding(DefaultParameterSetName = "Default")]
	Param 
	(
		
        [parameter(Position = 0, Mandatory = $false, ParameterSetName = "Default")]
		[string]$Name = $null,

        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [switch]$NoProfile,

        [parameter(Mandatory = $false)]
		[ValidateNotNullOrEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

	)

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if  ($ApplianceConnection.Count -eq 0)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoAuthSessionFound InvalidArgument 'ApplianceConnection' -Message 'No ApplianceConnections were found.  Please use Connect-HPOVMgmt to establish an appliance connection.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}
		
		$c = 0

        ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

        $serverCollection = New-Object System.Collections.ArrayList

    }

	Process 
	{

        ForEach ($_Connection in $ApplianceConnection) 
		{

            $uri = $ServerHardwareUri + "?sort=name:asc"

            if ($NoProfile) 
			{ 
                
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Filtering for server hardware with no assigned profiles."

                $uri += "&filter=serverProfileUri=null"
            
            }

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request"


			Try
			{

				$svrs = Send-HPOVRequest $uri -appliance $_Connection

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}
	        
            
            ForEach ($s in ($svrs.members | Sort-Object name)) 
			{

				$s.PSObject.TypeNames.Insert(0,'HPOneView.ServerHardare')

                [void]$serverCollection.Add($s)

            }

        }

	}

	End 
	{

        if ($Name) 
		{

            $serverCollection = $serverCollection | ? name -like $Name

        }

        if ($serverCollection.count -eq 0 -and $Name) 
		{
				
            $errorRecord = New-ErrorRecord HPOneView.ServerHardwareResourceException ServerHardwareResourceNotFound ObjectNotFound 'Name' -Message "Server '$Name' not found. Please check the name again, and try again."
            $pscmdlet.ThrowTerminatingError($errorRecord)

		}

		"Done. {0} server resource(s) found." -f $serverCollection.count | write-verbose

        Return $serverCollection

    }

}

function Get-HPOVIloSso
{

	# .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding(DefaultParameterSetName = "Default")]
    Param 
	(

        [parameter(ValueFromPipeline, Mandatory, HelpMessage = "Provide a Server resource object.", Position = 0, ParameterSetName = 'Default')]
        [ValidateNotNullOrEmpty()]
        [Object]$Server = $Null,

		[parameter(ValueFromPipeline, Mandatory = $false, ParameterSetName = 'Default')]
		[Switch]$RemoteConsoleOnly

    )

	Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSBoundParameters['Server']))
		{

			$PipelineInput = $true

		}

		else
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

			if (-not($Server -is [PSCustomObject]) -or (-not($Server.ApplianceConnection)))
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException InvalidApplianceConnectionDataType InvalidArgument 'Server' -TargetType 'PSObject' -Message "The specified 'Server' is not an object or is missing the 'ApplianceConnection' property.  Please correct this value and try again."
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			else
			{

				Try 
				{
	
					$ApplianceConnection = Test-HPOVAuth $Server.ApplianceConnection

				}

				Catch [HPOneview.Appliance.AuthSessionException] 
				{

					$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError 'ApplianceConnection' -TargetType $Server.ApplianceConnection.GetType().Name -Message $_.Exception.Message -InnerException $_.Exception
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				Catch 
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

			}

		}

		$colStatus = New-Object System.Collections.ArrayList

    }

    Process 
	{

		if (-not($PipelineInput) -and (-not($Server -is [PSCustomObject])))
		{

			$errorRecord = New-ErrorRecord HPOneview.ServerResourceException InvalidServerObject InvalidArgument 'Server' -TargetType $Server.GetType().Name -Message "The specified 'Server' is not an object.  Please correct this value and try again."
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		if ($PSBoundParameters['RemoteConsoleOnly'])
		{

			$_uri = $Server.uri + '/remoteConsoleUrl'

		}

		else
		{

			$_uri = $Server.uri + '/iloSsoUrl'

		}
		

        Write-Verbose ("[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing {0}" -f $Server.name)

		Try
		{
		
			$_ssoresp = Send-HPOVRequest $_uri -Hostname $Server.ApplianceConnection.Name
		
		}
        
		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding resp to collection."

		[void]$colStatus.Add($_ssoresp)
       
    }

    end 
	{
        
        Return $colStatus

    }

}

function Add-HPOVServer 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding(DefaultParameterSetName = "Managed",SupportsShouldProcess = $True,ConfirmImpact = 'High')]
    Param 
	(

        [parameter(ValueFromPipeline = $True, Mandatory = $true, HelpMessage = "Enter the host name (FQDN) or IP of the server's iLO.", Position = 0, ParameterSetName = "Monitored")]
        [parameter(ValueFromPipeline = $True, Mandatory = $true, HelpMessage = "Enter the host name (FQDN) or IP of the server's iLO.", Position = 0, ParameterSetName = "Managed")]
        [ValidateNotNullOrEmpty()]
        [string]$Hostname = $Null,
         
        [parameter(Mandatory = $true, HelpMessage = "Enter the iLO administrative user name.", Position = 1, ParameterSetName = "Monitored")]
        [parameter(Mandatory = $true, HelpMessage = "Enter the iLO administrative user name.", Position = 1, ParameterSetName = "Managed")]
        [ValidateNotNullOrEmpty()]
        [string]$Username = $Null,

        [parameter(Mandatory = $true, HelpMessage = "Enter the iLO administrative account password.", Position = 2, ParameterSetName = "Monitored")]
        [parameter(Mandatory = $true, HelpMessage = "Enter the iLO administrative account password.", Position = 2, ParameterSetName = "Managed")]
        [ValidateNotNullOrEmpty()]
        [string]$Password = $Null,

        [parameter(Mandatory = $true, HelpMessage = "Enter licensing intent for the server being imported (OneView or OneViewNoiLO).", Position = 3, ParameterSetName = "Managed")]
        [ValidateSet("OneView", "OneViewNoiLO")]
        [string]$LicensingIntent = $NULL,

        [parameter(Mandatory = $true, ParameterSetName = "Monitored")]
        [switch]$Monitored,

		[parameter(Mandatory = $true, ParameterSetName = "Monitored")]
		[parameter(Mandatory = $true, ParameterSetName = "Managed")]
		[ValidateNotNullorEmpty()]
		[object]$ApplianceConnection = $null

    )

	Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if (-not($ApplianceConnection -is [HPOneView.Appliance.Connection]) -and (-not($ApplianceConnection -is [System.String])))
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException InvalidApplianceConnectionDataType InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter is not type [HPOneView.Appliance.Connection] or [System.String].  Please correct this value and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif  ($ApplianceConnection.Count -gt 1)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException MultipleApplianceConnections InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter contains multiple Appliance Connections.  This CMDLET only supports 1 Appliance Connection in the ApplianceConnect parameter value.  Please correct this and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		else
		{

			Try 
			{
	
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError 'ApplianceConnection' -TargetType $ApplianceConnection.GetType().Name -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}

		$colStatus = New-Object System.Collections.ArrayList

    }

    Process 
	{

		#New Server Resource Object
        $_server = NewObject -ServerImport
        $_server.hostname           = $hostname;
        $_server.username           = $username;
        $_server.password           = $password;
        $_server.licensingIntent    = $licensingIntent;        

		if ([bool]$Monitored) 
		{ 
        
            $_server.licensingIntent    = "OneViewStandard"
            $_server.configurationState = "Monitored"

        }

        else 
		{ 
			
			$_server.configurationState = "Managed" 
		
		}

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request to add server resource ($hostname)"

		Try
		{
		
			$task = Send-HPOVRequest $ServerHardwareUri POST $_server -Hostname $ApplianceConnection.Name
		
		}
        
		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Request response: $($task | out-string)"

		Try
		{
			
			$resp = Wait-HPOVTaskStart $task

		}

		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Task response: $($resp | out-string)"

        #Check to see if the task errored, which should be in the Task Validation stage
        if ($resp.taskState -ne "Running") 
		{

            if (($resp.taskState -eq "Error") -and ($resp.stateReason -eq "ValidationError")) 
			{

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Task error found: $($resp.taskState), $($resp.stateReason)"
                
                #taskErrors should contain only a single value, so we will force pick the first one.
                $errorMessage = $resp.taskerrors[0]
                
                switch ($errorMessage.errorCode) 
				{

                    "SERVER_ALREADY_MANAGED" 
					{ 
                    
                        $externalManagerType = $errorMessage.data.managementProduct
                        $externalManagerIP   = $errorMessage.data.managementUrl.Replace("https://","")

						Try
						{
						
							$externalManagerFQDN = [System.Net.DNS]::GetHostByAddress($externalManagerIP)
						
						}

						Catch
						{

							$PSCmdlet.ThrowTerminatingError($_)

						}
						
                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Found server '$hostname' is already being managed by $externalManagerType at $externalManagerIP."
                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $externalManagerIP resolves to $($externalManagerFQDN | out-string)"
                        write-warning "Server '$hostname' is already being managed by $externalManagerType at $externalManagerIP ($($externalManagerFQDN.HostName))."

                        if ($pscmdlet.ShouldProcess($hostname,"Server is already being managed by $externalManagerType at $externalManagerIP ($($externalManagerFQDN.HostName)). Force add?")) 
						{
		    	    
                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server was claimed and user chose YES to force add."

                	        $_server | add-member -MemberType NoteProperty -name force -value $true -force | out-null
                            
							Try
							{

								$resp = Send-HPOVRequest $ServerHardwareUri POST $_server -Hostname $ApplianceConnection.Name

							}

							Catch
							{

								$PSCmdlet.ThrowTerminatingError($_)

							}
							

		                }

		                else 
						{

                            if ($PSBoundParameters['whatif'].ispresent) 
							{ 
                    
                                write-warning "-WhatIf was passed, would have force added '$hostname' server to appliance."
                                
								$resp = $null
                    
                            }

                            else 
							{

		    	                #If here, user chose "No", end processing
		    	                write-warning "Not importing server, $hostname."
                                
								$resp = $Null

                            }`

		                }
                    
                    }

                    "INVALID_ADDR" 
					{ 
                    
                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Generating error: $($errorMessage.message)"
                        $errorRecord = New-ErrorRecord HPOneView.ServerHardwareResourceException ServerResourceNotFound ObjectNotFound 'New-HPOVServer' -Message ($errorMessage.message + " " + $errorMessage.recommendedActions )
                        $PSCmdlet.ThrowTerminatingError($errorRecord)
                    
                    }

                }
                    
            }

        }

		[void]$colStatus.Add($resp)
       
    }

    end 
	{
        
        Return $colStatus

    }

}

function Remove-HPOVServer 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(SupportsShouldProcess = $True,ConfirmImpact = 'High')]
    Param 
    (
    
        [parameter (Mandatory = $true, ValueFromPipeline = $true, HelpMessage = "Enter the rackmount server to be removed.", Position = 0)]
        [ValidateNotNullOrEmpty()]
        [Alias("uri","name")]
        [object]$Server,

		[parameter(Mandatory = $false)] 
		[switch]$force,

		[parameter(Mandatory = $true, ValueFromPipelineByPropertyName)]
		[Alias('Appliance')]
		[Object]$ApplianceConnection
	
    )

    Begin 
    {

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"
        
		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSBoundParameters['Server']))
		{

			$PipelineInput = $True

		}

		if (-not($PipelineInput))
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
			$c = 0
		
			ForEach ($_Connection in $ApplianceConnection) 
			{

				Try 
				{
			
					$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

				}

				Catch [HPOneview.Appliance.AuthSessionException] 
				{

					$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				Catch 
				{

					$PSCmdlet.ThrowTerminatingError($_.Exception)

				}

				$c++

			}

			#Check for URI parameters with multiple appliance connections
			if($ApplianceConnection.Count -gt 1)
			{

				if (($Server -is [String] -and ($Server.StartsWith($ServerHardwareUri))) -or ($Server -is [Array] -and ($Server | % { $_.startswith($ServerHardwareUri) }))) 
				{
                    
					$errorRecord = New-ErrorRecord HPOneView.ServerResourceException InvalidArgumentValue InvalidArgument 'Server' -Message "The Server parameter as URI is unsupported with multiple appliance connections.  Please check the -Server parameter value and try again."
					$PSCmdLet.ThrowTerminatingError($errorRecord)
            
				}

			}

		}
        
		$_ServersToRemoveCol = New-Object System.Collections.ArrayList
        $_TaskCollection     = New-Object System.Collections.ArrayList

    }

    Process 
	{

		if ($PipelineInput)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing pipeline input objects."

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Received object: $($Server | fl * | Out-String)"

			if ($Server.category -ne 'server-hardware')
			{

				$errorRecord = New-ErrorRecord HPOneView.ServerHardwareResourceException UnsupportedResourceCategory InvalidArgument 'Server' -TargetType 'PSObject' -Message "The provided Server object {$($Server.name)} is an unsupported object category, '$($Server.category)'.  Only 'server-hardware' category objects are supported. please check the parameter value and try again."
                $PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			#Throw error that you cannot remove a BL server
			if ($Server.locationUri -ne $Null -and $Server.model -match 'BL')
			{

				$errorRecord = New-ErrorRecord HPOneView.ServerHardwareResourceException CannotRemoveBLServerTypes InvalidOperation 'Server' -TargetType 'PSObject' -Message "The provided Server object {$($Server.name)} cannot be removed from the appliance, as it is a BL server class.  If you wish to remove a BL server from the appliance, you either physically remove the server from the enclosure or remove the enclosure from the appliance.  Please check the parameter value and try again."
                $PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			[void]$_ServersToRemoveCol.Add($Server)

		}

		Else
		{

			ForEach ($_connection in $ApplianceConnection)
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing $($_connection.Name) appliance connection (of $($ApplianceConnection.Count))."

				Try
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Network Set object from Get-HPOVNetworkSet."

					$Server = Get-HPOVServer $Server -ApplianceConnection $_connection

					[void]$_ServersToRemoveCol.Add($Server)

				}

				Catch
				{


					$PSCmdlet.ThrowTerminatingError($_)
				}

			}

		}

    }

	End
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing $($_ServersToRemoveCol.count) Server object resources to remove."

		#Process Storage Resources
		ForEach ($_server in $_ServersToRemoveCol)
		{

			if ($pscmdlet.ShouldProcess($_server.ApplianceConnection.Name,"Remove Server resource '$($_server.name)' from appliance")) 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Removing Server resource '$($_server.name)' from appliance '$($_storagesystem.ApplianceConnection.Name)'."

				if ($PSboundParameters['force'])
				{

					$_server.uri += "?force=true"

				}

				Try
				{

					$_resp = Send-HPOVRequest $_server.Uri DELETE -Hostname $_server.ApplianceConnection.Name

					[void]$_TaskCollection.Add($_resp)

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

			}

			elseif ($PSBoundParameters['WhatIf'])
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] WhatIf parameter was passed."

			}

		}

		Return $_TaskCollection

      }

}

function Set-HPOVServerPower 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding(SupportsShouldProcess = $True,ConfirmImpact = 'High')]
    Param 
    (
    
        [parameter(Mandatory, ValueFromPipeline, HelpMessage = "Enter the uri or name for the server resource.", position = 0)]
        [ValidateNotNullOrEmpty()]
        [alias("name","uri","serverUri")]
        [object]$Server,

        [parameter(Mandatory = $false, position = 1)]
        [ValidateSet("On", "Off")]
        [string]$powerState = "On",

        [parameter(Mandatory = $false, position = 2)]
        [ValidateSet("PressAndHold", "MomentaryPress", "ColdBoot", "Reset")]
        [string]$powerControl = "MomentaryPress",

        [parameter(Mandatory, ValueFromPipelineByPropertyName)]
		[Alias('Appliance')]
		[object]$ApplianceConnection = $null
    
    )

    Begin 
    {

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSBoundParameters['Server']))
		{

			$PipelineInput = $True

		}

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if (-not($ApplianceConnection -is [HPOneView.Appliance.Connection]) -and (-not($ApplianceConnection -is [System.String])) -and (-not($PipelineInput)))
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException InvalidApplianceConnectionDataType InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter is not type [HPOneView.Appliance.Connection] or [System.String].  Please correct this value and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif (($ApplianceConnection | Measure-Object).Count -gt 1 -and (-not($PipelineInput)))
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException MultipleApplianceConnections InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter contains multiple Appliance Connections.  This CMDLET only supports 1 Appliance Connection in the ApplianceConnect parameter value.  Please correct this and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif (-not($PipelineInput))
		{

			Try 
			{
	
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError 'ApplianceConnection' -TargetType $ApplianceConnection.GetType().Name -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_.Exception)

			}

		}

		$_ServerPowerControlCol = New-Object System.Collections.ArrayList

    }
    
    Process 
	{

        #Validate input object type
        #Checking if the input is System.String and is NOT a URI
        if (($server -is [string]) -and (-not($server.StartsWith($ServerHardwareUri)))) 
		{
            
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server is a Server Name: $($server)"

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Server URI"

            $serverUri = (Get-HPOVServer $server -Appliance $applianceConnection).uri

        }

        #Checking if the input is System.String and IS a URI
        elseif (($server -is [string]) -and ($server.StartsWith($ServerHardwareUri))) 
		{
            
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server is a Server device URI: $($server)"

            $serverUri = $server
        
        }

        #Checking if the input is PSCustomObject, and the category type is server-profiles, which could be passed via pipeline input
        elseif (($server -is [System.Management.Automation.PSCustomObject]) -and ($server.category -ieq "server-hardware")) 
		{

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server is a Server Device object: $($server.name)"

            $serverUri = $server.uri
        
        }

        #Checking if the input is PSCustomObject, and the category type is server-hardware, which would be passed via pipeline input
        elseif (($server -is [System.Management.Automation.PSCustomObject]) -and ($server.category -ieq "server-profiles") -and ($server.serverHardwareUri)) 
		{
            
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server is a Server Profile object: $($server.name)"

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting server hardware device assigned to Server Profile."

			if (-not($server.serverHardwareUri))
			{

				$errorRecord = New-ErrorRecord InvalidOperationException ServerProfileUnassigned InvalidArgument 'Server' -TargetType $Server.GetType().Name -Message "The Server Profile '$($Server.name)' is unassigned.  This cmdlet only supports Server Profiles that are assigned to Server Hardware resources. Please check the input object and try again."
				$pscmdlet.ThrowTerminatingError($errorRecord)

			}

            $serverUri = $server.serverHardwareUri
        
        }

        else 
		{

            $errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'Server' -TargetType $Server.GetType().Name -Message "The parameter 'Server' value is invalid.  Please validate the 'Server' parameter value you passed and try again."
            $pscmdlet.ThrowTerminatingError($errorRecord)

        }

        #Validate the server power state and lock
		Try
		{

			$_serverObj = Send-HPOVRequest $serverUri -appliance $ApplianceConnection.Name

		}

		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}
        
		#Need to add confirm prompt here.
        if (($_serverObj.powerState -ine $ServerPowerControlEnum[$powerControl]) -and (-not($_serverObj.powerLock))) 
		{

			
			if ($PSCmdLet.ShouldProcess($_serverObj.name,"Set Server Power $($ServerPowerControlEnum[$powerControl]) to desired Power State '$powerState' ?'")) 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Set Server Power '$($ServerPowerControlEnum[$powerControl])' to desired Power State '$powerState' on server device $($_serverObj.name)."

				#Enforce the proper string case
				$powerState = (Get-Culture).TextInfo.ToTitleCase($powerState)
        
				$uri = $_serverObj.uri + "/powerState"
	    
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server to change power state: $($uri)"
	    
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server Power State requested: $($powerControl)"
	    
				$body = [pscustomobject]@{
			
					powerState   = $powerState; 
					powerControl = $ServerPowerControlEnum[$powerControl]
			
				}
	    
				Try
				{

					$_resp = Send-HPOVRequest $uri PUT $body -Hostname $_serverObj.ApplianceConnection.Name
		
				}
	    
				Catch
				{
	    
	    			$PSCmdlet.ThrowTerminatingError($_)
		
				}

				[void]$_ServerPowerControlCol.Add($_resp)

			}

			elseif ($PSBoundParameters['WhatIf'])
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User provided -WhatIf parameter."

			}

			else
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User selected 'No'."

			}
	    
        }
	
        else 
		{ 
        
            if ($serverPowerState.powerState -ieq $powerState) 
			{
				
				 $errorMessage += "Requested Power State `($($powerState)`) is the same value as the current Server Power State `($($serverPowerState.powerState)`).  "  
			
			}

            if ($serverPowerState.powerLock) 
			{ 
				
				$errorMessage += "Server is currently under Power Lock.  "  
			
			}

            if ($errorMessage) 
			{ 
			
				write-error $errorMessage -Category InvalidOperation -CategoryTargetName "Set-HPOVServerPower" -ErrorAction Stop
			
			}
	    
        }
	
    }

	End
	{

		Return $_ServerPowerControlCol

	}

}

function Update-HPOVServer
{

	# .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding()]
    Param 
    (
    
        [parameter (Mandatory, ValueFromPipeline, HelpMessage = "Provide a Server Hardware resource Name or Object, or a Server Profile Object.", Position = 0)]
        [ValidateNotNullOrEmpty()]
        [Alias("name")]
        [object]$Server,

		[parameter(Mandatory = $true, ValueFromPipelineByPropertyName)]
		[Alias('Appliance')]
		[Object]$ApplianceConnection
	
    )

	Begin 
    {

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSBoundParameters['Server']))
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server object provided by pipeline."

			$PipelineInput = $True

		}

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if (-not($ApplianceConnection -is [HPOneView.Appliance.Connection]) -and (-not($ApplianceConnection -is [System.String])) -and (-not($PipelineInput)))
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException InvalidApplianceConnectionDataType InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter is not type [HPOneView.Appliance.Connection] or [System.String].  Please correct this value and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif (($ApplianceConnection | Measure-Object).Count -gt 1 -and (-not($PipelineInput)))
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException MultipleApplianceConnections InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter contains multiple Appliance Connections.  This CMDLET only supports 1 Appliance Connection in the ApplianceConnect parameter value.  Please correct this and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif (-not($PipelineInput))
		{

			Try 
			{
	
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError 'ApplianceConnection' -TargetType $ApplianceConnection.GetType().Name -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_.Exception)

			}

		}

		$_ServerRefreshCol = New-Object System.Collections.ArrayList

    }
    
    Process 
	{

        #Validate input object type
        #Checking if the input is System.String and is NOT a URI
        if (($server -is [string]) -and (-not($server.StartsWith($ServerHardwareUri)))) 
		{
            
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server is a Server Name: $($server)"

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Server URI"

            Try
			{

				$server = Send-HPOVRequst $server -Hostname $ApplianceConnection

			}
			
			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

        }

        #Checking if the input is System.String and IS a URI
        elseif (($server -is [string]) -and ($server.StartsWith($ServerHardwareUri))) 
		{
            
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server is a Server device URI: $($server)"

            Try
			{

				$server = Send-HPOVRequst $server -Hostname $ApplianceConnection.Name

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}
        
        }

        #Checking if the input is PSCustomObject, and the category type is server-profiles, which could be passed via pipeline input
        elseif (($server -is [System.Management.Automation.PSCustomObject]) -and ($server.category -ieq "server-hardware")) 
		{

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server is a Server Device object: $($server.name)"
        
        }

        #Checking if the input is PSCustomObject, and the category type is server-hardware, which would be passed via pipeline input
        elseif (($server -is [System.Management.Automation.PSCustomObject]) -and ($server.category -ieq "server-profiles") -and ($server.serverHardwareUri)) 
		{
            
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server is a Server Profile object: $($server.name)"

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting server hardware device assigned to Server Profile."

			if (-not($server.serverHardwareUri))
			{

				$errorRecord = New-ErrorRecord InvalidOperationException ServerProfileUnassigned InvalidArgument 'Server' -TargetType $Server.GetType().Name -Message "The Server Profile '$($Server.name)' is unassigned.  This cmdlet only supports Server Profiles that are assigned to Server Hardware resources. Please check the input object and try again."
				$pscmdlet.ThrowTerminatingError($errorRecord)

			}

            Try
			{

				$Server = Send-HPOVRequst $Server.serverHardwareUri -Hostname $ApplianceConnection.Name

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}
        
        }

        else 
		{

            $errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'Server' -TargetType $Server.GetType().Name -Message "The parameter 'Server' value is invalid.  Please validate the 'Server' parameter value you passed and try again."
            $pscmdlet.ThrowTerminatingError($errorRecord)

        }

		"[$($MyInvocation.InvocationName.ToString().ToUpper())] Refreshing Server Hardware device: {0}" -f $Server.name | Write-Verbose 
        
		$uri = $Server.uri + "/refreshState"

		$body = [pscustomobject]@{
			
			refreshState   = 'RefreshPending'
			
		}
	    
		Try
		{

			$_resp = Send-HPOVRequest $uri PUT $body -Hostname $Server.ApplianceConnection.Name
		
		}
	    
		Catch
		{
	    
	    	$PSCmdlet.ThrowTerminatingError($_)
		
		}

		[void]$_ServerRefreshCol.Add($_resp)
	
    }

	End
	{

		Return $_ServerRefreshCol

	}

}

function Get-HPOVEnclosureGroup 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding()]    
    Param 
	(

        [parameter(Position = 0, Mandatory = $false)]
		[ValidateNotNullorEmpty()]
        [string]$Name = $null,

		[parameter(Position = 1, Mandatory = $false)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions},

        [parameter (Mandatory = $false)]
        [alias("x", "export")]
        [ValidateScript({split-path $_ | Test-Path})]
        [String]$exportFile

    )

	Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		if  ($ApplianceConnection.Count -eq 0)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoAuthSessionFound InvalidArgument 'ApplianceConnection' -Message 'No ApplianceConnections were found.  Please use Connect-HPOVMgmt to establish an appliance connection.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		$c = 0
		
		ForEach ($_connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$EGCollection = New-Object System.Collections.ArrayList
        
	}

    Process 
	{

		ForEach ($_connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($Connection.Name)' Appliance (of $($Appliance.Count))"

			if ($PSboundParameters['name']) 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Group name provided: '$name'"
	
				$name = $name -replace ("[*]","%25") -replace ("[&]","%26")
	
				#$uri = $enclosureGroupsUri + "?filter=name='$name'"
				$uri = $enclosureGroupsUri + "?filter=name matches '$name'"
	
			}
	
			else 
			{
	
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No Enclosure Group name provided. Looking for all Enclosure Group resources."
	
				$uri = $enclosureGroupsUri
	
			}
	
			Try
			{
	
				$enclGrps = Send-HPOVRequest $uri -Hostname $_connection
	
			}
	        
			Catch
			{
	
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] API Error Caught: $($_.Exception.Message)"
	
				$PSCmdlet.ThrowTerminatingError($_)
	
			}
	
			if ($enclGrps.count -eq 0 -and $name) 
			{ 
	
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Group '$name' resource not found. Generating error"

				$errorRecord = New-ErrorRecord InvalidOperationException EnclosureGroupNotFound ObjectNotFound 'Name' -Message "The specified Enclosure Group '$name' was not found on '$($_connection.Name)'.  Please check the name and try again." 
				$pscmdlet.ThrowTerminatingError($errorRecord)  
	            
			}
	
			elseif ($enclGrps.count -eq 0) 
			{ 
	
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No Enclosure Group resources found."
	
			}
	
			else 
			{
	
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Found $($enclGrps.count) Enclosure Group resources."
	
				# // Todo Update ConvertTo-Object with EG
				$enclGrps.members | % { 
					
					$_.PSObject.TypeNames.Insert(0,'HPOneView.EnclosureGroup')	
	
					[void]$EGCollection.Add($_ ) 
					
				}
	 
			}

		}

   
    }

    end 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Done. $($enclGrps.count) enclosure group(s) found."     

        if ($exportFile)
		{ 
			
			$enclGrps.members | convertto-json -Depth 99 | Set-Content -Path $exportFile -force -encoding UTF8 
		
		}
                
        else 
		{
			
			Return $EGCollection
		
		}  

    }

}

function New-HPOVEnclosureGroup 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding()]
    Param 
	(

        [parameter(Position = 0, Mandatory, ParameterSetName = 'Default', HelpMessage = "Enter a name for the new enclosure group.")]
        [ValidateNotNullOrEmpty()]
        [string]$Name = $Null,
         
        [parameter(Position = 1, Mandatory, ValueFromPipeline, ParameterSetName = 'Default', HelpMessage = "Enter the Object or URI or Array of Objects or URIs of the Logical Interconnect Group to associate with the Enclosure Group.")]
        [ValidateNotNullOrEmpty()]
        [alias('logicalInterconnectGroupUri','logicalInterconnectGroup')]
        [object]$LogicalInterconnectGroupMapping = $Null,

        [parameter(Position = 2, Mandatory = $false, ParameterSetName = 'Default')]
		[ValidateSet('RedundantPowerFeed','RedundantPowerSupply', IgnoreCase = $false)]
        [string]$PowerRedundantMode = "RedundantPowerFeed",

        [parameter(Position = 3, Mandatory = $false, ParameterSetName = 'Default')]
        [string]$ConfigurationScript = $null,

		[parameter(Mandatory, ValueFromPipelineByPropertyName)]
		[Alias('Appliance')]
		[Object]$ApplianceConnection = $null,

		[parameter(Mandatory = $true, ParameterSetName = "importFile", HelpMessage = "Enter the full path and file name for the input file.")]
		[Alias("i", "import")]
		[string]$ImportFile

    )

	Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		Try 
		{
	
			$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

		}

		Catch [HPOneview.Appliance.AuthSessionException] 
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		Catch 
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

		if (-not($PSBoundParameters['LogicalInterconnectGroupMapping']))
		{

			$PipelineInput = $true

		}

		$_EnclosureGroupCreateResults = New-Object System.Collections.ArrayList

    }

    Process 
	{

		$_EnclosureGroup = NewObject -EnclosureGroup

		#Process LIG Object here, and will be on a single Appliance Connection
        if ($PipelineInput -or $LogicalInterconnectGroupMapping -is [PSCustomObject]) 
		{ 
			
			if ($PipelineInput) 
			{
				
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] LIG was passed via pipeline." 

			}

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Single LIG Object:  $($LogicalInterconnectGroupMapping | fl * | out-string)" 

			#Check to make sure the object is a LIG, generate error if not
			if (-not($LogicalInterconnectGroupMapping.category -eq 'logical-interconnect-groups'))
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Invalid LIG Category value provided '$($LogicalInterconnectGroupMapping.category)'"

                $errorRecord = New-ErrorRecord InvalidOperationException InvalidLogicalInterconnectGroupCategory InvalidType 'LogicalInterconnectGroupMapping' -TargetType 'PSObject' -Message "Invalid [PSObject] value provided '$LogicalInterconnectGroupMapping'.  Logical Interconnect Group category must begin with 'logical-interconnect-groups'.  Please check the value and try again."
                $PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			"[$($MyInvocation.InvocationName.ToString().ToUpper())] Will process {0} Interconnect Bay Logical Location Entries in LIG Object." -f ($LogicalInterconnectGroupMapping.interconnectMapTemplate.interconnectMapEntryTemplates.logicalLocation | Measure-Object).Count | Write-Verbose

			$c = 1

			#Process Interconnect Bay Mapping, which is 1 LIG
			ForEach ($_LigBayMapping in $LogicalInterconnectGroupMapping.interconnectMapTemplate.interconnectMapEntryTemplates)
			{

				"Processing {0} of {1} Bay Mappings" -f $c,($LogicalInterconnectGroupMapping.interconnectMapTemplate.interconnectMapEntryTemplates.logicalLocation | Measure-Object).Count | Write-Verbose

				$_InterconnectBayMapping = NewOBject -InterconnectBayMapping

				$_InterconnectBayMapping.interconnectBay             = ($_LigBayMapping.logicalLocation.locationEntries | ? type -EQ 'bay').relativeValue
				$_InterconnectBayMapping.logicalInterconnectGroupUri = $LogicalInterconnectGroupMapping.uri

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Interconnect Bay Mapping Entry found in LIG resource:  $($_LigBayMapping)" 

				[void]$_EnclosureGroup.interconnectBayMappings.Add($_InterconnectBayMapping)

				$c++

			}

		}

		#Loop through Appliance Connections to create the Enclosure Group, and LIG Bay Mapping
		else
		{

			ForEach ($_key in $LogicalInterconnectGroupMapping.Keys)
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Hashtable key '$_key'"

				$_InterconnectBayMapping = NewOBject -InterconnectBayMapping

				switch (($LogicalInterconnectGroupMapping.$_key).GetType().Name)
				{

					'PSCustomObject'
					{

						#Validate object is a LIG
						if (-not(($LogicalInterconnectGroupMapping.$_key).category -eq 'logical-interconnect-groups'))
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Invalid [PSCustomObject] value provided '$(($LogicalInterconnectGroupMapping.$_key).category)' for '$_key' Hashtable entry."
									
							$errorRecord = New-ErrorRecord InvalidOperationException InvalidLogicalInterconnectGroupMappingObject InvalidArgument 'LogicalInterconnectGroupMapping' -TargetType 'PSObject' -Message "Invalid [PSCustomObject] value provided '$(($LogicalInterconnectGroupMapping.$_key).category)' for '$_key' Hashtable entry.  Logical Interconnect Group object category must be 'logical-interconnect-groups'.  Please check the value and try again."
							$PSCmdlet.ThrowTerminatingError($errorRecord)

						}

						$_InterconnectBayMapping.interconnectBay             = ((($LogicalInterconnectGroupMapping.$_key).interconnectMapTemplate.interconnectMapEntryTemplates.LogicalLocation.locationEntries) | ? { $_.type -EQ 'bay' -and $_.relativeValue -EQ $_key}).relativeValue
						$_InterconnectBayMapping.logicalInterconnectGroupUri = ($LogicalInterconnectGroupMapping.$_key).uri

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Interconnect Bay Mapping Entry:  $($_InterconnectBayMapping)" 

					}

					'String'
					{

						#Value is an Objects URI
						if (($LogicalInterconnectGroupMapping.$_key).StartsWith($logicalInterconnectGroupUri))
						{

							$_InterconnectBayMapping.interconnectBay             = $_key
							$_InterconnectBayMapping.logicalInterconnectGroupUri = $LogicalInterconnectGroupMapping.$_key

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Interconnect Bay Mapping Entry:  $($_InterconnectBayMapping)" 

						}

						#Object Name value
						else
						{

							Try
							{
									
								$_LogicalInterconnectGroupObject = Get-HPOVLogicalInterconnectGroup $LogicalInterconnectGroupMapping.$_key -ApplianceConnection $ApplianceConnection.Name

								$_InterconnectBayMapping.interconnectBay             = $_key
								$_InterconnectBayMapping.logicalInterconnectGroupUri = $_LogicalInterconnectGroupObject.uri
									
							}
									
							Catch
							{

								$PSCmdlet.ThrowTerminatingError($_)

							}

						}

					}

				}

				[void]$_EnclosureGroup.interconnectBayMappings.Add($_InterconnectBayMapping)

			}

		}

		if (($_EnclosureGroup.interconnectBayMappings | Measure-Object).count -lt 8)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding null interconnectBayMapping entries." 

			for ($b = $_EnclosureGroup.interconnectBayMappingCount - $_EnclosureGroup.interconnectBayMappings.count; $b -ne 0; $b--)
			{

				$_InterconnectBayMapping = NewOBject -InterconnectBayMapping

				$n = 1

				do
				{

					$_bayId = $null

					if (-not($_EnclosureGroup.interconnectBayMappings | ? interconnectBay -eq $n))
					{

						$_bayId = $n

					}
    

					#ERROR, we should never get more than the number of $_EnclosureGroup.interconnectBayMappingCount
					if ($n -gt $_EnclosureGroup.interconnectBayMappingCount)
					{

						$ErrorRecord = New-ErrorRecord System.InvalidOperationException InvalidOperation InvalidOperation -Message "Could not determine Enclosure Group interconnectBay ID (`$_bayId). (`$n = $n)"

						$PSCmdlet.ThrowTerminatingError($errorRecord)

					}

					$n++

				}
				until ($_bayId)

				$_InterconnectBayMapping.interconnectBay = $_bayId

				[void]$_EnclosureGroup.interconnectBayMappings.Add($_InterconnectBayMapping)

			}
			
		}

        $_EnclosureGroup.name                = $Name
        $_EnclosureGroup.configurationScript = $ConfigurationScript
		$_EnclosureGroup.powerMode           = $PowerRedundantMode

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Group object: $($_EnclosureGroup | out-string)"

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Creating $($_EnclosureGroup.name) Enclosure Group"


		Try
		{

			$resp = Send-HPOVRequest $enclosureGroupsUri POST $_EnclosureGroup -Hostname $ApplianceConnection.Name

			$resp.PSObject.TypeNames.Insert(0,'HPOneView.EnclosureGroup')

		}

		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}
        

		$_EnclosureGroupCreateResults.Add($resp)

    }

    End 
	{

        return $_EnclosureGroupCreateResults

    }

}

function Remove-HPOVEnclosureGroup 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "default",SupportsShouldProcess = $True,ConfirmImpact = 'High')]
    Param 
	(

        [parameter (Position = 0, Mandatory, ValueFromPipeline, ParameterSetName = "default", HelpMessage = "Enter the Enclosure Group to remove.")]
        [ValidateNotNullOrEmpty()]
        [Alias("uri", "name", "EnclosureGroup")]
        [object]$Resource,

		[parameter(Position = 1, ValueFromPipelineByPropertyName, Mandatory = $false)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = $null,

        [parameter(Mandatory = $false)]
        [switch]$Force

    )

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		ForEach ($_connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		if (-not($PSBoundParameters['Enclosure'])) { $PipelineInput = $True }

		$_TaskCollection           = New-Object System.Collections.ArrayList
		$_EnclosureGroupCollection = New-OBject System.Collections.ArrayList
        
	}

    Process 
	{

		if  ($ApplianceConnection.Count -eq 0)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoAuthSessionFound InvalidArgument 'ApplianceConnection' -Message 'No ApplianceConnections were found.  Please use Connect-HPOVMgmt to establish an appliance connection.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		if ($PipelineInput) 
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Pipeline input"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Group Object provided: $($Resource | FL * | Out-String)"

			If ($Resource.category -eq 'enclosure-groups')
			{

				If (-not($Resource.ApplianceConnection))
				{

					$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument $Resource.Name -TargetType PSObject -Message "The Enclosure Group resource provided is missing the source ApplianceConnection property.  Please check the object provided and try again."
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				[void]$_EnclosureGroupCollection.Add($Resource)

			}

			else
			{

				$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument $Resource.Name -TargetType PSObject -Message "The Enclosure Group resource is not an expected category type [$($Resource.category)].  Allowed resource category type is 'enclosure-groups'.  Please check the object provided and try again."
                $PSCmdlet.ThrowTerminatingError($errorRecord)

			}

		}

		else 
		{

			foreach ($enclosuregroup in $Resource) 
			{

				#Enclosure passed is a URI
				if (($enclosuregroup -is [String]) -and [System.Uri]::IsWellFormedUriString($enclosure,'Relative')) 
				{

				    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Received URI: $($enclosuregroup)"

				    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Enclosure Group Object"

					# // NEED APPLIANCE NAME HERE with If Condition
					Try
					{
						
						$enclosuregroup = Send-HPOVRequest $enclosuregroup -ApplianceConnection $ApplianceConnection

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

				}

				#Enclosure passed is the Name
				elseif (($enclosuregroup -is [string]) -and (-not($enclosuregroup.startsWith("/rest")))) 
				{

				    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Received Enclosure Group Name $($enclosuregroup)"

				    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Enclosure Group object from Get-HPOVEnclosureGroup"
				    
					# // NEED APPLIANCE NAME HERE with If Condition
					Try
					{

						$enclosuregroup = Get-HPOVEnclosureGroup $enclosuregroup -ApplianceConnection $ApplianceConnection

					}
				    

				    Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

				}

				#Enclosure passed is an object
				elseif ($enclosuregroup -is [PSCustomObject] -and ($enclosuregroup.category -ieq 'enclosure-groups')) 
				{
				    
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Group Object provided: $($enclosuregroup | FL * | out-string)"
				
				}

				else 
				{

				    $errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'Resource' -TargetType 'PSObject' -Message "Invalid Resource parameter: $($enclosuregroup | FL * | Out-String)"
				    $PSCmdlet.WriteError($errorRecord)

				}

				[void]$_EnclosureGroupCollection.Add($enclosuregroup)

			}

		}
        
    }

	End
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing $($_EnclosureGroupCollection.count) Enclosure Group resources to remove."

		#Process Enclosure Resources
		ForEach ($_enclosuregroup in $_EnclosureGroupCollection)
		{

			if ($pscmdlet.ShouldProcess($_enclosuregroup.name,"Remove Enclosure Group from appliance '$($_enclosuregroup.ApplianceConnection.Name)'?")) 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Removing Enclosure Group '$($_enclosuregroup.name)' from appliance '$($_enclosuregroup.ApplianceConnection.Name)'."

				Try
				{
					
					if ($PSBoundParameters['Force'])
					{

						$_enclosuregroup.uri += "?force=true"

					}

					$_resp = Send-HPOVRequest $_enclosuregroup.Uri DELETE -Hostname $_enclosuregroup.ApplianceConnection.Name

					[void]$_TaskCollection.Add($_resp)

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

			}

			elseif ($PSBoundParameters['WhatIf'])
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] WhatIf parameter was passed."

			}

		}

		Return $_TaskCollection

	}

}

function Add-HPOVEnclosure 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding(DefaultParameterSetName = "Managed", SupportsShouldProcess = $true,ConfirmImpact = "High")]
    Param 
	(

        [parameter(Position = 0, Mandatory = $true, HelpMessage = "Enter the host name (FQDN) or IP of the primary OA.", ParameterSetName = "Monitored")]
        [parameter(Position = 0, Mandatory = $true, HelpMessage = "Enter the host name (FQDN) or IP of the primary OA.", ParameterSetName = "Managed")]
        [ValidateNotNullOrEmpty()]
        [Alias("oa")]
        [string]$Hostname,
         
        [parameter(position = 1, Mandatory = $true, HelpMessage = "Enter the enclosure group name with which to associate the new enclosure.", ParameterSetName = "Managed")]
        [ValidateNotNullOrEmpty()]
        [Alias("eg",'EnclGroupName')]
        [object]$EnclosureGroup,

        [parameter(position = 1,Mandatory = $true, HelpMessage = "Enter the OA administrative user name.", ParameterSetName = "Monitored")]
        [parameter(position = 2,Mandatory = $true, HelpMessage = "Enter the OA administrative user name.", ParameterSetName = "Managed")]
        [ValidateNotNullOrEmpty()]
        [Alias("u", "user")]
        [string]$Username,

        [parameter(position = 2,Mandatory = $true, HelpMessage = "Enter the OA administrative account password.", ParameterSetName = "Monitored")]
        [parameter(position = 3,Mandatory = $true, HelpMessage = "Enter the OA administrative account password.", ParameterSetName = "Managed")]
        [ValidateNotNullOrEmpty()]
        [Alias("p", "pw")]
        [string]$Password,

        [parameter(position = 4,Mandatory = $true, HelpMessage = "Enter licensing intent for servers in this enclosure (OneView, OneViewNoiLO, or OneViewStandard).", ParameterSetName = "Managed")]
        [ValidateSet('OneView', 'OneViewNoiLO', 'OneViewStandard', IgnoreCase = $False)]
        [Alias("license", "l")]
        [string]$LicensingIntent,

        [parameter(position = 5, Mandatory = $false, ParameterSetName = "Managed")]
        [Alias("fwIso","fwBaselineIsoFilename")]
        [object]$Baseline = $NULL,

        [parameter(Mandatory = $false, ParameterSetName = "Managed")]
        [alias('forceFw','forceInstall')]
        [switch]$ForceInstallFirmware,

        [parameter(Mandatory = $true, ParameterSetName = "Monitored")]
        [switch]$Monitored,

		[parameter(Mandatory = $true, ParameterSetName = "Monitored")]
		[parameter(Mandatory = $true, ParameterSetName = "Managed")]
		[ValidateNotNullorEmpty()]
		[object]$ApplianceConnection = $null

    )

	Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if (-not($ApplianceConnection -is [HPOneView.Appliance.Connection]) -and (-not($ApplianceConnection -is [System.String])))
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException InvalidApplianceConnectionDataType InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter is not type [HPOneView.Appliance.Connection] or [System.String].  Please correct this value and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif  ($ApplianceConnection.Count -gt 1)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException MultipleApplianceConnections InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter contains multiple Appliance Connections.  This CMDLET only supports 1 Appliance Connection in the ApplianceConnect parameter value.  Please correct this and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		else
		{

			Try 
			{
	
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError 'ApplianceConnection' -TargetType $ApplianceConnection.GetType().Name -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}

		$colStatus = New-Object System.Collections.ArrayList

    }

    Process 
	{

        #Locate the Enclosure Group specified
        write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Starting"

		$_import          = NewObject -EnclosureImport
		$_import.hostname = $hostname
        $_import.username = $username
        $_import.password = $password

        if (-not([bool]$Monitored))
		{

			write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Building Managed Enclosure request"

			switch ($EnclosureGroup.GetType().Name)
			{

				'PSCustomObject'
				{

						write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - EnclosureGroup parameter is 'PSCustomObject'"

						write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - EnclosureGroup object category: '$($EnclosureGroup.category)'"

						write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - EnclosureGroup object name: '$($EnclosureGroup.name)'"

						if ($EnclosureGroup.category -ne 'enclosure-groups')
						{

							$errorRecord = New-ErrorRecord HPOneView.EnclosureGroupResourceException InvalidEnclosureGroupObject InvalidArgument 'EnclosureGroup' -TargetType 'PSObject' -Message "The EnclosureGroup parameter value contains an invalid or unsupported resource category, '$($EnclosureGroup.category)'.  The object category must be 'enclosure-groups'.  Please correct the value and try again."
							$PSCmdlet.ThrowTerminatingError($errorRecord)

						}

						else
						{

							$_enclosuregroup = $EnclosureGroup.PSObject.Copy()

						}

					}

				'String'
				{

						if ($EnclosureGroup.StartsWith($enclosureGroupsUri))
						{

							Try
							{

								$_enclosuregroup = Get-HPOVEnclosureGroup $EnclosureGroup -ApplianceConnection $ApplianceConnection

							}

							catch
							{

								$PSCmdlet.ThrowTerminatingError($_)

							}

						}

						else
						{

							Try
							{

								$_enclosuregroup = Get-HPOVEnclosureGroup $EnclosureGroup -ApplianceConnection $ApplianceConnection

							}
							
							Catch
							{

								$PSCmdlet.ThrowTerminatingError($_)

							}

						}
						
						write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Found Enclosure Group $($_enclosuregroup | out-String)"

					}

			}
            			

            $_import.licensingIntent      = $licensingIntent
            $_import.enclosureGroupUri    = $_enclosuregroup.uri
            $_import.forceInstallFirmware = [bool]$forceInstallFirmware
            $_import.updateFirmwareOn     = "EnclosureOnly" 
            
            if ($baseline) 
			{
					
					write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Firmware Baseline is to be configured"
					
					switch ($baseline.Gettype().Name) 
					{

						"String" 
						{
							
							if ($baseline.StartsWith($script:fwDriversUri)) 
							{
								
								write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Firmware Baseline URI Provided '$Basline'"
								
								Try
								{

									$fwBaseLine = Send-HPOVRequest $baseline -Hostname $ApplianceConnection.Name

								}
								
								Catch
								{

									$PSCmdlet.ThrowTerminatingError($_)

								}
						
							
							}
							
							elseif ((-not ($baseline.StartsWith($script:fwDriversUri)) -and ($baseline.StartsWith('/rest/')))) 
							{

								write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Invalid Firmware Baseline URI Provided '$Basline'"
								
								$errorRecord = New-ErrorRecord HPOneView.BaselineResourceException InavlideBaselineUri InvalidArgument 'Baseline' -Message "The Basline URI '$baseline' provided does not begin with '$script:fwDriversUri'.  Please correct the value and try again."
								$PSCmdlet.ThrowTerminatingError($errorRecord)
							
							}

							else 
							{

								write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Firmware Baseline Name Provided '$Basline'"
								
								if ($baseline -match ".iso") 
								{

									write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Getting Baseline based on isoFileName."
									
									$fwBaseLine = Get-HPOVBaseline -isoFileName $baseline -ApplianceConnection $ApplianceConnection
								
								}

								else 
								{

									write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Getting Baseline based on Baseline Name."
									
									$fwBaseLine = Get-HPOVBaseline -SppName $baseline -ApplianceConnection $ApplianceConnection
								
								}
							}

							$_import.firmwareBaselineUri = $fwBaseLine.uri
						
						}
						"PSCustomObject" 
						{

							if ($baseline.category -eq "firmware-drivers" -and $baseline.ApplianceConnection.Name -eq $ApplianceConnection.Name) 
							{

								write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Firmware Baseline Object Provided: $($Basline | Out-String)"
								
								$import.firmwareBaselineUri = $Basline.uri	

							}

							else 
							{

								write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Invalid Firmware Baseline Object Provided: $($Basline | Out-String)"

								if ($baseline.category -ne "firmware-drivers" -and $baseline.ApplianceConnection.Name -eq $ApplianceConnection.Name) 
								{

									$errorRecord = New-ErrorRecord HPOneView.BaselineResourceException InvalideBaselineObject InvalidArgument 'Baseline' -TargetType 'PSObject' -Message "The Basline Category '$($baseline.category)' provided does not match the required value 'firmware-drivers'.  Please correct the value and try again."

								}
								
								elseif ($baseline.category -eq "firmware-drivers" -and $baseline.ApplianceConnection.Name -ne $ApplianceConnection.Name) 
								{

									$errorRecord = New-ErrorRecord HPOneView.BaselineResourceException InvalidBaselineOrigin InvalidArgument 'Baseline' -TargetType 'PSObject' -Message "The Basline '$($baseline.name)' provided does not originate from the same ApplianceConnection you have specified.  Please correct the value and try again."

								}
								
								$PSCmdlet.ThrowTerminatingError($errorRecord)

							}

						}

					}

                }       

        }

        else 
		{

			write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Building Monitored Enclosure request"

            $_import.licensingIntent = "OneViewStandard"
            $_import.state           = "Monitored"

        }

		write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Sending request to claim enclosure"

		Try
		{

			$resp = Send-HPOVRequest $script:enclosuresUri POST $_import -Hostname $ApplianceConnection.Name

		}
        
		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

		Try
		{

			#Wait for task to get into Starting stage
			$resp = Wait-HPOVTaskStart $resp
		
		}

		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

        write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - task response: $($resp | out-string)"

        #Check to see if the task errored, which should be in the Task Validation stage
        if ($resp.taskState -ne "Running") 
		{

            if (($resp.taskState -eq "Error") -and ($resp.stateReason -eq "ValidationError")) 
			{

                write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Task error found $($resp.taskState) $($resp.stateReason) "

                if ($resp.taskerrors | Where-Object { ($_.errorCode -eq "ENCLOSURE_ALREADY_MANAGED") -or ($_.errorCode -eq "ENCLOSURE_MANAGED_BY_VCM") }) 
				{
                
                    $errorMessage = $resp.taskerrors | Where-Object { ($_.errorCode -eq "ENCLOSURE_ALREADY_MANAGED") -or ($_.errorCode -eq "ENCLOSURE_MANAGED_BY_VCM") }

                    $externalManagerType = $errorMessage.data.managementProduct
                    $externalManagerIP   = $errorMessage.data.managementUrl.Replace("https://","")
                    $externalManagerFQDN = [System.Net.DNS]::GetHostByAddress($externalManagerIP)

                    write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Found enclosure '$hostname' is already being managed by $externalManagerType at $externalManagerIP."
                    write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - $externalManagerIP resolves to $($externalManagerFQDN | out-string)"
                    
					write-warning "Enclosure '$hostname' is already being managed by $externalManagerType at $externalManagerIP ($($externalManagerFQDN.HostName))."

                    if ($pscmdlet.ShouldProcess($hostname,"Enclosure '$hostname' is already being managed by $externalManagerType at $externalManagerIP ($($externalManagerFQDN.HostName)). Force add?")) 
					{
		            
                        write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Server was claimed and user chose YES to force add."

                        $_import.force = $true
                        
						Try
						{
						
							$resp = Send-HPOVRequest $enclosuresUri POST $_import -Hostname $ApplianceConnection.Name
						
						}

						Catch
						{

							$PSCmdlet.ThrowTerminatingError($_)

						}
						

		            }

		            else 
					{

                        if ($PSBoundParameters['whatif'].ispresent) 
						{	 
                    
                            write-warning "-WhatIf was passed, would have force added '$hostname' enclosure to appliance."

                            $resp = $null
                    
                        }

                        else 
						{

		                    #If here, user chose "No", end processing
		                    write-warning "Not importing enclosure, $hostname."

                            $resp = $Null

                        }

		            }

                }

                else 
				{

                    $errorMessage = $resp.taskerrors

                    if ($errorMessage -is [Array]) 
					{ 
                
                        #Loop to find a Message value that is not blank.
                        $displayMessage = $errorMessage | ? { $_.message }

                        $errorRecord = New-ErrorRecord HPOneView.EnclosureResourceException $displayMessage.errorCode InvalidResult 'New-HPOVEnclosure' -Message $displayMessage.message }
                
                    else 
					{ 
						
						$errorRecord = New-ErrorRecord HPOneView.EnclosureResourceException $errorMessage.errorCode InvalidResult 'New-HPOVEnclosure' -Message ($errorMessage.details + " " + $errorMessage.message) 
					
					}

                    $PSCmdlet.ThrowTerminatingError($errorRecord)

                }

            }

        }

		[void]$colStatus.Add($resp)

    }

    end 
	{
        
        Return $colStatus

    }

}

function Update-HPOVEnclosure 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding(DefaultParameterSetName = "Refresh", SupportsShouldProcess = $True, ConfirmImpact = 'High')]
    Param 
	(
        
        [parameter(Position = 0, ValueFromPipeline = $True, Mandatory = $false, HelpMessage = "Enter the Enclosure Name, or an Array of names.", ParameterSetName = "Reapply")]
        [parameter(Position = 0, ValueFromPipeline = $True, Mandatory = $false, HelpMessage = "Enter the Enclosure Name, or an Array of names.", ParameterSetName = "Refresh")]
        [ValidateNotNullOrEmpty()]
        [object]$Enclosure,

		[parameter(Position = 1, ValueFromPipelineByPropertyName, Mandatory = $false)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions},

        [parameter(Mandatory = $true, HelpMessage = "Refresh the Enclosure configuration.", ParameterSetName = "Refresh")]
        [Switch]$Refresh,

        [parameter(Mandatory = $true, HelpMessage = "Reapply Enclosure Configuration", ParameterSetName = "Reapply")]
        [Switch]$Reapply,

        [parameter(Mandatory = $false, HelpMessage = "Monitor the progress.", ParameterSetName = "Reapply")]
        [parameter(Mandatory = $false, HelpMessage = "Monitor the progress.", ParameterSetName = "Refresh")]
        [switch]$Monitor

    )

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		#Support ApplianceConnection property value via pipeline from Enclosure Object
		if($PSboundParameters['ApplianceConnection'])
		{

			ForEach ($_connection in $ApplianceConnection) 
			{

				Try 
				{
			
					$ApplianceConnection[$c] = Test-HPOVAuth $_connection

				}

				Catch [HPOneview.Appliance.AuthSessionException] 
				{

					$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_connection -Message $_.Exception.Message -InnerException $_.Exception
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				Catch 
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

				$c++

			}

		}

		if (-not($PSBoundParameters['Enclosure'])) { $PipelineInput = $True }

		$_TaskCollection      = New-Object System.Collections.ArrayList
		$_EnclosureCollection = New-OBject System.Collections.ArrayList
        
	}

    Process 
	{

		if ($PipelineInput) 
		{
		
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Pipeline input."

			#error if the input value is not a PSObject
			if (-not($Enclosure -is [PSCustomObject]))
			{

				$errorRecord = New-ErrorRecord HPOneView.EnclosureResourceException InvalidEnclosureObjectType InvalidArgument 'Enclosure' -TargetType 'PSObject' -Message "The provided Enclosure value is not a valid PSObject ($($Enclosure.GetType().Name)). Please correct your input value."
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure PSObject: $($Enclosure | FL * | out-string)."

			#Validate the Input object is the allowed category
			if ($Enclosure.category -ne 'enclosures')
			{

				$errorRecord = New-ErrorRecord HPOneView.LogicalEnclosureResourceException InvalidLogicalEnclosureCategory InvalidArgument 'Enclosure' -TargetType 'PSObject' -Message "The provided Enclosure object ($($Enclosure.name)) category '$($LogicalEnclosure.category)' is not an allowed value.  Expected category value is 'enclosures'. Please correct your input value."
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			if(-not($Enclosure.ApplianceConnection))
			{

				$errorRecord = New-ErrorRecord HPOneView.LogicalEnclosureResourceException InvalidLogicalEnclosureObject InvalidArgument 'Enclosure' -TargetType 'PSObject' -Message "The provided Enclosure object ($($Enclosure.name)) does not contain the required 'ApplianceConnection' object property. Please correct your input value."
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			[void]$_EnclosureCollection.Add($Enclosure)
		
		}

		#Not Pipeline input, and support Array of Enclosure Name or PSObject
		else
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing LogicalEnclosure parameter."

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] LogicalEnclosure is [$($Enclosure.GetType().Name)]."

			ForEach ($_encl in $Enclosure)
			{

				switch ($_encl.GetType().Name)
				{

					#Enclosure Name
					'String' 
					{
					
						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure value: $($_encl)."

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Looking for Enclosure Name on connected sessions provided"

						#Loop through all Appliance Connections
						ForEach ($_connection in $ApplianceConnection)
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_connection.Name)' Session."

							Try
							{

								$_resp = Get-HPOVLogicalEnclosure $_encl -ApplianceConnection $_connection.Name

							}

							Catch
							{

								$PSCmdlet.ThrowTerminatingError($_)

							}

							[void]$_EnclosureCollection.Add($_resp)

						}
					
					}

					#Enclosure Object
					'PSCustomObject'
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure PSObject: $($_encl | FL * | out-string)."

						#Validate the Input object is the allowed category
						if ($_encl.category -ne 'enclosures')
						{

							$errorRecord = New-ErrorRecord HPOneView.EnclosureResourceException InvalidEnclosureCategory InvalidArgument 'Enclosure' -TargetType 'PSObject' -Message "The provided Enclosure object ($($_encl.name)) category '$($_encl.category)' is not an allowed value.  Expected category value is 'enclosures'. Please correct your input value."
							$PSCmdlet.ThrowTerminatingError($errorRecord)

						}

						[void]$_EnclosureCollection.Add($_resp)

					}

				}

			}

		}

	}

	End
	{
        #Perform the work
        ForEach ($_enclosure in $_EnclosureCollection) 
		{

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Enclosure: '$($_enclosure.name) [$($_enclosure.uri)]'"
            
			if ($pscmdlet.ShouldProcess($_enclosure.name,"$($PSCmdlet.ParameterSetName) Enclosure configuration. WARNING: Depending on this action, there might be a brief outage."))
			{ 

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request to $($PSCmdlet.ParameterSetName) Enclosure configuration"

				Try
				{
					
					switch ($PSCmdlet.ParameterSetName) 
					{

						"Reapply" 
						{ 

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Reapply Enclosure configuration."
							
							$_task = Send-HPOVRequest ($_enclosure.uri + "/configuration") PUT -Hostname $_enclosure.ApplianceConnection.Name
						
						}
						
						"Refresh"
						{ 

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Refreshing Enclosure data."

							$body = [PSCustomObject]@{ refreshState = "Refreshing" }

							$_task = Send-HPOVRequest ($_enclosure.uri + "/refreshState" ) PUT $body -Hostname $_enclosure.ApplianceConnection.Name
						
						}
                
					}

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

				if ($PSBoundParameters['Monitor'])
				{
					
					 $_task = Wait-HPOVTaskComplete $_task -ApplianceConnection $_enclosure.ApplianceConnection.Name
				
				}

				[void]$_TaskCollection.Add($_task)
                    
            }

            elseif ($PSBoundParamters['WhatIf'])
			{
				
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User included -WhatIf."
			
			}

			else
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User cancelled."

			}           

        }

		Return $_TaskCollection

    }




}

function Get-HPOVLogicalEnclosure 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml
  
    [CmdletBinding(DefaultParameterSetName = "default")]    
    Param 
	(

        [parameter(Mandatory = $false, ParameterSetName = "default", Position = 0)]
		[validateNotNullorEmpty()]
        [string]$Name = $null,

		[parameter(Position = 1, Mandatory = $false)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

    )

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if  ($ApplianceConnection.Count -eq 0)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoAuthSessionFound InvalidArgument 'ApplianceConnection' -Message 'No ApplianceConnections were found.  Please use Connect-HPOVMgmt to establish an appliance connection.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}
		
		$c = 0
		
		ForEach ($_connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_LogicalEnclosureCollection = New-Object System.Collections.ArrayList
        
	}

    Process 
	{

		ForEach ($_connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($Connection.Name)' Appliance (of $($Appliance.Count))"

			if ($PSboundParameters['Name']) 
			{

	            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Logical Enclosure name provided: '$Name'"
	
				$Name = $Name -replace ("[*]","%25") -replace ("[&]","%26")
	
				$uri = $logicalEnclosuresUri + "?filter=name matches '$Name'&sort=name:asc"
	
	        }
	
	        else 
			{
	
	            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No Logical Enclosure name provided. Looking for all resources."
	
	            $uri = $logicalEnclosuresUri + "?sort=name:asc"
	
	        }

			Try
			{
	
				$_LogicalEnclosures = Send-HPOVRequest $uri -Hostname $_connection
	
			}
	        
			Catch
			{
	
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] API Error Caught: $($_.Exception.Message)"
	
				$PSCmdlet.ThrowTerminatingError($_)
	
			}
	
	        if ($_LogicalEnclosures.count -eq 0 -and $Name) 
			{ 
	
	            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Logical Enclosure '$Name' resource not found. Generating error"

	            $errorRecord = New-ErrorRecord HPOneView.LogicalEnclosureResourceException LogicalEnclosureNotFound ObjectNotFound 'Name' -Message "The specified Logical Enclosure '$Name' was not found on '$($_connection.Name)'.  Please check the name and try again." 
	            $pscmdlet.ThrowTerminatingError($errorRecord)  
	            
	        }
	
	        elseif ($_LogicalEnclosures.count -eq 0) 
			{ 
	
	            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No Logical Enclosure resources found on $($_connection.name)."
	
	        }
	
	        else 
			{
	
	            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Found $($_LogicalEnclosures.count) Enclosure Group resources."
	
				# // Todo Update ConvertTo-Object with LIG
				$_LogicalEnclosures.members | % { 
					
					$_.PSObject.TypeNames.Insert(0,'HPOneView.LogicalEnclosure')	
	
					[void]$_LogicalEnclosureCollection.Add($_) 
					
				}
	 
	        }

		}

	}

	End 
	{
                
		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Done. $($_LogicalEnclosureCollection.count) enclosure(s) found."
				
		#Export results to exportfile
		if ($exportFile) 
		{ 
			
			$_LogicalEnclosureCollection | convertto-json -depth 99 > $exportFile 
		
		}
		
		# else Return Logical Enclosure object(s)
		else 
		{ 

            Return $_LogicalEnclosureCollection
        
        }

	}

}

function Update-HPOVLogicalEnclosure 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding(DefaultParameterSetName = "Reapply", SupportsShouldProcess = $True, ConfirmImpact = 'High')]
    Param 
	(
        
        [parameter(Position = 0, ValueFromPipeline = $True, Mandatory = $false, HelpMessage = "Enter the Logical Enclosure Object, Name, or an Array of names.", ParameterSetName = "Update")]
        [parameter(Position = 0, ValueFromPipeline = $True, Mandatory = $false, HelpMessage = "Enter the Logical Enclosure Object, Name, or an Array of names.", ParameterSetName = "Reapply")]
        [ValidateNotNullOrEmpty()]
		[Alias('le')]
        [object]$LogicalEnclosure,

		[parameter(Position = 1, ValueFromPipelineByPropertyName, Mandatory = $false)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions},

        [parameter(Mandatory = $true, HelpMessage = "Update Logical Enclosure configuration from Enclosure Group for compliance.", ParameterSetName = "Update")]
        [Alias('UpdateFromGroup')]
        [Switch]$Update,

        [parameter(Mandatory = $true, HelpMessage = "Reapply existing configuration only.", ParameterSetName = "Reapply")]
        [Switch]$Reapply,

        [parameter(Mandatory = $false, HelpMessage = "Return created task object without waiting for completion.", ParameterSetName = "Update")]
        [parameter(Mandatory = $false, HelpMessage = "Return created task object without waiting for completion.", ParameterSetName = "Reapply")]
        [Switch]$Async

    )

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		#Support ApplianceConnection property value via pipeline from Enclosure Object
		if($PSboundParameters['ApplianceConnection'])
		{

			ForEach ($_connection in $ApplianceConnection) 
			{

				Try 
				{
			
					$ApplianceConnection[$c] = Test-HPOVAuth $_connection

				}

				Catch [HPOneview.Appliance.AuthSessionException] 
				{

					$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_connection -Message $_.Exception.Message -InnerException $_.Exception
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				Catch 
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

				$c++

			}

		}

		if (-not($PSBoundParameters['LogicalEnclosure'])) { $PipelineInput = $True }

		$_TaskCollection             = New-Object System.Collections.ArrayList
		$_LogicalEnclosureCollection = New-OBject System.Collections.ArrayList
        
	}

    Process 
	{

		if ($PipelineInput) 
		{
		
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Pipeline input."

			#error if the input value is not a PSObject
			if (-not($LogicalEnclosure -is [PSCustomObject]))
			{

				$errorRecord = New-ErrorRecord HPOneView.LogicalEnclosureResourceException InvalidLogicalEnclosureObjectType InvalidArgument 'LogicalEnclosure' -TargetType 'PSObject' -Message "The provided LogicalEnclosure value is not a valid PSObject ($($LogicalEnclosure.GetType().Name)). Please correct your input value."
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] LogicalEnclosure PSObject: $($LogicalEnclosure | FL * | out-string)."

			#Validate the Input object is the allowed category
			if ($LogicalEnclosure.category -ne 'logical-enclosures')
			{

				$errorRecord = New-ErrorRecord HPOneView.LogicalEnclosureResourceException InvalidLogicalEnclosureCategory InvalidArgument 'LogicalEnclosure' -TargetType 'PSObject' -Message "The provided LogicalEnclosure object ($($LogicalEnclosure.name)) category '$($LogicalEnclosure.category)' is not an allowed value.  Expected category value is 'logical-enclosures'. Please correct your input value."
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			if(-not($LogicalEnclosure.ApplianceConnection))
			{

				$errorRecord = New-ErrorRecord HPOneView.LogicalEnclosureResourceException InvalidLogicalEnclosureObject InvalidArgument 'LogicalEnclosure' -TargetType 'PSObject' -Message "The provided LogicalEnclosure object ($($LogicalEnclosure.name)) does not contain the required 'ApplianceConnection' object property. Please correct your input value."
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			[void]$_LogicalEnclosureCollection.Add($LogicalEnclosure)
		
		}

		#Not Pipeline input, and support Array of Logical Enclosure Name or PSObject
		else
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing LogicalEnclosure parameter."

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] LogicalEnclosure is [$($LogicalEnclosure.GetType().Name)]."

			ForEach ($_le in $LogicalEnclosure)
			{

				switch ($_le.GetType().Name)
				{

					#LE Name
					'String' 
					{
					
						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] LogicalEnclosure value: $($_le)."

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Looking for Logical Enclosure Name on connected sessions provided"

						#Loop through all Appliance Connections
						ForEach ($_connection in $ApplianceConnection)
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_connection.Name)' Session."

							Try
							{

								$_resp = Get-HPOVLogicalEnclosure $_le -ApplianceConnection $_connection.Name

							}

							Catch
							{

								$PSCmdlet.ThrowTerminatingError($_)

							}

							[void]$_LogicalEnclosureCollection.Add($_resp)

						}
					
					}

					#LE Object
					'PSCustomObject'
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] LogicalEnclosure PSObject: $($_le | FL * | out-string)."

						#Validate the Input object is the allowed category
						if ($_le.category -ne 'logical-enclosures')
						{

							$errorRecord = New-ErrorRecord HPOneView.LogicalEnclosureResourceException InvalidLogicalEnclosureCategory InvalidArgument 'LogicalEnclosure' -TargetType 'PSObject' -Message "The provided LogicalInterconnect object ($($_le.name)) category '$($_le.category)' is not an allowed value.  Expected category value is 'logical-enclosures'. Please correct your input value."
							$PSCmdlet.ThrowTerminatingError($errorRecord)

						}

						[void]$_LogicalEnclosureCollection.Add($_le)

					}

				}

			}

		}

	}

	End
	{
        #Perform the work
        ForEach ($_leObject in $_LogicalEnclosureCollection) 
		{

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Logical Enclosure: '$($_leObject.name) [$($_leObject.uri)]'"
            
            switch ($PSCmdlet.ParameterSetName) {

                "Reapply" 
				{ 

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Reapply configuration."
					
					$uri = $_leObject.uri + "/configuration" 
				
				}
                
				"Update"
				{ 

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Update from Group."
					
					$uri = $_leObject.uri + "/updateFromGroup" 
				
				}
                
            }

			if ($pscmdlet.ShouldProcess($_leObject.name,"$($PSCmdlet.ParameterSetName) Logical Enclosure configuration. WARNING: Depending on this action, there might be a brief outage."))
			{ 

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request to $($PSCmdlet.ParameterSetName) configuration"

				Try
				{

					$_task = Send-HPOVRequest $uri PUT -Hostname $_letoprocess.ApplianceConnection.Name

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

				if (-not($PSBoundParameters['Async']))
				{
					
					 $_task = Wait-HPOVTaskComplete $_task -ApplianceConnection $_letoprocess.ApplianceConnection.Name
				
				}

				[void]$_TaskCollection.Add($_task)
                    
            }

            elseif ($PSBoundParamters['WhatIf'])
			{
				
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User included -WhatIf."
			
			}

			else
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User cancelled."

			}           

        }

		Return $_TaskCollection

    }

}

function Invoke-HPOVVcmMigration 
{

	# .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding(DefaultParameterSetName = "Default", SupportsShouldProcess = $true, ConfirmImpact = "High")]
	param
	(

        [parameter(Position = 0, Mandatory = $true, ValueFromPipeline = $false, HelpMessage = "Onboard Administrator IP Address or FQDN", ParameterSetName = "Report")]	
		[parameter(Position = 0, Mandatory = $true, ValueFromPipeline = $false, HelpMessage = "Onboard Administrator IP Address or FQDN", ParameterSetName = "VCEMMigration")]
        [parameter(Position = 0, Mandatory = $true, ValueFromPipeline = $false, HelpMessage = "Onboard Administrator IP Address or FQDN", ParameterSetName = "Default")]
		[alias('oip')]
		[ValidateNotNullOrEmpty()]
		[System.String]$OAIPAddress,

        [parameter(Position = 1, Mandatory = $true, ValueFromPipeline = $false, HelpMessage = "Onboard Administrator Administrator account", ParameterSetName = "Report")]
		[parameter(Position = 1, Mandatory = $true, ValueFromPipeline = $false, HelpMessage = "Onboard Administrator Administrator account", ParameterSetName = "VCEMMigration")]
        [parameter(Position = 1, Mandatory = $true, ValueFromPipeline = $false, HelpMessage = "Onboard Administrator Administrator account", ParameterSetName = "Default")]
		[alias('ou')]
		[ValidateNotNullOrEmpty()]
		[System.String]$OAUserName,

        [parameter(Position = 2, Mandatory = $true, ValueFromPipeline = $false, HelpMessage = "Onboard Administrator Administrator password", ParameterSetName = "Report")]
		[parameter(Position = 2, Mandatory = $true, ValueFromPipeline = $false, HelpMessage = "Onboard Administrator Administrator password", ParameterSetName = "VCEMMigration")]
		[parameter(Position = 2, Mandatory = $true, ValueFromPipeline = $false, HelpMessage = "Onboard Administrator Administrator password", ParameterSetName = "Default")]
		[alias('op')]
		[ValidateNotNullOrEmpty()]
		[System.String]$OAPassword,

        [parameter(Position = 3, Mandatory = $true, ValueFromPipeline = $false, HelpMessage = "Virtual Connect Administrator account", ParameterSetName = "Report")]
		[parameter(Position = 3, Mandatory = $true, ValueFromPipeline = $false, HelpMessage = "Virtual Connect Administrator account", ParameterSetName = "VCEMMigration")]
		[parameter(Position = 3, Mandatory = $true, ValueFromPipeline = $false, HelpMessage = "Virtual Connect Administrator account", ParameterSetName = "Default")]
		[alias('vu')]
		[ValidateNotNullOrEmpty()]
		[System.String]$VCMUserName,

        [parameter(Position = 4, Mandatory = $true, ValueFromPipeline = $false, HelpMessage = "Virtual Connect Administrator password", ParameterSetName = "Report")]
		[parameter(Position = 4, Mandatory = $true, ValueFromPipeline = $false, HelpMessage = "Virtual Connect Administrator password", ParameterSetName = "VCEMMigration")]
		[parameter(Position = 4, Mandatory = $true, ValueFromPipeline = $false, HelpMessage = "Virtual Connect Administrator password", ParameterSetName = "Default")]
		[alias('vp')]
		[ValidateNotNullOrEmpty()]
		[System.String]$VCMPassword,

		[parameter(Position = 5, Mandatory = $false, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, HelpMessage = "Enclosure Group Resource Name, URI or Object", ParameterSetName = "Report")]
        [parameter(Position = 5, Mandatory = $false, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, HelpMessage = "Enclosure Group Resource Name, URI or Object", ParameterSetName = "VCEMMigration")]
        [parameter(Position = 5, Mandatory = $false, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, HelpMessage = "Enclosure Group Resource Name, URI or Object", ParameterSetName = "Default")]
		[alias('eg')]
        [ValidateScript({
            if (($_ -is [String]) -and ($_.StartsWith('/rest/')) -and (-not ($_.StartsWith('/rest/enclosure-groups')))) { Throw "'$_' is not an allowed resource URI.  Enclosure Group Resource URI must start with '/rest/enclosure-groups'. Please check the value and try again." } 
            elseif ($_ -is [String] -and ($_.StartsWith('/rest/'))) { $True }
            elseif ($_ -is [String]) { $True }
            
            elseif (($_ -is [PSCustomObject]) -and (-not ($_.category -eq "enclosure-groups"))) { 
            
                if ($_.category) { Throw "'$_.category' is not an allowed resource category.  The resource object category must be 'enclosure-groups'. Please check the value and try again." }
                else { Throw "The object provided does not contain an the allowed resource category 'enclosure-groups'. Please check the value and try again." }
            }
            else { $True } })]
		[Object]$EnclosureGroup = $Null,

		[parameter(Position = 6, Mandatory = $false, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, HelpMessage = "Logical Interconnect Group Resource Name, URI or Object", ParameterSetName = "Report")]
        [parameter(Position = 6, Mandatory = $false, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, HelpMessage = "Logical Interconnect Group Resource Name, URI or Object", ParameterSetName = "VCEMMigration")]
        [parameter(Position = 6, Mandatory = $false, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, HelpMessage = "Logical Interconnect Group Resource Name, URI or Object", ParameterSetName = "Default")]
		[alias('lig')]
        [ValidateScript({
            if (($_ -is [String]) -and ($_.StartsWith('/rest/')) -and (-not ($_.StartsWith('/rest/logical-interconnect-groups')))) { Throw "'$_' is not an allowed resource URI.  Logical Interconnect Group Resource URI must start with '/rest/logical-interconnect-groups'. Please check the value and try again." } 
            elseif ($_ -is [String] -and ($_.StartsWith('/rest/'))) { $True }
            elseif ($_ -is [String]) { $True }
            
            elseif (($_ -is [PSCustomObject]) -and (-not ($_.category -eq "logical-interconnect-groups"))) { 
            
                if ($_.category) { Throw "'$_.category' is not an allowed resource category.  The resource object category must be 'logical-interconnect-groups'. Please check the value and try again." }
                else { Throw "The object provided does not contain an the allowed resource category 'logical-interconnect-groups'. Please check the value and try again." }
            }
            else { $True } })]
		[Object]$LogicalInterconnectGroup = $Null,

		[parameter(Position = 7, Mandatory = $true, ValueFromPipeline = $false, HelpMessage = "Enclosure License Intent; OneView or OneViewNoIlo", ParameterSetName = "Report")]
        [parameter(Position = 7, Mandatory = $true, ValueFromPipeline = $false, HelpMessage = "Enclosure License Intent; OneView or OneViewNoIlo", ParameterSetName = "VCEMMigration")]
        [parameter(Position = 7, Mandatory = $true, ValueFromPipeline = $false, HelpMessage = "Enclosure License Intent; OneView or OneViewNoIlo", ParameterSetName = "Default")]
		[ValidateSet("OneView", "OneViewNoiLO", IgnoreCase = $false)]
		[ValidateNotNullOrEmpty()]
        [Alias("license", "l")]
	    [System.String]$licensingIntent,

        [parameter(Position = 8, Mandatory = $true, ValueFromPipeline = $false, HelpMessage = "Virtual Connect Enterprise Manager CMS IP Address or FQDN", ParameterSetName = "Report")]
        [parameter(Position = 8, Mandatory = $true, ValueFromPipeline = $false, HelpMessage = "Virtual Connect Enterprise Manager CMS IP Address or FQDN", ParameterSetName = "VCEMMigration")]
		[String]$VCEMCMS,

        [parameter(Position = 9, Mandatory = $true, ValueFromPipeline = $false, HelpMessage = "Virtual Connect Enterprise Manager Administrator account", ParameterSetName = "Report")]
        [parameter(Position = 9, Mandatory = $true, ValueFromPipeline = $false, HelpMessage = "Virtual Connect Enterprise Manager Administrator account", ParameterSetName = "VCEMMigration")]
		[String]$VCEMUser,

        [parameter(Position = 10, Mandatory = $true, ValueFromPipeline = $false, HelpMessage = "Virtual Connect Enterprise Manager Administrator Password", ParameterSetName = "Report")]
        [parameter(Position = 10, Mandatory = $true, ValueFromPipeline = $false, HelpMessage = "Virtual Connect Enterprise Manager Administrator Password", ParameterSetName = "VCEMMigration")]
		[String]$VCEMPassword,

		[parameter(Mandatory = $false, HelpMessage = "Do not wait for task to complete", ParameterSetName = "Default")]
		[Switch]$NoWait,

		[parameter(Mandatory = $true, HelpMessage = "Generate report only", ParameterSetName = "Report")]
		[Switch]$Report,

		[parameter(Mandatory = $false, HelpMessage = "Save Report Only", ParameterSetName = "Report")]
        [ValidateScript({
            if ({split-path $_ | Test-Path}) { $True } 
            else { Throw "'$(Split-Path $_)' is not a valid directory.  Please verify $(Split-Path $_) exists and try again." } 
            })]
		[System.String]$Export,

        [parameter(Mandatory = $true)]
		[Alias('Appliance')]
		[object]$ApplianceConnection
		
	)
	
	Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if (-not($ApplianceConnection -is [HPOneView.Appliance.Connection]) -and (-not($ApplianceConnection -is [System.String])))
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException InvalidApplianceConnectionDataType InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter is not type [HPOneView.Appliance.Connection] or [System.String].  Please correct this value and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif  ($ApplianceConnection.Count -gt 1)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException MultipleApplianceConnections InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter contains multiple Appliance Connections.  This CMDLET only supports 1 Appliance Connection in the ApplianceConnect parameter value.  Please correct this and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		else
		{

			Try 
			{
	
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError 'ApplianceConnection' -TargetType $ApplianceConnection.GetType().Name -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_.Exception)

			}

		}

    }
	
	Process 
	{

        $vcMigrationObject = NewObject -vcMigration

        #Check to see if EnclosureGroup was provided
        if ($PSBoundParameters['EnclosureGroup']) 
		{
        
            switch ($EnclosureGroup.Gettype().Name) 
			{

                #Validate the String value
                "String" 
				{ 
                
                    #The value is an Enclosure Group URI
                    if ($EnclosureGroup.startswith('/rest/enclosure-groups')) 
					{

                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(get-date -UFormat `"%Y-%m-%d %T`") Enclosure Group URI provided: $EnclosureGroup"
                       
						$vcMigrationObject.enclosureGroupUri = $EnclosureGroup

                    }

                    #The value is an enclosure group name
                    else 
					{
                        
                        #Enclosure group name provided.  Check if this is for a custom EG and LIG (LIG name also provided), or existing EG
                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(get-date -UFormat `"%Y-%m-%d %T`") Enclosure Group Name provided: $EnclosureGroup"

                        try 
						{ 
                            
                            $eg = (Get-HPOVEnclosureGroup $EnclosureGroup -appliance $ApplianceConnection).uri 
                                
                            #Add the URI property to the migration object
                            $vcMigrationObject.enclosureGroupUri = $eg
                                
                        }

                        catch 
						{

                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(get-date -UFormat `"%Y-%m-%d %T`") Enclosure Group '$EnclosureGroup' not found. Specifying custom Enclosure Group Name."
                            $vcMigrationObject | Add-Member -NotePropertyName "enclosureGroupName" -NotePropertyValue $EnclosureGroup -force

                        }

                    }
                    
                }
                "PSCustomObject" 
				{
            
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(get-date -UFormat `"%Y-%m-%d %T`") Enclosure Group resource object provided: $($EnclosureGroup | fl | out-string)"
                    $vcMigrationObject.enclosureGroupUri = $EnclosureGroup.uri
            
                }

            }#SWITCH

        }#If EG provided

		#Check to see if LogicalInterconnectGroup was provided
		if ($PSBoundParameters['LogicalInterconnectGroup']) {
        
            switch ($LogicalInterconnectGroup.Gettype().Name) {

                #Validate the String value
                "String" { 
                
                    #The value is an Enclosure Group URI
                    if ($LogicalInterconnectGroup.startswith('/rest/logical-interconnect-groups')) {

                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(get-date -UFormat `"%Y-%m-%d %T`") Logical Interconnect Group URI provided: $LogicalInterconnectGroup"
                        $vcMigrationObject.logicalInterconnectGroupUri = $LogicalInterconnectGroup

                    }

                    #The value is an enclosure group name
                    else {
                        
                        #Enclosure group name provided.  Check if this is for a custom EG and LIG (LIG name also provided), or existing EG
                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(get-date -UFormat `"%Y-%m-%d %T`") Logical Interconnect Group Name provided: $LogicalInterconnectGroup"

                        try { 
                            
                            $lig = (Get-HPOVEnclosureGroup $LogicalInterconnectGroup -appliance $ApplianceConnection).uri 
                                
                            #Add the URI property to the migration object
                            $vcMigrationObject.logicalInterconnectGroupUri = $lig
                                
                        }

                        catch {

                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(get-date -UFormat `"%Y-%m-%d %T`") Logical Interconnect Group '$LogicalInterconnectGroup' not found. Specifying custom Logical Interconnect Group Name."
                            $vcMigrationObject | Add-Member -NotePropertyName logicalInterconnectGroupName -NotePropertyValue $LogicalInterconnectGroup -force

                        }

                    }
                    
                }
                "PSCustomObject" {
            
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(get-date -UFormat `"%Y-%m-%d %T`") Logical Interconnect Group resource object provided: $($LogicalInterconnectGroup | fl | out-string)"
                    $vcMigrationObject.logicalInterconnectGroupUri  = $LogicalInterconnectGroup.uri
            
                }

            }#SWITCH

        }#If EG provided

        #Send the POST and retrieve the Uri for the MigratableVcDomain resource
        $thisTask = Send-HPOVRequest -method POST -uri "/rest/migratable-vc-domains" -body $vcMigrationObject  -appliance $ApplianceConnection | Wait-HPOVTaskComplete
        
        if ($thisTask.taskState -ieq "Error") {

            $errorRecord = New-ErrorRecord HPOneView.EnclosureResourceException $thisTask.taskErrors.errorCode InvalidArgument 'Invoke-HPOVVcMigration' -Message "$($thisTask.taskErrors.message)"
            $PsCmdlet.ThrowTerminatingError($errorRecord)

        }

        #If we get here, task was successful. Get the migration resource
        $vcMigrationReport = MigrationReport $thisTask

		$EnclosureName = $vcMigrationReport.apiVcMigrationReport.enclosureName

        if ($Export) {

            [Array]$Output = @()

			$Output += $vcMigrationReport.apiVcMigrationReport | ft $a -AutoSize -wrap
			$Output += $vcMigrationReport.apiVcMigrationReport| ft $b -AutoSize -wrap
			$Output += $vcMigrationReport.outReport | sort severity | fl $i

            $outFile = "$export\$($vcMigrationReport.apiVcMigrationReport.enclosureName)_$(get-date -uformat %Y%m%d).report"

            $vcMigrationReport.outReport += "Generated on $(get-date -uformat %c)"

            Out-File -InputObject  $Output -FilePath $outFile -Encoding utf8 -force -confirm:$false

            write-host "Report saved to: " -nonewline -ForegroundColor Green
            write-host "$outFile" -ForegroundColor Yellow

        }
        else {

			#Generate and return the report
			""
			"Migration Compatibility Report"
			"------------------------------"
			""
			$vcMigrationReport.apiVcMigrationReport | ft $a -AutoSize -wrap
			$vcMigrationReport.apiVcMigrationReport| ft $b -AutoSize -wrap
			$vcMigrationReport.outReport | sort severity | fl $i

        }

        #Generate terminating error if caller didn't include VCEMCMS parameter and $vcMigrationReport.VcemManaged is True
        if (-not ($PSBoundParameters["vcemcms"]) -and $vcMigrationReport.VcemManaged) {

            $ErrorRecord = New-ErrorRecord HPOneview.VCMigratorException VCEMCMSParameterMissing InvalidArgument 'VCEMCMS' -Message "The Enclosure is currently managed by a Virtual Connect Enterprise Manager (VCEM) CMS, and the -VCEMCMS parameter was not provided.  Please provide the required parameter and try again."
            $PSCmdlet.ThrowTerminatingError($ErrorRecord)
                            
        }

        if ($VCEMCMS -and $vcMigrationReport.VcemManaged -and ($vcMigrationReport.apiVcMigrationReport.criticalCount -le 1) -and (-not ($Report.IsPresent))) {

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(get-date -UFormat `"%Y-%m-%d %T`") Entering Eject VCM from VCEM DG process"
       
            $oaUrl = "https://$OAIPAddress/xmldata?item=all"

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(get-date -UFormat `"%Y-%m-%d %T`") Building SOAP Request to OA: $oaUrl” 

            try {

                $soapWebRequest = [System.Net.WebRequest]::Create($oaUrl) 
                $soapWebRequest.Accept = “text/xml” 
                $soapWebRequest.Method = “GET” 
                $resp = $soapWebRequest.GetResponse() 
                $responseStream = $resp.GetResponseStream() 
                $soapReader = [System.IO.StreamReader]($responseStream) 
                $ReturnXml = [Xml] $soapReader.ReadToEnd() 
                $responseStream.Close() 
                $resp.Close()
                $soapWebRequest = $Null
                
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(get-date -UFormat `"%Y-%m-%d %T`") Response received: $($returnXML.OuterXml | Out-String)"
    
            }

            catch [Net.WebException]{

                if ($_.exception.InnerException -match "The remote name could not be resolved") {

                    $ErrorRecord = New-ErrorRecord HPOneview.VCMigratorException OnboardAdministratorUnavailable ResourceUnavailable 'OAIP' -Message "$($_.exception.InnerException)"
                    $PSCmdlet.ThrowTerminatingError($ErrorRecord)

                }

                else {

                    $ErrorRecord = New-ErrorRecord HPOneview.VCMigratorException $_.FullyQualifiedErrorId ResourceUnavailable 'OAIP' -Message "$($_.exception.message)"
                    $PSCmdlet.ThrowTerminatingError($ErrorRecord)
                }

            }

            catch {

                $ErrorRecord = New-ErrorRecord HPOneview.VCMigratorException $_.FullyQualifiedErrorId ResourceUnavailable 'OAIP' -Message "$($_.exception.message)"
                $PSCmdlet.ThrowTerminatingError($ErrorRecord)

            }

            #Recieved valid OA XML reply
            if ($ReturnXml.RIMP.INFRA2) { 
    
                if ($ReturnXml.RIMP.INFRA2.VCM.vcmMode -eq "true") {
            
                    $vcDomainName = $ReturnXml.RIMP.INFRA2.VCM.vcmDomainName
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(get-date -UFormat `"%Y-%m-%d %T`") Found VC Domain from OA:  '$vcDomainName'"
                            
                }
                else {

                    $ErrorRecord = New-ErrorRecord HPOneview.VCMigratorException NoVCDomainFound ResourceUnavailable 'OAIP' -Message "Enclosure is not managed by VCM or no valid VC Domain Found."
                    $PSCmdlet.ThrowTerminatingError($ErrorRecord)

                }
    
            }
    
            #Reply will not have any returned data beyond the RIMP XML node, so generate error
            else {

                $ErrorRecord = New-ErrorRecord HPOneview.VCMigratorException NoVCDomainFound ResourceUnavailable 'OAIP' -Message "No data provided from XML Interface. Is it disabled?"
                $PSCmdlet.ThrowTerminatingError($ErrorRecord)

            }

            #VCEM CodeBlock
            #Use the mvcd7_3 API Endpoint
            $XmlAuth = @"
        <soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:v7="http://v7_3.api.mvcd.hp.com">
           <soapenv:Header/>
           <soapenv:Body>
              <v7:login>
                 <String_1>$VCEMUser</String_1>
                 <String_2>$VCEMPassword</String_2>
              </v7:login>
           </soapenv:Body>
        </soapenv:Envelope>
"@

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(get-date -UFormat `"%Y-%m-%d %T`") $(get-date -UFormat `"%Y-%m-%d %T`") Authenticating to VCEM CMS host: $VCEMCMS."

            try {

                $Uri = "https://$($VCEMCMS):50000/mvcd7_3/SoapApi"
                $reply = Invoke-WebRequest -uri $Uri -Method POST -ContentType "text/xml" -Body $XmlAuth

            }
            catch [System.Net.WebException] {

				if ($_.exception -match "The remote name could not be resolved") {
				
					$ErrorRecord = New-ErrorRecord HPOneview.VCMigratorException VcemHostUnavailable ResourceUnavailable 'VCEMCMS' -Message "The VCEM host '$VCEMCMS' remote name could not be resolved. Please check the name and try again."
                    $PSCmdlet.ThrowTerminatingError($ErrorRecord)	

				}
				
				else { 

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(get-date -UFormat `"%Y-%m-%d %T`") [System.Net.WebException] Error Caught: $($_.Exception.Response | out-string)"

					$ResponseCode = [int]$_.Exception.response.statuscode
					$ResponseMessage = $_.Exception.Message

					#Get exception response from Web Service API.
					if ($_.Exception.InnerException) { $HttpWebResponse = $_.Exception.InnerException.Response }
					else { $HttpWebResponse = $_.Exception.Response }

					$rs = $HttpWebResponse.GetResponseStream()
					$reader = New-Object System.IO.StreamReader($rs)
					
					if ($HttpWebResponse.ContentType.Contains("text/xml")) { [XML]$ErrorBodyResponse = $reader.ReadToEnd() }
					else { $ErrorBodyResponse = $reader.ReadToEnd() }

					switch ([int]$ResponseCode) {
					
					    404 {  

					        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(get-date -UFormat `"%Y-%m-%d %T`") [System.Net.WebException] SOAP API Endpoint not found"
					
					        $ErrorRecord = New-ErrorRecord HPOneview.VCMigratorException VCEMSoapAPIEndPointNotFound ResourceUnavailable 'VCEMCMS' -Message "The provided VCEM CMS host '$VCEMCMS' does not have the VCEM role of HP Insight Software installed.  Please verify the VCEMCMS parameter value and try again."
					        $PSCmdlet.ThrowTerminatingError($ErrorRecord)
					
					    }

					    default {

					        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(get-date -UFormat `"%Y-%m-%d %T`") [System.Net.WebException] Internal Server Error or auth exception"
					        
					        if ($ErrorBodyResponse -is [XML]) {

					            $ResponseMessage = $ErrorBodyResponse.Envelope.body.Fault.faultstring

					            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(get-date -UFormat `"%Y-%m-%d %T`") Received XML Response FaultString:  $ResponseMessage"
					        
					        }              
					        
					        $ErrorRecord = New-ErrorRecord HPOneview.VCMigratorException VCEMSoapApiInternalError InvalidResult 'VCEMCMS' -Message "HTTP '$ResponseCode' Error. $ResponseMessage"
					        $PSCmdlet.ThrowTerminatingError($ErrorRecord)

					    }

					}

				}

            }

            [XML]$ContentResponse = $reply.content
            $AuthToken = $ContentResponse.Envelope.Body.loginResponse.result

            #Check for new VCEM API Endpoint
            $getVcemApiVersion = @"
            <soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:v7="http://v7_3.api.mvcd.hp.com">
               <soapenv:Header/>
               <soapenv:Body>
                  <v7:getProductVersion>
                     <String_1>$AuthToken</String_1>
                  </v7:getProductVersion>
               </soapenv:Body>
            </soapenv:Envelope>
"@

            $Uri = "https://$($VCEMCMS):50000/mvcd7_3/SoapApi"
            $reply = Invoke-WebRequest -uri $Uri -Method POST -ContentType "text/xml" -Body $getVcemApiVersion
            
            [XML]$ContentResponse = $reply.content
            
            [version]$apiVersion = ($ContentResponse.Envelope.Body.getProductVersionResponse.result) -replace ("Virtual Connect Enterprise Manager v","")
			$apiVersionString = ($ContentResponse.Envelope.Body.getProductVersionResponse.result) -replace ("Virtual Connect Enterprise Manager v","") -replace ("\.","_")

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(get-date -UFormat `"%Y-%m-%d %T`") VCEM API Version found: $apiVersion"


            if ($apiVersion -lt 7.3) {

                #Generate error that VCEM version is too old to support patch and instruct caller to upgrade to either 7.3+Patch or 7.4.1
                $ErrorRecord = New-ErrorRecord HPOneview.VCMigratorException VcemVersionTooOld ResourceUnavailable 'VCEMCMS' -Message "The VCEM host '$VCEMCMS' version '$($apiVersion.ToString())' is not supported. Please upgrade your VCEM CMS to at least 7.3 and obtain the VCEM 7.3/7.4 Patch (ftp://ftp.hp.com/pub/softlib2/software1/pubsw-generic/p270829882/v106568) and try again."
                $PSCmdlet.ThrowTerminatingError($ErrorRecord)

            }

            #Locate VCM Domain within VCEM
            $FindVCDomainByNameRequest = @"
        <s11:Envelope xmlns:s11='http://schemas.xmlsoap.org/soap/envelope/'>
          <s11:Body>
            <ns1:findVCDomainByName xmlns:ns1='http://v7_3.api.mvcd.hp.com'>
              <String_1>$AuthToken</String_1>
              <String_2>$vcDomainName</String_2>
            </ns1:findVCDomainByName>
          </s11:Body>
        </s11:Envelope>
"@

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(get-date -UFormat `"%Y-%m-%d %T`") Looking for '$vcDomainName' VC Domain on VCEM host."

            $reply = Invoke-WebRequest -uri $Uri -Method POST -ContentType "text/xml" -Body $FindVCDomainByNameRequest

            [xml]$findVCDomainByNameResponse = $reply.content

            if ($findVCDomainByNameResponse.Envelope.body.findVCDomainByNameResponse.result.nil) {

                $ErrorRecord = New-ErrorRecord HPOneview.VCMigratorException NoVCDomainFound ResourceUnavailable 'OAIP' -Message "No data provided from XML Interface. Is it disabled?"
                $PSCmdlet.ThrowTerminatingError($ErrorRecord)

            }

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(get-date -UFormat `"%Y-%m-%d %T`") Found VC Domain: $($findVCDomainByNameResponse.Envelope.body.findVCDomainByNameResponse.result | out-string)"

            if ($findVCDomainByNameResponse.Envelope.body.findVCDomainByNameResponse.result.status -eq "LICENSED_UNMANAGED") {

                Write-Warning "'$vcDomainName' is not currently managed by the VCEM CMS host."
                Return

            }

            $vcemDomainId = $findVCDomainByNameResponse.Envelope.body.findVCDomainByNameResponse.result.vcDomainId

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(get-date -UFormat `"%Y-%m-%d %T`") Attempting to remove VC Domain from VCEM Domain Group"

            if ($pscmdlet.ShouldProcess("$vcDomainName","Remove VC Domain From VC Domain Group")) {

                if ($apiVersion -ge "7.4.1") { 
                
                    $uri = "https://$($VCEMCMS):50000/mvcd$($apiVersionString)/SoapApi" 
                    $nameSpaceVer = "v$($apiVersionString)"
                }
                else { 
                
                    $uri = "https://$($VCEMCMS):50000/mvcdExtra/SoapApi" 
                    $nameSpaceVer = "vExtra"
                        
                }

                $removeVcDomainRequest = @"
<s11:Envelope xmlns:s11='http://schemas.xmlsoap.org/soap/envelope/'>
    <s11:Body>
    <ns1:removeVcDomainFromGroup xmlns:ns1='http://$nameSpaceVer.api.mvcd.hp.com'>
        <String_1>$AuthToken</String_1>
        <Long_2>$vcemDomainId</Long_2>
    </ns1:removeVcDomainFromGroup>
    </s11:Body>
</s11:Envelope>
"@

                #Attempt removeVcDomainFromGroup request to API
                try {

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(get-date -UFormat `"%Y-%m-%d %T`") Attempting SOAP Call to '$uri'"

                    $soapWebRequest = [System.Net.HttpWebRequest]::Create($uri) 
                    $soapWebRequest.Accept = “text/xml” 
                    $soapWebRequest.ContentType = “text/xml”
                    $soapWebRequest.Method = “POST” 
                    $bytes = [System.Text.Encoding]::UTF8.GetBytes($removeVcDomainRequest) 
                    $soapWebRequest.ContentLength = $bytes.Length

                    [System.IO.Stream] $outputStream = [System.IO.Stream]$soapWebRequest.GetRequestStream()
                    $outputStream.Write($bytes,0,$bytes.Length)  
                    $outputStream.Close()

                    $resp = $soapWebRequest.GetResponse() 
                    $responseStream = $resp.GetResponseStream() 
                    $soapReader = [System.IO.StreamReader]($responseStream) 
                    $reply = [Xml]$soapReader.ReadToEnd() 
                    $responseStream.Close() 
                    $resp.Close()
                    $soapWebRequest = $Null
                
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(get-date -UFormat `"%Y-%m-%d %T`") Response received: $($reply.OuterXml)"
    
                }

                Catch [System.Net.WebException] {

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(get-date -UFormat `"%Y-%m-%d %T`") [System.Net.WebException] exception caught: $($_.Exception.Response | out-string)"

                    $HttpWebResponse = $_.Exception.Response
                    $ResponseCode = [int]$_.Exception.response.statuscode
                    $ResponseMessage = $_.Exception.Message

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(get-date -UFormat `"%Y-%m-%d %T`") Getting error response stream."
                    
                    $rs = $HttpWebResponse.GetResponseStream()
                    $reader = New-Object System.IO.StreamReader($rs)

                    if ($HttpWebResponse.ContentType.Contains("text/xml")) { [XML]$ErrorBodyResponse = $reader.ReadToEnd() }

                    else { [String]$ErrorBodyResponse = $reader.ReadToEnd() }

                    if ($ErrorBodyResponse -is [String] -and $ErrorBodyResponse.StartsWith("<script>") -and [int]$ResponseCode -eq 404) { 
                    
                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(get-date -UFormat `"%Y-%m-%d %T`") [System.Net.WebException] SOAP API Endpoint not found.  Generating terminating error."
                
                        $ErrorRecord = New-ErrorRecord HPOneview.VCMigratorException VCEMSoapAPIEndPointNotFound ResourceUnavailable 'VCEMCMS' -Message "The provided VCEM CMS host '$VCEMCMS' does not have the required VCEM patch installed.  Please download the patch from (ftp://ftp.hp.com/pub/softlib2/software1/pubsw-generic/p270829882/v106568) and try again."
                        $PSCmdlet.ThrowTerminatingError($ErrorRecord)

                    }
                    elseif ($ErrorBodyResponse -is [XML] -and [int]$HttpWebResponse.StatusCode -eq 500 -and $ErrorBodyResponse.Envelope.Body.Fault.faultstring -match "Failed to parse source: For input string: `"$vcemDomainId`"") {

                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(get-date -UFormat `"%Y-%m-%d %T`") '$vcDomainName' was not found on the VCEM host '$VCEMCMS'.  Generating terminating error."

                        $ErrorRecord = New-ErrorRecord HPOneview.VCMigratorException VcDomainNotFound ResourceUnavailable 'VCEMCMS' -Message "The Virtual Connect Domain '$vcDomainName' not found on VCEM host '$VCEMCMS'.  Please verify the Virtual Connect Domain is managed by the provided VCEM CMS host and try again."
                        $PSCmdlet.ThrowTerminatingError($ErrorRecord)

                    }
                    elseif ($ErrorBodyResponse -is [XML]) {

                        $ErrorRecord = New-ErrorRecord HPOneview.VCMigratorException $ErrorBodyResponse.Envelope.Body.Fault.faultcode InvalidResult 'VCEMCMS' -Message "$($ErrorBodyResponse.Envelope.Body.Fault.faultstring)"
                        $PSCmdlet.ThrowTerminatingError($ErrorRecord)
                    
                    }
                    else {

                        $ErrorRecord = New-ErrorRecord HPOneview.VCMigratorException VCEMApiCallGenericError InvalidResult 'VCEMCMS' -Message "HTTP '$ResponseCode ' Error. Message: $ResponseMessage"
                        $PSCmdlet.ThrowTerminatingError($ErrorRecord)
                    
                    }

                }

                $jobId = $reply.Envelope.body.removeVcDomainFromGroupResponse.result

                if (-not ($jobId)){

                    $ErrorRecord = New-ErrorRecord HPOneview.VCMigratorException InvalidJobIdResult InvalidResult 'VCEMCMS' -Message "A valid VCEM Job ID was not provided."
                    $PSCmdlet.ThrowTerminatingError($ErrorRecord)
                    
                }

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(get-date -UFormat `"%Y-%m-%d %T`") Monitoring VCEM Job ID '$jobId'"

				$Uri = "https://$($VCEMCMS):50000/mvcd7_3/SoapApi"

                $jobMonitorRequest = @"
        <s11:Envelope xmlns:s11='http://schemas.xmlsoap.org/soap/envelope/'>
          <s11:Body>
            <ns1:listStatusForMvcdJob xmlns:ns1='http://v7_3.api.mvcd.hp.com'>
              <String_1>$AuthToken</String_1>
              <Long_2>$jobId</Long_2>
            </ns1:listStatusForMvcdJob>
          </s11:Body>
        </s11:Envelope>
"@

                do {

                    #Hide the progress display of Invoke-WebRequest, which adds unecessary tet to the Write-Progress output
                    $progressPreference = 'silentlyContinue' 
                    $reply = Invoke-WebRequest -uri $Uri -Method POST -ContentType "text/xml" -Body $jobMonitorRequest

                    #Reset hidding progress display prior to executing Write-Progress
                    $progressPreference = 'Continue'  

                    [xml]$jobStatus = $reply.Content

                    Write-Verbose $($jobStatus.Envelope.body.listStatusForMvcdJobResponse.result | out-string)
                    Write-Verbose $($jobStatus.Envelope.body.listStatusForMvcdJobResponse.result.jobProgress[-1] | out-string)

                    if ($jobStatus.Envelope.body.listStatusForMvcdJobResponse.result.jobProgress[-1].progressDescription) { $status = $jobStatus.Envelope.body.listStatusForMvcdJobResponse.result.jobProgress[-1].progressDescription}
                    else { $status = "Waiting" }

                    if ($jobStatus.Envelope.body.listStatusForMvcdJobResponse.result.jobProgress[-1].percentComplete) { $PrecentComplete = $jobStatus.Envelope.body.listStatusForMvcdJobResponse.result.jobProgress[-1].percentComplete}
                    else { $PrecentComplete = 0 }

                    Write-Progress -id 2 -Activity $jobStatus.Envelope.body.listStatusForMvcdJobResponse.result.jobName -Status $status -PercentComplete $PrecentComplete

                } Until ($jobStatus.Envelope.body.listStatusForMvcdJobResponse.result.state -eq "COMPLETED" -or $jobStatus.Envelope.body.listStatusForMvcdJobResponse.result -eq "FAILED")
    
                #Job Failed, terminate
                if ($jobStatus.Envelope.body.listStatusForMvcdJobResponse.result -eq "FAILED") {
                
                    $errorRecord = New-ErrorRecord HPOneView.VCMigratorException $thisTask.taskErrors.errorCode InvalidArgument 'Invoke-HPOVVcMigration' -Message "$($thisTask.taskErrors.message)"
                    $PsCmdlet.ThrowTerminatingError($errorRecord)
                
                }           
                
                Write-Progress -id 2 -Activity $jobStatus.Envelope.body.listStatusForMvcdJobResponse.result.jobName -Completed

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(get-date -UFormat `"%Y-%m-%d %T`") Checking Compatibility again."

                #Check for report status now
                $thisTask = Send-HPOVRequest -method POST -uri "/rest/migratable-vc-domains" -body $vcMigrationObject  -appliance $ApplianceConnection | Wait-HPOVTaskComplete

                if ($thisTask.taskState -ieq "Error") {

                    $errorRecord = New-ErrorRecord HPOneView.VCMigratorException $thisTask.taskErrors.errorCode InvalidResult 'Invoke-HPOVVcMigration' -Message "$($thisTask.taskErrors.message)"
                    $PsCmdlet.ThrowTerminatingError($errorRecord)

                }

                #If we get here, task was successful. Generate new VCMMigrator report
                #$vcMigrationReport = Send-HPOVRequest $thisTask.associatedResource.resourceUri
                $vcMigrationReport = MigrationReport $thisTask

                if ($vcMigrationReport.apiVcMigrationReport.migrationState -eq "UnableToMigrate") {

                    $errorRecord = New-ErrorRecord HPOneView.VCMigratorException UnableToMigrateVCDomain InvalidResult 'Invoke-HPOVVcMigration' -Message "The VC Domain in unable to be migrated due to $($vcMigrationReport.apiVcMigrationReport.highCount) Critical Issues.  Please examine the VC Migration Report to identify what needs to be resolved before migration can continue."
                    $PsCmdlet.ThrowTerminatingError($errorRecord)

                }

				#Generate and return the report
				""
				"Migration Compatibility Report"
				"------------------------------"
				""
				$vcMigrationReport.apiVcMigrationReport | ft $a -AutoSize -wrap
				$vcMigrationReport.apiVcMigrationReport| ft $b -AutoSize -wrap
				$vcMigrationReport.outReport | sort severity | fl $i

            }

            Else {

                if ($PSBoundParameters['whatif'].ispresent) { 
                            
                    write-warning "-WhatIf was passed, would have proceeded with removing '$vcDomainName' from VCEM Domain Group."
                    $resp = $null
            
                }
                else {

	                #If here, user chose "No", end processing
                    write-host ""
	                write-warning "Not removing '$vcDomainName'from VCEM Domain Group and unable to proceed without removing the VC Domain from the VCEM Domain Group."
                    write-host ""
                    
                    $resp = $Null

                }

            }

        }

		#We are ready to migrate
        if ($vcMigrationReport.migrationState -eq "ReadyToMigrate" -and -not ($report.IsPresent)) {
            
            if ($pscmdlet.ShouldProcess("enclosure $EnclosureName at $($vcMigrationReport.apiVcMigrationReport.enclosureIp)","Process migration")) {
                
                #Make the PUT call to migrate
                $migrateTask = Send-HPOVRequest -method PUT -uri $vcMigrationReport.apiVcMigrationReport.uri -body @{migrationState = "Migrated"; type = "migratable-vc-domains"}  -appliance $ApplianceConnection

                if ($NoWait) {

                    $resp = $migrateTask

                }
                else {
                    
                    $resp = $migrateTask | Wait-HPOVTaskComplete -timeout (New-TimeSpan -Minutes 60)

                }

            }
            else {

                if ($PSBoundParameters['whatif'].ispresent) { 
                            
                    write-warning "-WhatIf was passed, would have proceeded with migration of $($vcMigrationReport.apiVcMigrationReport.enclosureName)."
                    $resp = $null
            
                }
                else {

	                #If here, user chose "No", end processing
                    write-host ""
	                write-warning "Not migrating enclosure, $($vcMigrationReport.apiVcMigrationReport.enclosureName)."
                    write-host ""
                    
                    $resp = $Null

                }

            }

        }#End if ReadyToMigrate

		#Handle error conditions that need to be resolved by the caller before migration can be performed.
		elseif ($vcMigrationReport.migrationState -eq "UnableToMigrate" -and $vcMigrationReport.apiVcMigrationReport.criticalCount -ge 1) {
		
			$errorRecord = New-ErrorRecord HPOneView.VCMigratorException UnableToMigrateEnclosure InvalidResult 'Invoke-HPOVVcMigration' -Message "There are 1 or more critical issues preventing the enclosure from being eligible to migrate.  Please run a compatibility report using the -report switch, then review and resolve the reported issues before continuing."
            $PsCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif ($vcMigrationReport.migrationState -eq "Migrated") {
		
			$errorRecord = New-ErrorRecord HPOneView.VCMigratorException EnclosureMigrated OperationStopped 'OAIP' -Message "The enclosure '$EnclosureName' was already migrated.  Not performing action again."
			$PsCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif ($vcMigrationReport.migrationState -eq "Migrating") {
		
			$errorRecord = New-ErrorRecord HPOneView.VCMigratorException MigratingEnclosure InvalidOperation 'OAIP' -Message "An asynchronOut task migrating enclosure '$EnclosureName' exists and is currently still running."
			$PsCmdlet.ThrowTerminatingError($errorRecord)

		}
           
	}#End process
	
	End {
	     
	    $resp
	}

}

function MigrationReport ($task){

    $vcMigrationReport = [PSCustomObject]@{

        apiVcMigrationReport = @{};
        issueCount           = [int]$null;
        migrationState       = [String]$Null;
        VcemManaged          = [Bool]$False;
        outReport            = [Array]@()

    }

    $vcMigrationReport.apiVcMigrationReport = Send-HPOVRequest $task.associatedResource.resourceUri

    $vcMigrationReport.migrationState = $vcMigrationReport.apiVcMigrationReport.migrationState

    $vcMigrationReport.issueCount = $vcMigrationReport.apiVcMigrationReport.highCount + $vcMigrationReport.apiVcMigrationReport.mediumCount + $vcMigrationReport.apiVcMigrationReport.lowCount
        
    if ($vcMigrationReport.migrationState -eq "UnableToMigrate" -or $vcMigrationReport.issueCount -gt 0) {

        [Array]$outReport = $null
            
        foreach ($itemCategory in $vcMigrationReport.apiVcMigrationReport.items) {
            
            foreach ($issue in $itemCategory.issues) {
            
                $issue | % { 

                    if ($_.description -match "The specified enclosure is managed by Virtual Connect Enterprise Manager") {

                        Write-Warning "Enclosure is currently managed by Virtual Connect Enterprise Manager."
                                
                        $vcMigrationReport.VcemManaged = $True
                        
                    }

                    $_ | add-member -NotePropertyName name -NotePropertyValue $itemCategory.name -force 
                    $_ | add-member -NotePropertyName resourceName -NotePropertyValue $_.name -force 
                    $vcMigrationReport.outReport += $_  
                        
                }
            
            }
            
            foreach ($item in $itemCategory.items) { 
            
                $items = $item | where { $_.severity -notmatch "OK" }
                $items | foreach { 
            
                    $_.issues | add-member -NotePropertyName name -NotePropertyValue $itemCategory.name -force 
                    $_.issues | add-member -NotePropertyName resourceName -NotePropertyValue $_.name -force 
                    $vcMigrationReport.outReport += $_.issues
            
                }
                
            }
            
        }

    }
            
    Return $vcMigrationReport

}

function Get-HPOVEnclosure 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml
  
    [CmdletBinding(DefaultParameterSetName = "default")]    
    Param 
	(

        [parameter(Mandatory = $false, ParameterSetName = "default", Position = 0)]
		[parameter(Mandatory = $false, ParameterSetName = "export", Position = 0)]
		[parameter(Mandatory = $false, ParameterSetName = "report", Position = 0)]
		[validateNotNullorEmpty()]
        [string]$Name = $null,

		[parameter(Position = 1, Mandatory = $false)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions},

        [parameter (Mandatory = $false, ParameterSetName = "export", Position = 2)]
        [Alias("x", "export")]
        [ValidateScript({split-path $_ | Test-Path})]
        [String]$exportFile,
			
		[parameter (Mandatory = $false, ParameterSetName = "report")]
		[switch]$Report

    )

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if  ($ApplianceConnection.Count -eq 0)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoAuthSessionFound InvalidArgument 'ApplianceConnection' -Message 'No ApplianceConnections were found.  Please use Connect-HPOVMgmt to establish an appliance connection.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}
		
		$c = 0
		
		ForEach ($_connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$EnclosureCollection = New-Object System.Collections.ArrayList
        
	}

    Process 
	{

		ForEach ($_connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($Connection.Name)' Appliance (of $($Appliance.Count))"

			if ($PSboundParameters['name']) 
			{

	            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Group name provided: '$name'"
	
				$name = $name -replace ("[*]","%25") -replace ("[&]","%26")
	
				$uri = $enclosuresUri + "?filter=name matches '$name'&sort=name:asc"
	
	        }
	
	        else 
			{
	
	            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No Enclosure Group name provided. Looking for all Enclosure Group resources."
	
	            $uri = $enclosuresUri
	
	        }

			Try
			{
	
				$_enclosures = Send-HPOVRequest $uri -Hostname $_connection
	
			}
	        
			Catch
			{
	
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] API Error Caught: $($_.Exception.Message)"
	
				$PSCmdlet.ThrowTerminatingError($_)
	
			}
	
	        if ($_enclosures.count -eq 0 -and $name) 
			{ 
	
	            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure '$name' resource not found. Generating error"

	            $errorRecord = New-ErrorRecord InvalidOperationException EnclosureGroupNotFound ObjectNotFound 'Name' -Message "The specified Enclosure '$name' was not found on '$($_connection.Name)'.  Please check the name and try again." 
	            $pscmdlet.ThrowTerminatingError($errorRecord)  
	            
	        }
	
	        elseif ($_enclosures.count -eq 0) 
			{ 
	
	            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No Enclosure resources found on $($_connection.name)."
	
	        }
	
	        else 
			{
	
	            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Found $($_enclosures.count) Enclosure Group resources."
	
				# // Todo Update ConvertTo-Object with LIG
				$_enclosures.members | % { 
					
					$_.PSObject.TypeNames.Insert(0,'HPOneView.Enclosure')	
	
					[void]$EnclosureCollection.Add($_ ) 
					
				}
	 
	        }

		}

	}

	End 
	{
                
		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Done. $($EnclosureCollection.count) enclosure(s) found."
				
		#Display a report of an enclsosure
        if ($Report) 
		{ 
			
			$EnclosureCollection | % { Enclosure-Report $_ } 
		
		}
		
		#display the JSON body of the enclosure
		elseif ($exportFile) 
		{ 
			
			$EnclosureCollection | convertto-json -depth 99 > $exportFile 
		
		}
		
		# else Return enclosure object
		else 
		{ 

            Return $EnclosureCollection
        
        }

	}

}

function Enclosure-Report 
{

    <#
        .DESCRIPTION
        Internal helper function to display the report of an enclosure

        .PARAMETER Enclosure
        The enclosure object.
	
        .PARAMETER file
        File to save the report to.
	
        .INPUTS
        Enclosure object.

        .OUTPUTS
        Enclosure report.

        .LINK
        Get-HPOVEnclosure

        .LINK
        Send-HPOVRequest

        .EXAMPLE
        PS C:\> $enclosures = Get-HPOVEnclosure
        Return all the enclosure hardware  managed by this appliance.

    #>
    
	[CmdletBinding()]    
    Param 
	(

        [parameter(Mandatory = $true,ValueFromPipeline = $true, Position = 0)]
        [object]$Enclosure,
	
	    [parameter(Mandatory = $false,ValueFromPipeline = $false, Position = 1)]
        [object]$file = $null,
	
		[parameter(Mandatory = $false)]
        [switch]$fwreport
    )

	Process 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"
		
		write-verbose "ENCLOSURE OBJECT:  $($enclosure)"
        write-verbose "ENCLOSURE UUID:  $($Enclosure.uuid)"
	
	#ENCLOSURE REPORT DATA
        $a = @{Expression={$_.name};Label="Enclosure Name";width=15},
			 @{Expression={$_.serialNumber};Label="Serial Number";width=15},
			 @{Expression={$_.enclosureType};Label="Enclosure Model";width=30},
			 @{Expression={$_.rackName};Label="Rack Name";width=12},
			 @{Expression={$_.isFwManaged};Label="FW Managed";width=10},
			 @{Expression={$_.fwBaseLineName};Label="Baseline Name";width=30}

		#Generate Report
        $Enclosure | format-table $a -AutoSize
		
		#License Intent Report
		$a = @{Expression={$_.licensingIntent};Label="Licensing";width=15}

		$Enclosure | format-table $a -AutoSize
		
	#ONBOARD ADMINISTRATOR REPORT DATA
        $a = @{Expression={$_.bayNumber};Label="OA Bay";width=10},
			 @{Expression={$_.role};Label="Role";width=15},
			 @{Expression={$_.ipAddress};Label="IP Address";width=15},
			 @{Expression={($_.fwVersion + " " + $_.fwBuildDate)};Label="Firmware Version";width=20}
        
        $Enclosure.oa | Format-Table $a -AutoSize
		
	#DEVICE BAY REPORT DATA
		#Looking for servers related to the requested enclosure
		$serversCol = New-Object System.Collections.ArrayList
		
		#Loop through populated device bays
		ForEach ($_DeviceBay in ($Enclosure.deviceBays | ? { $_.devicePresence -eq 'Present' -and $_.deviceUri } ))
		{
			
			#Loop through index association results
			#$enclosureDeviceAssociation.members | % { [void]$deviceBays.Add((send-hpovrequest $_.childuri -Hostname $Enclosure.ApplianceConnection.Name)) }
			[void]$serversCol.Add((Send-HPOVRequest $_DeviceBay.deviceUri -Hostname $Enclosure.ApplianceConnection.Name))

		}
		
        $serversCol | out-string | write-verbose
		
		$a = @{Expression={$_.name};Label="Server Name";width=20},
			 @{Expression={$_.serialNumber};Label="Serial Number";width=15},
			 @{Expression={$_.shortModel};Label="Model";width=12},
			 @{Expression={$_.romVersion};Label="System ROM";width=15},
			 @{Expression={($_.mpModel + " " + $_.mpFirmwareVersion)};Label="iLO Firmware Version";width=22},
			 @{Expression={

			 	if (-not($_.serverProfileUri))
				{ 
					
					'No Profile' 
				
				}

			 	else 
				{ 
				 
					(Send-HPOVRequest $_.serverProfileUri -Hostname $Enclosure.ApplianceConnection.Name).name 
				
				}

			 };Label="Server Profile";width=30},
			 @{Expression={$_.licensingIntent};Label="Licensing";width=15}
		
        $serversCol | Sort-Object name | format-table $a -AutoSize
		
	#INTERCONNECT BAY REPORT DATA
		#Loop through interconnect bays
		$interconnectsCol = New-Object System.Collections.ArrayList

		foreach ($interconnect in $enclosure.interconnectBays)
		{

			Write-Verbose "INTERCONNECT:  $($interconnect)"

            if ($interconnect.interconnectUri)
			{

                #Get the Interconnect object to read properties
			    $tempInterconnect = Send-HPOVRequest $interconnect.interconnectUri -Hostname $Enclosure.ApplianceConnection.Name

                #Get Logical Interconnect associated with the Interconnect to report its Name
				$li = Send-HPOVRequest $interconnect.logicalInterconnectUri -Hostname $Enclosure.ApplianceConnection.Name

				$tempInterconnect | Add-Member -type NoteProperty -name liName -value $li.name
                $tempInterconnect | out-string | Write-Verbose
				
				[void]$interconnectsCol.Add($tempInterconnect)

		    }

		}

        #Display Interconnect information (Name, Model, Serial Number, FW Ver)
		$a = @{Expression={$_.name};Label="Interconnect Name";width=22},
			 @{Expression={$_.model};Label="Module";width=38},
			 @{Expression={$_.serialNumber};Label="Serial Number";width=20},
			 @{Expression={$_.firmwareVersion};Label="Firmware Version";width=20}

        $interconnectsCol | format-Table $a -AutoSize

        #Display Interconnect information (PAD, Name, Logical Interconnect Name, State, Status)
        $b = @{Expression={'     '};Label="     ";width=5},
			 @{Expression={$_.name};Label="Interconnect Name";width=22},
			 @{Expression={$_.liName};Label="Logical Interconnect";width=30},
			 @{Expression={$_.state};Label="State";width=14},
			 @{Expression={$_.status};Label="Status";width=20},
			 @{Expression={ 
				 
				 $tempLI = Send-HPOVRequest $_.logicalInterconnectUri -Hostname $Enclosure.ApplianceConnection.Name
	             switch ($tempLI.consistencyStatus) 
				 {
 
					'CONSISTENT'     { "Consistent" }
					'NOT_CONSISTENT' { "Inconsistent with group" }
					default          { $tempLI.consistencyStatus }
			     
				 }
			 
			 };Label="Consistency state";width=26}

        $interconnectsCol | format-Table $b -AutoSize

		#Write-Host "=================================================================================================================="

	}

}

function Remove-HPOVEnclosure 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "default",SupportsShouldProcess = $True,ConfirmImpact = 'High')]
    Param
    (

        [parameter (Position = 0, Mandatory, ValueFromPipeline, ParameterSetName = "default", HelpMessage = "Enter the enclosure to remove.")]
        [ValidateNotNullOrEmpty()]
        [Alias("uri", "name", "Enclosure")]
        [object]$Resource,

		[parameter(Position = 1, ValueFromPipelineByPropertyName, Mandatory = $false)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = $null,

        [parameter(Mandatory = $false)]
        [switch]$Force

    )

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		#Support ApplianceConnection property value via pipeline from Enclosure Object
		if(-not($PSboundParameters['ApplianceConnection']))
		{

			ForEach ($_connection in $ApplianceConnection) 
			{

				Try 
				{
			
					$ApplianceConnection[$c] = Test-HPOVAuth $_connection

				}

				Catch [HPOneview.Appliance.AuthSessionException] 
				{

					$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_connection -Message $_.Exception.Message -InnerException $_.Exception
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				Catch 
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

				$c++

			}

		}

		if (-not($PSBoundParameters['Enclosure'])) { $PipelineInput = $True }

		$_TaskCollection      = New-Object System.Collections.ArrayList
		$_EnclosureCollection = New-OBject System.Collections.ArrayList
        
	}

    Process 
	{

		if ($PipelineInput) 
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Pipeline input"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Object provided: $($Resource | FL * | Out-String)"

			If ($Resource.category -eq 'enclosures')
			{

				If (-not($Resource.ApplianceConnection))
				{

					$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument $Resource.Name -TargetType PSObject -Message "The Network resource provided is missing the source ApplianceConnection property.  Please check the object provided and try again."
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				[void]$_EnclosureCollection.Add($Resource)

			}

			else
			{

				$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument "$($Resource.Name)" -TargetType PSObject -Message "The Enclosure resource is not an expected category type [$($Resource.category)].  Allowed resource category type is 'enclosures'.  Please check the object provided and try again."
                $PSCmdlet.ThrowTerminatingError($errorRecord)

			}

		}

		else 
		{

			foreach ($enclosure in $Resource) 
			{

				#Enclosure passed is a URI
				if (($enclosure -is [String]) -and [System.Uri]::IsWellFormedUriString($enclosure,'Relative')) 
				{

				    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Received URI: $($enclosures)"

				    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Enclosure Object"

					# // NEED APPLIANCE NAME HERE with If Condition
					Try
					{

						$enclosure = Send-HPOVRequest $enclosure -ApplianceConnection $ApplianceConnection

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}
			    
				}

				#Enclosure passed is the Name
				elseif (($enclosure -is [string]) -and (-not($enclosure.startsWith("/rest")))) 
				{

				    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Received Enclosure Name $($enclosure)"

				    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Enclosure object from Get-HPOVEnclosure"
				    
					# // NEED APPLIANCE NAME HERE with If Condition
					Try
					{

						$enclosure = Get-HPOVEnclosure $enclosure -ApplianceConnection $ApplianceConnection

					}
				    

				    Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

				}

				#Enclosure passed is an object
				elseif ($enclosure -is [PSCustomObject] -and ($enclosure.category -ieq 'enclosures')) 
				{
				    
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Object provided: $($enclosure | FL * | out-string)"
				
				}

				else 
				{

				    $errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'Resource' -TargetType 'PSObject' -Message "Invalid Resource parameter: $($enclosure | FL * | Out-String)"
				    $PSCmdlet.WriteError($errorRecord)

				}

				[void]$_EnclosureCollection.Add($enclosure)

			}

		}
        
    }

	End
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing $($_EnclosureCollection.count) Enclosure resources to remove."

		#Process Enclosure Resources
		ForEach ($_enclosure in $_EnclosureCollection)
		{

			if ($pscmdlet.ShouldProcess($_enclosure.name,"Remove Enclosure from appliance '$($_enclosure.ApplianceConnection.Name)'?'")) 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Removing Enclosure '$($_enclosure.name)' from appliance '$($_enclosure.ApplianceConnection.Name)'."

				Try
				{
					
					if ($PSBoundParameters['Force'])
					{

						$_enclosure.uri += "?force=true"

					}

					$_resp = Send-HPOVRequest $_enclosure.Uri DELETE -Hostname $_enclosure.ApplianceConnection.Name

					[void]$_TaskCollection.Add($_resp)

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

			}

			elseif ($PSBoundParameters['WhatIf'])
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] WhatIf parameter was passed."

			}

		}

		Return $_TaskCollection

	}

}

function Get-HPOVServerHardwareType 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding()]
	Param
	(

		[parameter(Position = 0, Mandatory = $false)]
		[ValidateNotNullorEmpty()]
		[string]$Name = $null,

		[parameter(Position = 1, ValueFromPipelineByPropertyName, Mandatory = $false)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions},

		[parameter (Position = 2, Mandatory = $false)]
        [Alias("x", "export")]
        [ValidateScript({split-path $_ | Test-Path})]
        [String]$exportFile

    )

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if  ($ApplianceConnection.Count -eq 0)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoAuthSessionFound InvalidArgument 'ApplianceConnection' -Message 'No ApplianceConnections were found.  Please use Connect-HPOVMgmt to establish an appliance connection.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}
		
		$c = 0
		
		#Support ApplianceConnection property value via pipeline from Enclosure Object
		if(-not($PSboundParameters['ApplianceConnection']))
		{

			ForEach ($_connection in $ApplianceConnection) 
			{

				Try 
				{
			
					$ApplianceConnection[$c] = Test-HPOVAuth $_connection

				}

				Catch [HPOneview.Appliance.AuthSessionException] 
				{

					$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_connection -Message $_.Exception.Message -InnerException $_.Exception
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				Catch 
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

				$c++

			}

		}

		$_SHTCollection = New-OBject System.Collections.ArrayList
        
	}

    Process 
	{

		ForEach ($_connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Appliance Connection $($_connection.Name)."

			if ($PSBoundParameters['Name'])
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server Hardware Type name provided: '$Name'"

				$uri = $script:serverHardwareTypesUri + "?filter=name matches '$name'&sort=name:asc"

			}

			else
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Looking for all Server Hardware Type resources."

				$uri = $script:serverHardwareTypesUri

			}

			Try
			{

				$_resp = Send-HPOVRequest $uri -hostname $_connection

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			if ($PSBoundParameters['Name'] -and $_resp.count -eq 0)
			{

				$errorRecord = New-ErrorRecord InvalidOperationException ServerHardwareTypeNotFound ObjectNotFound 'Name' -Message "'$name' Server Hardware Type not found. Please check the name and try again."
				$pscmdlet.ThrowTerminatingError($errorRecord)

			}

			if ($_resp.count -gt 0)
			{

				$_resp.members | % { 
					
					$_.PSObject.TypeNames.Insert(0,'HPOneView.ServerHardwareType')

					[void]$_SHTCollection.Add($_)
				
				}

			}

		}

    }

    End 
	{

        if ($PSboundParameters['ExportFile']) 
		{

			
			$_SHTCollection | ConvertTo-JSON -Depth 99 > $ExportFile

        }

        else
		{

			Return $_SHTCollection

		}

    }

}

function Show-HPOVFirmwareReport 
{

	# .ExternalHelp HPOneView.200.psm1-help.xml
    
	[CmdletBinding()]
	Param 
	(

		[parameter(Mandatory, ValueFromPipeline, Position = 0)]
		[validateNotNullorEmpty()]
		[Object]$Resource,
	
		[parameter(Mandatory = $false, Position = 1)]
		[validateNotNullorEmpty()]
		[Object]$Baseline,
            
		[parameter(Mandatory = $false)]
		[Switch]$Export,
            
		[parameter(Mandatory = $false)]
		[validateNotNullorEmpty()]
		[String]$Location = (get-location).Path,

		[parameter(ValueFromPipelineByPropertyName, Mandatory)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Object]$ApplianceConnection

	)
	
    Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		if ($PSBoundParameters['Name'])
		{

			Write-Warning 'The -Name parameter is now deprecated.  Please use the -Resource parameter to specify a resource object via the parameter or Pipeline.'

		}

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		#Support ApplianceConnection property value via pipeline from Enclosure Object
		if($PSboundParameters['ApplianceConnection'])
		{

			Try 
			{
			
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $ApplianceConnection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}

		$_ResourceCollection       = New-OBject System.Collections.ArrayList
		$_FirmwareReportCollection = New-OBject System.Collections.ArrayList

        #Test for location
        if ($Export) 
		{
        
            if ( -not (Test-Path $Location)) 
			{  

                $errorRecord = New-ErrorRecord InvalidOperationException LocationPathNotFound ObjectNotFound 'Location' -Message "The specified path $Location does not exist. Please verify it and try again."
                $pscmdlet.ThrowTerminatingError($errorRecord)
            
            }

        }
    
    }

    Process 
	{	

		$_r = 1

		#Add Resource to Collection, which can be accepted via the pipeline
		ForEach ($_resource in $Resource)
		{

			if ($_resource -is [String])
			{

				#Error that the Resource isn't an object

			}

			"[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding '{0}' object to collection ({1}/{2})." -f $_resource.name, $_r, ($Resource | Measure-Object).Count | Write-Verbose 

			[void]$_ResourceCollection.Add($_resource)

			$_r++

		}

    }

    End 
	{

		$_P = 0

		#Process the report generation here
		ForEach ($_resource in $_ResourceCollection)
		{

			if (-not($PSBoundParameters['Verbose']) -or -not($VerbosePreference -eq 'Continue'))
			{
				
				Write-Progress -id 1 -activity "Generate Firmware Report" -percentComplete (($_P / $_ResourceCollection.count) * 100)

			}

			switch ($_resource.category) 
			{

				"enclosure-groups"
				{

					$_P++

					$_ProgressParams = @{

						ID = 1;
						Activity = "Generate Firmware Report";
						CurrentOperation = ("Processing '{0}' Enclosure Group" -f $_resource.name);
						PercentComplete = (($_P / $_ResourceCollection.count) * 100)

					}

					#Handle the call from -Verbose so Write-Progress does not get borked on display.
					if ($PSBoundParameters['Verbose'] -or $VerbosePreference -eq 'Continue') 
					{
						
						  "[$($MyInvocation.InvocationName.ToString().ToUpper())] Collecting Enclosure Firmware Information - {0}" -f ($_ProgressParams | Out-String) | Write-Verbose
					}
                    
					else 
					{ 

						Write-Progress @_ProgressParams
					
					}

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Enclosure Group to Enclosure associations, then getting found Enclosure Resources."

					[Array]$_LogicalEnclosures = (Send-HPOVRequest "/rest/index/associations?parentUri=$($_resource.uri)&name=ENCLOSURE_GROUP_TO_LOGICAL_ENCLOSURE" -Hostname $_resource.ApplianceConnection.Name).members  | % { Send-HPOVRequest $_.childUri -Hostname $_.ApplianceConnection.Name}
                        
					#Make sure the EG has associated Enclosures/LogicalEnclosures.
					if ($_LogicalEnclosures) 
					{

						$_e = 0

						$_TotalEnclosures = ($_LogicalEnclosures.enclosureUris | Measure-Object).Count

						"[$($MyInvocation.InvocationName.ToString().ToUpper())] Total number of Enclosures to process: {0}" -f $_TotalEnclosures | Write-Verbose 

						foreach ($_le in $_LogicalEnclosures) 
						{ 

							#Loop through LE EnclosureUris
							foreach ($_enclosure in $_le.enclosureUris)
							{

								#Get Enclosure Resource Object
								Try
								{

									$_enclosure = Send-HPOVRequest $_enclosure -Hostname $_resource.ApplianceConnection.Name

								}
							
								Catch
								{

									$PSCmdlet.ThrowTerminatingError($_)

								}

								$_e++

								$_EnclParams = @{

									ID               = 10;
									ParentID         = 1;
									Activity         = "Create Enclosure Firmware Report";
									CurrentOperation = ("[{0}\{1}] Processing '{2}' Enclosure" -f $_e, $_TotalEnclosures, $_enclosure.name);
									PercentComplete  = (($_e / $_TotalEnclosures) * 100)

								}

								#Handle the call from -Verbose so Write-Progress does not get borked on display.
								if ($PSBoundParameters['Verbose'] -or $VerbosePreference -eq 'Continue') 
								{ 

									"[$($MyInvocation.InvocationName.ToString().ToUpper())] Collecting Enclosure Firmware Information: {0}" -f ($_EnclParams | Out-String) | Write-Verbose
							
								}
                    
								else 
								{ 
								
									Write-Progress @_EnclParams
							
								}

								Try
								{

									$_EnclosureReportCol = Get-EnclosureFirmware $_enclosure $Baseline 1

									"[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Firmware Report return: {0}" -f ($_EnclosureReportCol | Out-String) | Write-Verbose

									ForEach ($_item in $_EnclosureReportCol)
									{

										"[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding {0} in {1} to  Enclosure Firmware collection" -f $_item.Component, $_item.Name | Write-Verbose
										
										$_item | add-member -Type NoteProperty -Name eg -value $_resource.name

										[void]$_FirmwareReportCollection.Add($_item)

									}

								}
							
								Catch
								{

									$PSCmdlet.ThrowTerminatingError($_)

								}

							}						

						}

					}
                        
					#Clear Child Write-Progress progress bars
					#Handle the call from -Verbose so Write-Progress does not get borked on display.
					if ($PSBoundParameters['Verbose'] -or $VerbosePreference -eq 'Continue') 
					{ 
						
						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Completed Collecting Enclosure Firmware Information - Skipping Write-Progress display."  
					
					}
             
					else 
					{ 
						
						Write-Progress -ParentId 1 -id 2 -activity "Collecting Enclosure Firmware Information" -CurrentOperation "Completed" -Completed 
					
					}

					#Handle the call from -Verbose so Write-Progress does not get borked on display.
					if ($PSBoundParameters['Verbose'] -or $VerbosePreference -eq 'Continue') 
					{ 
						
						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Completed Collecting Enclosure Group Firmware Information Skipping Write-Progress display."  
					
					}
             
					else 
					{ 
						
						Write-Progress -Id 1 -activity "Collecting Enclosure Group Firmware Information" -CurrentOperation "Completed" -Completed 
					
					}

				}

				"enclosures" 
				{

					#Keep track of the number of resources
					$_P++

					$_ProgressParams = @{

						ID = 1;
						Activity = "Generate Firmware Report";
						CurrentOperation = ("Processing '{0}' Enclosure" -f $_resource.name);
						PercentComplete = (($_P / $_ResourceCollection.count) * 100)

					}

					#Handle the call from -Verbose so Write-Progress does not get borked on display.
					if ($PSBoundParameters['Verbose'] -or $VerbosePreference -eq 'Continue') 
					{
						
						  "[$($MyInvocation.InvocationName.ToString().ToUpper())] Collecting Enclosure Firmware Information - {0}" -f ($_ProgressParams | Out-String) | Write-Verbose
					}
                    
					else 
					{ 

						Write-Progress @_ProgressParams
					
					}

					Try
					{

						$_EnclosureReport = Get-EnclosureFirmware $_resource $Baseline 1

						$_EnclosureReport | % {

							[void]$_FirmwareReportCollection.Add($_)

						}

					}

					Catch
					{

						Write-Progress -id 1 -activity "Collecting Enclosure Firmware Information" -CurrentOperation "Completed" -Completed 

						$PSCmdlet.ThrowTerminatingError($_)

					}
					
					#Handle the call from -Verbose so Write-Progress does not get borked on display.
					if ($PSBoundParameters['Verbose'] -or $VerbosePreference -eq 'Continue') 
					{ 
						
						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Completed Collecting Enclosure Firmware Information - Skipping Write-Progress display."  
					
					}
                
					else 
					{ 
						
						Write-Progress -id 1 -activity "Collecting Enclosure Firmware Information" -CurrentOperation "Completed" -Completed 
					
					}

				}

				"server-hardware" 
				{ 

					#Keep track of the number of resources
					$_P++

					$_ProgressParams = @{

						ID = 1;
						Activity = "Generate Firmware Report";
						CurrentOperation = ("Processing '{0}' Server(s)" -f $_resource.name);
						PercentComplete = (($_P / $_ResourceCollection.count) * 100)

					}

					#Handle the call from -Verbose so Write-Progress does not get borked on display.
					if ($PSBoundParameters['Verbose'] -or $VerbosePreference -eq 'Continue') 
					{
						
						  "[$($MyInvocation.InvocationName.ToString().ToUpper())] Collecting Server Firmware Information - {0}" -f ($_ProgressParams | Out-String) | Write-Verbose
					}
                    
					else 
					{ 

						Write-Progress @_ProgressParams
					
					}

					Try
					{

						$_ServerReport = Get-ServerFirmware $_resource $Baseline

						$_ServerReport | % {

							[void]$_FirmwareReportCollection.Add($_)

						}

					}

					Catch
					{

						Write-Progress -id 1 -activity "Collecting Server Firmware Information" -CurrentOperation "Completed" -Completed 

						$PSCmdlet.ThrowTerminatingError($_)

					}
					
					#Handle the call from -Verbose so Write-Progress does not get borked on display.
					if ($PSBoundParameters['Verbose'] -or $VerbosePreference -eq 'Continue') 
					{ 
						
						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Completed Collecting Server Firmware Information - Skipping Write-Progress display."  
					
					}
                
					else 
					{ 
						
						Write-Progress -id 1 -activity "Collecting Server Firmware Information" -CurrentOperation "Completed" -Completed 
					
					}
            
				}

				"interconnects" 
				{ 

					#Keep track of the number of resources
					$_P++

					$_ProgressParams = @{

						ID = 1;
						Activity = "Generate Firmware Report";
						CurrentOperation = ("Processing '{0}' Interconnects(s)" -f $_resource.name);
						PercentComplete = (($_P / $_ResourceCollection.count) * 100)

					}

					#Handle the call from -Verbose so Write-Progress does not get borked on display.
					if ($PSBoundParameters['Verbose'] -or $VerbosePreference -eq 'Continue') 
					{
						
						  "[$($MyInvocation.InvocationName.ToString().ToUpper())] Collecting Interconnect Firmware Information - {0}" -f ($_ProgressParams | Out-String) | Write-Verbose
					}
                    
					else 
					{ 

						Write-Progress @_ProgressParams
					
					}

					Try
					{

						$_InterconnectFirmwareReport = Get-InterconnectFirmware $_resource $Baseline

						$_InterconnectFirmwareReport | % {

							[void]$_FirmwareReportCollection.Add($_)

						}

					}

					Catch
					{

						Write-Progress -id 1 -activity "Collecting Interconnect Firmware Information" -CurrentOperation "Completed" -Completed 

						$PSCmdlet.ThrowTerminatingError($_)

					}
					
					#Handle the call from -Verbose so Write-Progress does not get borked on display.
					if ($PSBoundParameters['Verbose'] -or $VerbosePreference -eq 'Continue') 
					{ 
						
						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Completed Collecting Interconnect Firmware Information - Skipping Write-Progress display."  
					
					}
                
					else 
					{ 
						
						Write-Progress -id 1 -activity "Collecting Server Firmware Information" -CurrentOperation "Completed" -Completed 
					
					}
           
				}

			}

		}

        Write-Progress -Activity "Firmware collection report complete." -PercentComplete (100) -Status "Finished." -Completed

		if ($Export) 
		{ 

			$_Location = '{0}\FirmwareReport_{1}.csv' -f $Location,[DateTime]::Now.ToUniversalTime().ToString('yyyy-MM-ddTHH.mm.ss.ff.fffZzzz').Replace(':','')

			$_FirmwareReportCollection | % { Export-Csv -InputObject $_ -Path $_Location -Append -NoTypeInformation -Encoding UTF8 }
				
		}

        #Display Report
        else 
		{

            Return $_FirmwareReportCollection

        }

    }

}

function Get-EnclosureFirmware 
{

    <#
        Internal-only function.
    #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param 
	(
    
        [parameter(Position = 0, Mandatory, ValueFromPipeline, ParameterSetName = "Default", HelpMessage = "Enclosure resource object")]
		[ValidateScript({
			if ($_.category -ne 'enclosures') 
			{ 
				
				Throw ("The resource object provided is not an Enclosure Resource.  Expected category 'enclosures', recieved '{0}' [{1}]." -f $_.category, $_.name)
			}

			else
			{

				$True

			}
		
		})]
        [PsCustomObject]$Enclosure = $Null, 

        [parameter(Position = 1, Mandatory = $false, ParameterSetName = "Default", HelpMessage = "SPP Baseline resource object, Name or URI")]
        [object]$Baseline = $Null,

        [parameter(Position = 2, Mandatory = $false, ParameterSetName = "Default", HelpMessage = "Specify the level of the Write-Progress ID")]
        [int]$ProgressID = 0
        
    )

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

        #Reset private variables
        $_BaseLinePolicy  = $Null
        $_EnclosureReport = New-Object System.Collections.ArrayList

        #Keep track of the number of Servers
        $_s = 0

        #Keep track of the number of Interconnects
        $_i = 0
		
        #Keep track of the number of OAs
        $_o = 0

        #See if EnclosureObject was passed via Pipeline
        if (-not $PSBoundParameters['Enclosure']) 
		{ 
			
			$PipelineInput = $True 
		
		}

    }

    Process 
	{
        
        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Object passed via pipeline: $($PipelineInput)"
        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Enclosure firmware report for: '$($Enclosure.name)'"

        #Use the Enclosure FwBaseline if it is set
        if (($Enclosure.isFwManaged) -and ($Baseline -eq $Null)) 
		{ 

			Try
			{

				$BaseLinePolicy = Send-HPOVRequest $Enclosure.fwBaselineUri -Hostname $Enclosure.ApplianceConnection.Name

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

        }

        elseif (($Baseline) -and ($Baseline -is [PsCustomObject]) -and ($Baseline.category -eq "firmware-drivers")) 
		{ 
        
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Baseline resource passed."
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Baseline resource name: $($Baseline.baselineShortName)"
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Baseline resource uri: $($Baseline.uri)"
            $BaseLinePolicy = $Baseline
            
        }
        
        #Check to see if the wrong Object has been passed
        elseif (($Baseline) -and ($Baseline -is [PsCustomObject]) -and ($Baseline.category -ne "firmware-drivers")) 
		{ 
        
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Invalid Baseline resource passed. Generating error."
            $errorRecord = New-ErrorRecord InvalidOperationException InvalidBaselineResouce InvalidArgument 'Baseline' -TargetType 'PSObject' -Message "An invalid Baseline Object was passed.  Expected Category type 'firmware-drivers', received '$($Baseline.category)' (Object Name: $($Baseline.name)"
            $PsCmdLet.ThrowTerminatingError($errorRecord)
            
        }
        
        elseif (($Baseline) -and ($Baseline -is [string]) -and ($Baseline.StartsWith(($script:fwDriversUri)))) 
		{ 
            
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Baseline URI passed: $Baseline"

			Try
			{

				$BaseLinePolicy = Send-HPOVRequest $Baseline -Hostname $Enclosure.ApplianceConnection.Name

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}
            
        
        }
        
        #Check to see if the wrong URI has been passed
        elseif (($Baseline) -and ($Baseline -is [string]) -and $Baseline.StartsWith("/rest/") -and ( ! $Baseline.StartsWith(("/rest/firmware-drivers/")))) 
		{ 
        
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Invalid Baseline URI passed. Generating error."
            $errorRecord = New-ErrorRecord InvalidOperationException InvalidBaselineValue InvalidArgument 'Baseline' -Message "The wrong Baseline URI was passed.  URI must start with '/rest/firmware-drivers/', received '$($Baseline)'"
            $PsCmdLet.ThrowTerminatingError($errorRecord)        
            
        }
        
        elseif (($Baseline) -and ($Baseline -is [string])) 
		{ 
        
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Baseline Name passed: $Baseline"

			Try
			{

				$BaseLinePolicy = Get-HPOVSppFile -name $Baseline 

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}
            
        }
        
        else 
		{ 
        
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No Baseline provided."

            $BaseLinePolicy = [PsCustomObject]@{ baselineShortName = "No Policy Set" } 
        
        }

        #Get OA Firmware Information
		foreach ($_oa in $Enclosure.managerBays) 
		{

			$_o ++

			$_ProgressParams = @{

				id               = (2 + $ProgressID);
				ParentId         = 1;
				activity         = "Collecting Onboard Administrator Firmware Information";
				CurrentOperation = ("[{0}/{1}] Processing '{2}'" -f $_o, $Enclosure.managerBays.count, $_oa.role);
				percentComplete  = (($_o / $Enclosure.managerBays.count) * 100) 

			}

            #Handle the call from -Verbose so Write-Progress does not get borked on display.
            if ($PSBoundParameters['Verbose'] -or $VerbosePreference -eq 'Continue') 
			{ 
				
				"[$($MyInvocation.InvocationName.ToString().ToUpper())] Collecting Onboard Administrator Firmware Information - Skipping Write-Progress display: {0}" -f ($_ProgressParams | Out-String) | Write-Verbose
			
			}
            
            else 
			{ 
				
				Write-Progress @_ProgressParams
			
			}

            #If OA is absent report it as such
            if ($_oa.role -eq "OaAbsent") 
			{
				
				$_OAReport = [PSCustomObject]@{ 

					ApplianceConnection = $_resource.ApplianceConnection.Name
					Name                = $Enclosure.name; 
					Device              = $Enclosure.enclosureType; 
					Component           = "OA Bay $($_oa.bayNumber) Absent"; 
					Installed           = "N/A"; Baseline = "N/A" ; 
					BaselinePolicy      = "N/A"; 
					Compliance          = "N/A" 

				}
			
			}
		    
            else 
			{

                if ($BaseLinePolicy.baselineShortName -eq "No Policy Set") 
				{ 
					
					$BaselineVer = "N/A" 
					$Compliance  = "N/A" 
				
				}

                else 
				{ 
					
					$_BaselineVersions = ($BaseLinePolicy.fwComponents | ? swKeyNameList -match "oa" ).componentVersion 

					$_NewerVersion = $null

					#Figure out which is the newest, and only display that if multiple ROM versions found
					foreach ($_version in $_BaselineVersions)
					{

						if ($_NewerVersion)
						{

							if ($_version -gt $_NewerVersion)
							{

								$_NewerVersion = $_version
							
							}

						}

						else
						{

							if ($_version -ge $_oa.fwVersion)
							{
							
								$_NewerVersion = $_version

							}

						}

					}

					$_BaselineVer = $_NewerVersion
				
				}

                if ($_oa.fwVersion -ne $_BaselineVer)
				{ 
					
					$Compliance = "Not Compliant" 
				
				}
				 
                else 
				{ 
					
					$Compliance = "Compliant" 
				
				}

				$_OAReport = [PSCustomObject]@{

					ApplianceConnection = $_resource.ApplianceConnection.Name
					Name                = $Enclosure.name; 
					Device              = $Enclosure.enclosureType; 
					Component           = "OA Bay $($_oa.bayNumber) $($_oa.role)"; 
					Installed           = $_oa.fwVersion; 
					Baseline            = $_BaselineVer ; 
					BaselinePolicy      = $BaseLinePolicy.baselineShortName; 
					Compliance          = $Compliance 
					
				}

            }

			$_OAReport.PSObject.TypeNames.Insert(0,'HPOneView.FirmwareReport')

			"[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding {0} in {1} to Enclosure Firmware collection" -f $_item.Component, $_item.Name | Write-Verbose

			[void]$_EnclosureReport.Add($_OAReport)

		} 

        #Get Server Resource Objects
        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Server resources from the enclosure."
		Try

		{

			$_Servers = ($Enclosure.deviceBays | ? devicePresence -eq "present" | % { Send-HPOVRequest $_.deviceUri -Hostname $Enclosure.ApplianceConnection.Name })

		}
        
		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

        foreach ($_server in $_Servers) 
		{

            $_s++

			$_ProgressParams = @{

				id               = (3 + $ProgressID);
				ParentId         = 1;
				activity         = "Collecting Server Firmware Information";
				CurrentOperation = ("[{1}/{2}] Processing '{0}' Server" -f $_server.name, $_s, $_Servers.Count);
				percentComplete  = (($_s / $_Servers.Count) * 100) 

			}

            #Handle the call from -Verbose so Write-Progress does not get borked on display.
            if ($PSBoundParameters['Verbose'] -or $VerbosePreference -eq 'Continue') 
			{
				
				"[$($MyInvocation.InvocationName.ToString().ToUpper())] Collecting Server Firmware Information - Skipping Write-Progress display: {0}" -f ($_ProgressParams | Out-String) | Write-Verbose
			
			}
             
            else 
			{ 
				
				Write-Progress @_ProgressParams
			
			}

			Try
			{

				$_ServerFirmwareReport = Get-ServerFirmware $_server $BaseLinePolicy 

				ForEach ($_item in $_ServerFirmwareReport)
				{

					"[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding {0} in {1} to Enclosure Firmware collection" -f $_item.Component, $_item.Name | Write-Verbose

					$_item.PSObject.TypeNames.Insert(0,'HPOneView.FirmwareReport')

					[void]$_EnclosureReport.Add($_item)

				}

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

        }

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Interconnect resources from the enclosure."

		Try
		{

			$_Interconnects = ($Enclosure.interconnectBays | ? interconnectUri -ne $Null | % { Send-HPOVRequest $_.interconnectUri -Hostname $Enclosure.ApplianceConnection.Name })

		}

		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}
        

        #Get Interconnect Information
		foreach ($_interconnect in $_Interconnects) 
		{

            $_i++

			$_ProgressParams = @{

				id               = (4 + $ProgressID);
				ParentId         = 1;
				activity         = "Collecting Interconnect Firmware Information";
				CurrentOperation = ("Processing {0}: {1} of {2} Interconnect(s)" -f $_interconnect.name, $_i, $_Interconnects.Count);
				percentComplete  = (($_i / $_Interconnects.Count) * 100) 

			}

            #Handle the call from -Verbose so Write-Progress does not get borked on display.
            if ($PSBoundParameters['Verbose'] -or $VerbosePreference -eq 'Continue') 
			{
				
				"[$($MyInvocation.InvocationName.ToString().ToUpper())] Collecting Interconnect Firmware Information - Skipping Write-Progress display: {0}" -f ($_ProgressParams | Out-String) | Write-Verbose
			
			}
             
            else 
			{ 
				
				Write-Progress @_ProgressParams
			
			}

			Try
			{

				$_InterconnectReport = Get-InterconnectFirmware $_interconnect $BaseLinePolicy

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			"[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding {0} in {1} to Enclosure Firmware collection" -f $_InterconnectReport.Component, $_InterconnectReport.Name | Write-Verbose

			$_InterconnectReport.PSObject.TypeNames.Insert(0,'HPOneView.FirmwareReport')

			[void]$_EnclosureReport.Add($_InterconnectReport)

        }

        #Handle the call from -Verbose so Write-Progress does not get borked on display.
        if ($PSBoundParameters['Verbose'] -or $VerbosePreference -eq 'Continue') 
		{ 
			
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Completed Collecting OA/Server/Interconnect Firmware Information - Skipping Write-Progress display."  
		
		}
         
        else 
		{ 
        
            Write-Progress -ParentId 1 -id (2 + $ProgressID) -activity "Collecting Onboard Administrator Firmware Information" -CurrentOperation "Completed" -Completed                    
            Write-Progress -ParentId 1 -id (3 + $ProgressID) -activity "Collecting Server Firmware Information" -CurrentOperation "Completed" -Completed
            Write-Progress -ParentId 1 -id (4 + $ProgressID) -activity "Collecting Interconnect Firmware Information" -CurrentOperation "Completed" -Completed

        }

    }

    end 
	{

        Return $_EnclosureReport

    }

}

function Get-ServerFirmware 
{

    <#
        Internal-only function.
    #>

    [CmdletBinding()]
    Param 
	(
    
        [parameter(Position = 0, Mandatory, ValueFromPipeline, ParameterSetName = "Default", HelpMessage = "Server resource object")]
        [PsCustomObject]$Server, 

        [parameter(Position = 1, Mandatory = $false, ParameterSetName = "Default", HelpMessage = "SPP Baseline resource object, Name or URI")]
        [object]$Baseline = $Null
        
    )


    Begin 
	{

        #See if serverObject was passed via Pipeline
        if (-not $PSBoundParameters['serverObject']) { $PipelineInput = $True }
        
        $_ServerReport = New-Object System.Collections.ArrayList

    }

    Process 
	{
        
        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server Object passed via pipeline: $($PipelineInput)"
        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Server firmware report for: '$($server.name)'"
        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Server Hardware Type"

        #Check if the server hardware type allows firmware management
		Try
		{

			$_sht = Send-HPOVRequest $Server.serverHardwareTypeUri -Hostname $Server.ApplianceConnection.Name

		}

		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}
        

        if ($_sht.capabilities -match "FirmwareUpdate") 
		{

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server Hardware Type supports firmware management."

            "[$($MyInvocation.InvocationName.ToString().ToUpper())] Baseline value provided: {0}" -f ($Baseline | Out-String) | Write-Verbose

            #If a bladeserver and that the caller hasn't specified a Baseline, Use the Enclosure FwBaseline if it is set
            if (-not($Baseline))
			{ 

                #Check to see if there is a profile
                if ($Server.serverProfileUri) 
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No Baseline provided.  Checking Server Profile."

					Try
					{

						$_ServerProfile = Send-HPOVRequest $Server.serverProfileUri -Hostname $Server.ApplianceConnection.Name

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

                    #Then check if a Baseline is attached there
                    if ($_ServerProfile.firmware.manageFirmware) 
					{ 
                    
                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server Profile has baseline attached. Getting baseline details."

						Try
						{

							$_BaselinePolicy = Send-HPOVRequest $_ServerProfile.firmware.firmwareBaselineUri -Hostname $Server.ApplianceConnection.Name

						}

						Catch
						{

							$PSCmdlet.ThrowTerminatingError($_)

						}

                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server Profile Baseline name: $($_BaselinePolicy.name)"

                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server Profile Baseline name: $($_BaselinePolicy.uri)"

                    }
                    
					#If not, set $BaselinePolicy to No Policy Set
                    else 
					{
                        
                        write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server Profile does not have a baseline attached."

                        $_BaselinePolicy = [PsCustomObject]@{ 
							
							baselineShortName = "No Policy Set" 
						
						} 

                    }

                }

                else 
				{

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No Server Profile assigned, which does not have a baseline policy set."

                    $_BaselinePolicy = [PsCustomObject]@{ 
							
						baselineShortName = "No Policy Set" 
						
					} 

                }
                   
            }

            elseif (($Baseline) -and ($Baseline -is [PsCustomObject]) -and ($Baseline.category -eq "firmware-drivers")) 
			{ 
            
                write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Baseline resource passed."
                write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Baseline resource name: $($Baseline.baselineShortName)"
                write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Baseline resource uri: $($Baseline.uri)"

                $_BaselinePolicy = $Baseline.PSObject.Copy()
                
            }

            #Check to see if the wrong Object has been passed
            elseif (($Baseline) -and ($Baseline -is [PsCustomObject]) -and ($Baseline.category -ne "firmware-drivers")) 
			{ 
            
                write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Invalid Baseline resource passed. Generating error."

                $errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentType InvalidArgument 'getserverfirmware' -Message "The wrong Baseline Object was passed.  Expected Category type `'firmware-drivers`', received `'$($Baseline.category)`' (Object Name: $($Baseline.name)"

                $PsCmdLet.ThrowTerminatingError($errorRecord)
                
            }

            elseif (($Baseline) -and ($Baseline -is [string]) -and ($Baseline.StartsWith(($script:fwDriversUri)))) 
			{ 
                
                write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Baseline URI passed: $Baseline"

				Try
				{

					$_BaseLinePolicy = Send-HPOVRequest $Baseline -Hostname $Server.ApplianceConnection.Name

				}
                
				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}
            
            }

            #Check to see if the wrong URI has been passed
            elseif (($Baseline) -and ($Baseline -is [string]) -and $Baseline.StartsWith("/rest/") -and ( ! $Baseline.StartsWith(("/rest/firmware-drivers/")))) 
			{ 

                write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Invalid Baseline URI passed. Generating error."
                $errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentType InvalidArgument 'getserverfirmware' -Message "The wrong Baseline URI was passed.  URI must start with '/rest/firmware-drivers/', received '$($Baseline)'"
                $PsCmdLet.ThrowTerminatingError($errorRecord)        
                
            }

            elseif (($Baseline) -and ($Baseline -is [string])) 
			{ 
            
                write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Baseline Name passed: $Baseline"

				Try
				{

					$_BaseLinePolicy = Get-HPOVSppFile -name $Baseline -ApplianceConnection $Server.ApplianceConnection.Name

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)
				
				}
                
                
            }

            else 
			{ 
            
                write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No Baseline provided."

                $_BaseLinePolicy = [PsCustomObject]@{ baselineShortName = "No Policy Set" } 
            
            }

            write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Server ROM Information."

            #Saving SystemROM Information
            $_ServerRomVersion = ($Server.romVersion -replace "/",".").SubString(4)

            #Check Baseline Policy and set Compliance statement
            if ($_BaseLinePolicy.baselineShortName -eq "No Policy Set") 
			{ 
                            
                $_BaselineVer = "N/A" 
                $_Compliance  = "N/A"
                                    
            }

            else 
			{ 
                            
                $BaselineVer = ($_BaseLinePolicy.fwComponents | ? swKeyNameList -eq $Server.romVersion.SubString(0,3)).componentVersion

                write-verbose "Found Baseline version(s): $($BaselineVer | out-string)"

				$_NewerVersion = $null

				#Figure out which is the newest, and only display that if multiple ROM versions found
				foreach ($_version in $BaselineVer)
				{

					if ($_NewerVersion)
					{

						if ($_version -gt $_NewerVersion)
						{

							$_NewerVersion = $_version
							
						}

					}

					else
					{

						if ($_version -ge $_ServerRomVersion)
						{
							
							$_NewerVersion = $_version

						}

					}

				}

				$_BaselineVer = $_NewerVersion

                if ($_ServerRomVersion -ne $_BaselineVer) 
				{ 
					
					$_Compliance = "Not Compliant" 
				
				} 
                
				else 
				{ 
					
					$_Compliance = "Compliant" 
				
				}				
				 
            }

            $_Report = [PSCustomObject]@{ 
				
				ApplianceConnection = $_resource.ApplianceConnection.Name
				Name           = $Server.name; 
				Device         = $Server.shortModel; 
				Component      = "ROM"; 
				Installed      = $_ServerRomVersion; 
				Baseline       = $_BaselineVer ; 
				BaselinePolicy = $_BaseLinePolicy.baselineShortName; 
				Compliance     = $_Compliance 
			
			}

			[void]$_ServerReport.Add($_Report)

            write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Server iLO Information."

            #Saving iLO Information
            $_MpFirmwareVersion = $Server.mpFirmwareVersion.SubString(0,4)

            #Check Baseline Policy and set Compliance statement
            if ($_BaseLinePolicy.baselineShortName -eq "No Policy Set") 
			{
                            
                $_BaselineVer = "N/A" 
                $_Compliance = "N/A"
                                    
            }

            else 
			{ 
                            
                $_BaselineVersions = ($_BaseLinePolicy.fwComponents | ? swKeyNameList -match $mpModelTable.($Server.mpModel)).componentVersion

				$_NewerVersion = $null

				#Figure out which is the newest, and only display that if multiple ROM versions found
				foreach ($_version in $_BaselineVersions)
				{

					if ($_NewerVersion)
					{

						if ($_version -gt $_NewerVersion)
						{

							$_NewerVersion = $_version
							
						}

					}

					else
					{

						if ($_version -ge $_MpFirmwareVersion)
						{
							
							$_NewerVersion = $_version

						}

					}

				}

				$_BaselineVer = $_NewerVersion

                if ($_MpFirmwareVersion -ne $_BaselineVer) 
				{ 
					
					$_Compliance = "Not Compliant" 
				
				} 

                else 
				{ 
					
					$_Compliance = "Compliant" 
				
				} 
                                
            }

			$_Report = [PSCustomObject]@{ 
				
				ApplianceConnection = $_resource.ApplianceConnection.Name
				Name           = $Server.name; 
				Device         = $Server.shortModel; 
				Component      = "iLO"; 
				Installed      = $_MpFirmwareVersion; 
				Baseline       = $_BaselineVer; 
				BaselinePolicy = $_BaseLinePolicy.baselineShortName; 
				Compliance     = $_Compliance 
			
			}

			[void]$_ServerReport.Add($_Report)

			if ($Server.intelligentProvisioningVersion)
			{

				#Report Intelligent Provisioning version
				$_Report = [PSCustomObject]@{ 
				
					ApplianceConnection = $_resource.ApplianceConnection.Name
					Name           = $Server.name; 
					Device         = $Server.shortModel; 
					Component      = "Intelligent Provisioning"; 
					Installed      = $Server.intelligentProvisioningVersion; 
					Baseline       = 'N/A'; 
					BaselinePolicy = 'N/A'; 
					Compliance     = 'N/A'
			
				}

				[void]$_ServerReport.Add($_Report)

			}

        }

        #Server firmware is unmanageable based on its Server Hardware Type
        else 
		{ 
            
            write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server Hardware Type does not support firmware management."      

            [void]$_ServerReport.Add(

				[PSCustomObject]@{ 

					ApplianceConnection = $_resource.ApplianceConnection.Name
					Name           = $Server.name; 
					Device         = $Server.shortModel; 
					Component      = "N/A"; 
					Installed      = "N/A"; 
					Baseline       = "N/A" ; 
					BaselinePolicy = "Unmanageable" 
				
				}

			)

        }

    }

    end 
	{

		$_ServerReport | % {

			$_.PSObject.TypeNames.Insert(0,'HPOneView.FirmwareReport')

		}

        Return $_ServerReport

    }

}

function Get-InterconnectFirmware 
{

    <#
        Internal-only function.
    #>

    [CmdletBinding(DefaultParameterSetName = 'Default')]
    Param 
	(
    
        [parameter(Position = 0, Mandatory, ValueFromPipeline, ParameterSetName = "Default", HelpMessage = "Interconnect resource object")]
        [PsCustomObject]$Interconnect, 

        [parameter(Position = 1, Mandatory = $false, ParameterSetName = "Default", HelpMessage = "SPP Baseline resource object, Name or URI")]
        [object]$Baseline = $Null
        
    )


    Begin 
	{

        $_InterconnectReport = New-Object System.Collections.ArrayList

    }

    Process 
	{
        
        "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Interconnect firmware report for: {0}" -f $Interconnect.name | Write-Verbose

		$_InterconnectFirmwareVersion = $Interconnect.firmwareVersion
        
        if (-not($Baseline))
		{



			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Baseline was not provided, checking Logical Interconnect Firmware Baseline set."

			Try
			{

				$_LogicalInterconnect = Send-HPOVRequest $Interconnect.logicalInterconnectUri -Hostname $Interconnect.ApplianceConnection.Name

				$_LogicalInterconnectFirmware = Send-HPOVRequest ($_LogicalInterconnect.uri + '/firmware') -Hostname $Interconnect.ApplianceConnection.Name

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			if ($_LogicalInterconnectFirmware.sppUri.ToLower() -ne 'unknown')
			{
				
				Try
				{

					$_BaseLinePolicy = Send-HPOVRequest $_LogicalInterconnectFirmware.sppUri -Hostname $Interconnect.ApplianceConnection.Name

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

				"[$($MyInvocation.InvocationName.ToString().ToUpper())] Logical Interconenct Firmware Baseline name: {0}" -f $_BaseLinePolicy.name | Write-Verbose

			}

			Else
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Baseline was not provided, checking Enclosure Firmware Baseline set."

				Try
				{

					$_Enclosure = Send-HPOVRequest $Interconnect.enclosureUri -Hostname $Interconnect.ApplianceConnection.Name

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}
            
				"[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Firmware Baseline set: {0}" -f $_Enclosure.isFwManaged | Write-Verbose 

				#Check if the Enclosure has a Firmware Baseline attached
				if ($_Enclosure.isFwManaged -and $_Enclosure.fwBaselineUri)
				{ 

					Try
					{

						$_BaseLinePolicy = Send-HPOVRequest $_Enclosure.fwBaselineUri -Hostname $Interconnect.ApplianceConnection.Name

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

					"[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Firmware Baseline name: {0}" -f $_BaseLinePolicy.name | Write-Verbose

				}

				else 
				{ 
            
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No Baseline provided."

					$_BaseLinePolicy = [PsCustomObject]@{ baselineShortName = "No Policy Set" } 
            
				}

			}

        }

        else 
		{
            
            if ($Baseline -is [PsCustomObject] -and ($Baseline.category -eq "firmware-drivers")) 
			{ 
            
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Baseline resource passed."
                "[$($MyInvocation.InvocationName.ToString().ToUpper())] Baseline resource name: {0}" -f $Baseline.baselineShortName | Write-Verbose 
                "[$($MyInvocation.InvocationName.ToString().ToUpper())] Baseline resource uri: {0}" -f $Baseline.uri | Write-Verbose 

                $_BaseLinePolicy = $Baseline
                
            }

            #Check to see if the wrong Object has been passed
            elseif ($Baseline -is [PsCustomObject] -and ($Baseline.category -ne "firmware-drivers")) 
			{ 
            
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Invalid Baseline resource passed. Generating error."
                $errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentType InvalidArgument 'Baseline' -TargetType 'PSObject' -Message ("An invalid Baseline Object was passed.  Expected Category type 'firmware-drivers', received '{0}' (Object Name: {1})" -f $Baseline.category, $Baseline.name)
                $PsCmdLet.ThrowTerminatingError($errorRecord)
                
            }

            elseif ($Baseline -is [string] -and ($Baseline.StartsWith(($script:fwDriversUri)))) 
			{ 
                
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Baseline URI passed: $Baseline"

				Try
				{

					$_BaseLinePolicy = Send-HPOVRequest $Baseline -Hostname $Interconnect.ApplianceConnection.Name

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}
  
            }

            #Check to see if the wrong URI has been passed
            elseif (($Baseline -is [string]) -and $Baseline.StartsWith("/rest/") -and (-not($Baseline.StartsWith(("/rest/firmware-drivers/"))))) 
			{ 

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Invalid Baseline URI passed. Generating error."

                $errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentType InvalidArgument 'Baseline' -Message ("An invalid Baseline URI was passed.  URI must start with '/rest/firmware-drivers/', received '{0}'" -f $Baseline)
                $PsCmdLet.ThrowTerminatingError($errorRecord)        
                
            }

            elseif ($Baseline -is [string]) 
			{ 
            
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Baseline Name passed: $Baseline"

				Try
				{

					$_BaseLinePolicy = Get-HPOVSppFile -name $Baseline -Hostname $Interconnect.ApplianceConnection.Name

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

            }

            else 
			{ 
				
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Unknown baseline." 
			
			}

        }

        if ($_BaseLinePolicy.baselineShortName -eq "No Policy Set") 
		{ 
        
            $_BaselineVer = "N/A"
            $_Compliance = "N/A"

        }

        else 
		{ 

            $_BaselineVersions = ($_BaseLinePolicy.fwComponents | ? swKeyNameList -match "vceth").componentVersion

			$_NewerVersion = $null

			#Figure out which is the newest, and only display that if multiple ROM versions found
			foreach ($_version in $_BaselineVersions)
			{

				if ($_NewerVersion)
				{

					if ($_version -gt $_NewerVersion)
					{

						$_NewerVersion = $_version
							
					}

				}

				else
				{

					if ($_version -ge $_InterconnectFirmwareVersion)
					{
							
						$_NewerVersion = $_version

					}

				}

			}

			$_BaselineVer = $_NewerVersion

            if ($_InterconnectFirmwareVersion -ne $_BaselineVer) 
			{ 
					
				$_Compliance = "Not Compliant" 
				
			} 

            else 
			{ 
					
				$_Compliance = "Compliant" 
				
			} 
                                
        }

		$_Report = [PSCustomObject]@{ 
				
			ApplianceConnection = $_resource.ApplianceConnection.Name;
			Name           = $Interconnect.name; 
			Device         = $Interconnect.model; 
			Component      = 'Interconnect'; 
			Installed      = $_InterconnectFirmwareVersion; 
			Baseline       = $_BaselineVer; 
			BaselinePolicy = $_BaseLinePolicy.baselineShortName; 
			Compliance     = $_Compliance 
			
		}

		[void]$_InterconnectReport.Add($_Report)

    }

    end 
	{

		$_InterconnectReport | % {

			$_.PSObject.TypeNames.Insert(0,'HPOneView.FirmwareReport')

		}

        Return $_InterconnectReport

    }

}

function Show-HPOVUtilization
{


}

#######################################################
# Storage Systems and Volume Management:
#

function Get-HPOVStorageSystem 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding(DefaultParameterSetName = "Name")]
    Param 
	(

        [parameter(Mandatory = $false, HelpMessage = "Enter the Storage System name.", ParameterSetName = "Name", Position = 0)]
        [ValidateNotNullOrEmpty()]
        [Alias('Name')]
        [string]$SystemName,

        [parameter(Mandatory = $false, HelpMessage = "Enter the Storage System serial number.", ParameterSetName = "Serial",Position=0)]
        [ValidateNotNullOrEmpty()]
        [Alias('SN')]
        [string]$SerialNumber,

		[parameter(Position = 1, Mandatory = $false)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions},

        [parameter(Mandatory = $false, HelpMessage = "Display output in Table List format.", ParameterSetName = "Name")]
        [parameter(Mandatory = $false, HelpMessage = "Display output in Table List format.", ParameterSetName = "Serial")]
        [Alias('Report')]
        [switch]$List

    )

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		if  ($ApplianceConnection.Count -eq 0)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoAuthSessionFound InvalidArgument 'ApplianceConnection' -Message 'No ApplianceConnections were found.  Please use Connect-HPOVMgmt to establish an appliance connection.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		$c = 0
		
		ForEach ($_connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_StorageSystemCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{

			$uri = $script:storageSystemUri

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($Connection.Name)' Appliance (of $($Appliance.Count))"

			if ($SystemName)
			{ 

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Filtering for systemName property"
				
				$SystemName = $SystemName -replace ("[*]","%25") -replace ("[&]","%26") 

				$uri += "?filter=name matches $SystemName'"
						
			}

			elseif ($SerialNumber) 
			{ 

			    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Filtering for serialNumber property"
			    
				$uri += "?filter=serialNumber='$SerialNumber'"
			    
			}

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting list of Storage Systems"

			Try
			{

				$_StorageSystems = Send-HPOVRequest $uri -Hostname $_Connection

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			#Generate Terminating Error if resource not found
			if (-not $_StorageSystems.members.Count -gt 0 -and ($SystemName -or $SerialNumber)) 
			{
			    
			    if ($SystemName) 
				{ 
			        
			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Woops! No '$SystemName' Storage System found."
			            
			        $errorRecord = New-ErrorRecord HPOneView.StorageSystemResourceException StorageSystemResourceNotFound ObjectNotFound 'SystemName' -Message "No Storage System with '$SystemName' system name found.  Please check the name or use Add-HPOVSanManager to add the Storage System."

			    }

			    elseif ($SerialNumber) 
				{ 
			        
			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Woops! No Storage System with '$SerialNumber' serial number found."
			            
			        $errorRecord = New-ErrorRecord HPOneView.StorageSystemResourceException StorageSystemResourceNotFound ObjectNotFound 'SerialNumber' -Message "No Storage System with '$SerialNumber' serial number found.  Please check the serial number or use Add-HPOVSanManager to add the Storage System."

			    }
                    
			    #Generate Terminating Error
			    $PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			$_StorageSystems.members | % {

				$_.PSObject.TypeNames.Insert(0,'HPOneView.Storage.System')

				[void]$_StorageSystemCollection.Add($_)

			}		

		}
		 
    }

    end 
	{

		Write-Verbose "Done. $($_StorageSystemCollection.count) storage system(s) found."

        if ($List) 
		{

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Generating List display"

            foreach ($_system in $_StorageSystemCollection) 
			{
                
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_system.name)' Storage System."
                
                #Storage System Details
                $a = @{Expression={$_.status};Label="Status"},
                     @{Expression={$_.name};Label="Name"},
                     @{Expression={$_.serialNumber};Label="Serial Number"},
                     @{Expression={$_.model};Label="Model"},
                     @{Expression={$_.managedDomain};Label="Storage Domain"},
                     @{Expression={$_.wwn};Label="WWN"},
                     @{Expression={$_.firmware};Label="Firmware"}

                #Storage System Credentials and Address
                $b = @{Expression={"   "};Label="[Credentials]"},
                     @{Expression={$_.credentials.username};Label="Username"},
                     @{Expression={$_.credentials.ip_hostname};Label="Address"}				
 
                #Capacity Details
                $c = @{Expression={"   "};Label="[Capacity]"},
                     @{Expression={$_.status};Label="Status"},
                     @{Expression={'{0:N2}TB' -f ($_.totalCapacity / 1TB)};Label="Total   "},
                     @{Expression={'{0:N2}TB' -f ($_.allocatedCapacity / 1TB)};Label="Allocated  "},
                     @{Expression={'{0:N2}TB' -f ($_.freeCapacity / 1TB)};Label="Free   "}
                
                #Managed Storage Pools
                $d = @{Expression={"   "};Label="[Managed Storage Pools]"},
                     @{Expression={$_.status};Label="Status"},
                     @{Expression={$_.name};Label="Name   "},
                     @{Expression={$_.deviceType};Label="Drive Type"},
                     @{Expression={$_.supportedRAIDLevel};Label="RAID"},
                     @{Expression={'{0:N2}TB' -f ($_.totalCapacity / 1GB)};Label="Total   "},
                     @{Expression={'{0:N2}TB' -f ($_.allocatedCapacity / 1GB)};Label="Allocated  "},
                     @{Expression={'{0:N2}TB' -f ($_.freeCapacity / 1GB)};Label="Free   "},
                     @{Expression={ (Send-HPOVRequest ($script:indexUri + "?category=storage-volumes&query=storage_volume_storagepool_uri:'$($_.uri)'") -Hostname $_system.ApplianceConnection.Name).count};Label="Volumes"}

                #Unmanaged Pools
                $e = @{Expression={"   "};Label="[Unmanaged Storage Pools]"},
                     @{Expression={$_.name};Label="Name   "},
                     @{Expression={$_.deviceType};Label="Drive Type"},
                     @{Expression={$_.supportedRAIDLevel};Label="RAID"},
                     @{Expression={'{0:N2}GB' -f ($_.totalCapacity / 1GB)};Label="Total   "},
                     @{Expression={'{0:N2}GB' -f ($_.allocatedCapacity / 1GB)};Label="Allocated  "},
                     @{Expression={'{0:N2}GB' -f ($_.freeCapacity / 1GB)};Label="Free   "}

                $unmanagedPools = $system.unmanagedPools | ? { $_.domain -eq $system.managedDomain }

                

                #Configured Host Ports
                $f = @{Expression={"   "};Label="[Host Ports]"},
                     @{Expression={$_.status};Label="Status"},
                     @{Expression={$_.portName};Label="Port"},
                     @{Expression={$_.portWwn};Label="WWPN"},
                     @{Expression={
                         $net = send-hpovrequest $_.expectedNetworkUri -Hostname $_system.ApplianceConnection.Name
                         "$($net.name) ($(if ($net.fabricType -eq "FabricAttach") {"FA"}
                                          else {"DA"}))"
                     };Label="Expected Network"},
                     @{Expression={
                         $net = send-hpovrequest $_.actualNetworkUri -Hostname $_system.ApplianceConnection.Name
                         "$(if ($net.name) {$net.name} else { "None" }) ($(if ($net.fabricType -eq "FabricAttach") {"FA"}
                                          else {"DA"}))"
                     };Label="Actual Network"},
                     @{Expression={$_.groupName};Label="Port Group Name"}

				$_system | format-table $a -autosize -wrap
                $_system | format-table $b -autosize -wrap
                $_system | format-table $c -autosize -wrap
                $_system.managedPools | sort-object 'Name' | format-table $d -autosize -wrap

				if ($unmanagedPools) 
				{ 
					
					$unmanagedPools | sort-object 'Name' | format-table $e -autosize -wrap 
				
				}

                else 
				{
					 
                    ""
                    "[Unmanaged Storage Pools] Name     Drive Type RAID  Total          Allocated   Free"
                    "------------------------- -------  ---------- ----  --------       ----------- -------"
                    "No unmanaged pools available in '{0}' Managed Domain" -f $system.managedDomain 
                    ""
                    ""
                
				}

                $_system.managedPorts | sort-object 'Port' | format-table $f -autosize -wrap

                if ($_StorageSystems.count -gt 1) 
				{

                    "=================================================================================================================="
                    ""
                }
                                
            }

        }

        else 
		{
        
            Return $_StorageSystemCollection
        
		}

    }

}

function Update-HPOVStorageSystem 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding(DefaultParameterSetName = "Default")]
    Param 
	(

        [parameter(Mandatory = $false, ValueFromPipeLine = $True, HelpMessage = "Enter the Storage System name.", ParameterSetName = "Default", Position = 0)]
        [ValidateNotNullOrEmpty()]
        [Alias('Name')]
        [Object]$StorageSystem,
		
		[parameter(Position = 1, ValueFromPipelineByPropertyName, Mandatory, ParameterSetName = "Default")]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Object]$ApplianceConnection

    )

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		#Key off of ApplianceConnection for Pipeline Input
		if (-not($PSBoundParameters['ApplianceConnection']))
		{

			$PipelineInput = $True

		}

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if (-not($ApplianceConnection -is [HPOneView.Appliance.Connection]) -and (-not($ApplianceConnection -is [System.String])) -and (-not($PipelineInput)))
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException InvalidApplianceConnectionDataType InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter is not type [HPOneView.Appliance.Connection] or [System.String].  Please correct this value and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif (($ApplianceConnection | Measure-Object).Count -gt 1 -and (-not($PipelineInput)))
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException MultipleApplianceConnections InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter contains multiple Appliance Connections.  This CMDLET only supports 1 Appliance Connection in the ApplianceConnect parameter value.  Please correct this and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif (-not($PipelineInput))
		{

			Try 
			{
	
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError 'ApplianceConnection' -TargetType $ApplianceConnection.GetType().Name -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_.Exception)

			}

		}

		$_StorageSystemRefreshCollection = New-OBject System.Collections.ArrayList
    
    }

    process 
	{ 

        if (-not ($StorageSystem)) 
		{ 
            
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No Storage System resource(s) provided. Calling Get-HPOVStorageSystem."

			Try
			{

				$StorageSystem = Get-HPOVStorageSystem 

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}
            
            
			"[$($MyInvocation.InvocationName.ToString().ToUpper())] Found {{0}} Storage Systems." -f $StorageSystem.count | Write-Verbose
        
        }

        ForEach ($_system in $StorageSystem) 
		{

            switch ($_system.gettype().name) 
			{

                "String" 
				{ 
                    

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] System Name was provided, calling Get-HPOVStorageSystem."

					Try
					{

						$_system = Get-HPOVStorageSystem $_system

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}
                    
                }

                "PSCustomObject" 
				{
                
                    if ($_system.category -eq "storage-systems") 
					{
                    
                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Storage System resource object provided"
                        "[$($MyInvocation.InvocationName.ToString().ToUpper())] Storage System Name: {0}" -f $_system.name | Write-Verbose
                        "[$($MyInvocation.InvocationName.ToString().ToUpper())] Storage System URI: {0}"  -f $_system.uri  | Write-Verbose

                    }

                    else 
					{

                        #Wrong category, generate error
                        $errorRecord = New-ErrorRecord HPOneView.StorageSystemResourceException WrongCategoryType InvalidResult 'StorageSystem' -TargetType 'PSObject' -Message ("The '{0}' is the wrong value.  Only 'storage-systems' category is allowed.  Please check the value and try again." -f $_system.category)#-verbose
                        $PSCmdlet.ThrowTerminatingError($errorRecord)

                    }

                }

                default 
				{                         
                    
                    #Wrong category, generate error
                    $errorRecord = New-ErrorRecord HPOneView.StorageSystemResourceException UnsupportedDataType InvalidArgument 'StorageSystem' -TargetType $_system.GetType().Name -Message ("The {0} is unsupported.  Only [System.String], [System.Array] of [System.String] or [System.Management.Automation.PSCustomObject] are allowed.  Please check the value and try again." -f $_system.Gettype().Name )
                    $PSCmdlet.ThrowTerminatingError($errorRecord)
                        
                }

            }

			#Update object to refresh state
            $_system.refreshState = "RefreshPending"

			Try
			{

				$_results = Send-HPOVRequest $_system.uri PUT $_system -Hostname $_system.ApplianceConnection.Name

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}
            
			[void]$_StorageSystemRefreshCollection.Add($_results)

        }
   
    }

    end 
	{

        Return $_StorageSystemRefreshCollection

    }

}

function Add-HPOVStorageSystem 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding()]
    Param 
	(

        [parameter(Mandatory = $true, position = 0, HelpMessage = "Enter the host name (FQDN) or IP of the Storage System.")]
        [ValidateNotNullOrEmpty()]
        [string]$hostname,
         
        [parameter(Mandatory = $true, position = 1, HelpMessage = "Enter the administrative user name (i.e. 3paradm).")]
        [ValidateNotNullOrEmpty()]
        [string]$username = $null,

        [parameter(Mandatory = $true, position = 2, HelpMessage = "Enter the administrative account password (i.e. 3pardata).")]
        [ValidateNotNullOrEmpty()]
        [string]$password = $null,

        [parameter(Mandatory = $false, position = 3, HelpMessage = "Specify the HP 3PAR Virtual Domain Name to Import resources from.")]
        [ValidateNotNullOrEmpty()]
        [String]$Domain = 'NO DOMAIN',

        [parameter(Mandatory = $false, position = 4, HelpMessage = 'Specify the Host Ports and Expected Network in an Array of PSCustomObject entries. Example: @{"1:1:1"="Fabric A";"2:2:2"="Fabric B"}')]
        [ValidateNotNullOrEmpty()]
        [PsCustomObject]$Ports,

		[parameter(Mandatory = $false, position = 5, HelpMessage = 'Specify the Host Ports and Expected Network in an Array of PSCustomObject entries. Example: @{"1:1:1"="PG_1";"2:2:2"="Fabric B"}')]
        [ValidateNotNullOrEmpty()]
        [Hashtable]$PortGroups,

		[parameter(Mandatory = $false, ParameterSetName = "Name")]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

    )

    Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$colStatus = New-Object System.Collections.ArrayList

    }
     
    Process 
	{

		ForEach ($_appliance in $ApplianceConnection)
		{
		
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing appliance: $($_appliance.Name)"

			$_storagesystemcredentials = NewObject -StorageSystemCredentials

			$_storagesystemcredentials.ip_hostname = $hostname
			$_storagesystemcredentials.username    = $username
			$_storagesystemcredentials.password    = $password


			Try
			{

				$_storageSystemDiscoveryTask = Send-HPOVRequest $storageSystemUri POST $_storagesystemcredentials -Hostname $_appliance.Name | Wait-HPOVTaskComplete

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}			

			if ($_storageSystemDiscoveryTask.taskState -eq "Completed") 
			{

				Try
				{
					
					$_connectedStorageSystem = Send-HPOVRequest $_storageSystemDiscoveryTask.associatedResource.resourceUri -Hostname $_appliance.Name
			    
				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}		

				"[$($MyInvocation.InvocationName.ToString().ToUpper())] Connected Storage System Object: {0}" -f ($_connectedStorageSystem | ConvertTo-Json -Depth 99 -Compress) | Write-Verbose

			    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_connectedStorageSystem.name)' Storage System."

				$_connectedStorageSystem.PSObject.TypeNames.Insert(0,'HPOneView.Storage.System')

				#Display Storage System details
				$_connectedStorageSystem | Out-Host
				
				if ($_connectedStorageSystem.unmanagedPools)
				{

					$_connectedStorageSystem.unmanagedPools | % { 
						
						$_.PSObject.TypeNames.Insert(0,'HPOneView.Storage.System.Pool') 

					}

					#Display Storage System Unmanaged Pool details
					$_connectedStorageSystem.unmanagedPools | Sort domain,name | Out-Host

				}

				if ($_connectedStorageSystem.unmanagedPorts)
				{

					$_connectedStorageSystem.unmanagedPorts | % { 
						
						#This is temporary
						Add-Member -InputObject $_ -NotePropertyName ApplianceConnection -NotePropertyValue $_connectedStorageSystem.ApplianceConnection

						$_.PSObject.TypeNames.Insert(0,'HPOneView.Storage.System.Port') 

					}

					#Display Storage System Unmanaged Port details
					$_connectedStorageSystem.unmanagedPorts | Out-Host

					#remove the noteproperty as it will mess up the PUT call later.
					$_connectedStorageSystem.unmanagedPorts = $_connectedStorageSystem.unmanagedPorts | Select * -ExcludeProperty ApplianceConnection

				}

			    #Handle Host Port configuration
			    if (-not($PSBoundParameters['Ports']))
				{

			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Ports parameter was not provided.  Using Default values."

			        $_managedPorts   = New-Object System.Collections.ArrayList
					$_unmanagedPorts = New-Object System.Collections.ArrayList

			        "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing {0} unmanaged ports." -f $_connectedStorageSystem.unmanagedPorts.count | Write-Verbose 

			        #Loop through all ports, looking for actualNetworkUri property set.
			        foreach ($_port in $_connectedStorageSystem.unmanagedPorts) 
					{

			            $_StoragePort = NewObject -StorageSystemManagedPort

						$_StoragePort.portName     = $_port.portName
						$_StoragePort.name         = $_port.name
						$_StoragePort.portWwn      = $_port.portWwn
						$_StoragePort.protocolType = $_port.protocolType

						if ($PSBoundParameters['PortGroups'])
						{

							if ($PortGroups.Get_Item($_port.portName))
							{

								"[$($MyInvocation.InvocationName.ToString().ToUpper())] Found '{0}' Port Group for '{1}' port." -f $PortGroups.Get_Item($_port.portName), $_port.portName | Write-Verbose

								$_StoragePort.groupName = $PortGroups.Get_Item($_port.portName)

							}

						}
    	
			            if ('unknown','none' -contains $_port.actualNetworkUri)
						{
							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Un-ManagedPort: $($_StoragePort | out-string)"

							[void]$_unmanagedPorts.Add($_StoragePort)	

			            }

						#IS a Managed Port
			            #If $Ports parameter was not passed, take the discovered Actual Network URI and default
						else
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] actualNetworkUri contains value for port '$($_port.name)'"

			                $_StoragePort.actualNetworkUri   = $_port.actualNetworkUri
			                $_StoragePort.expectedNetworkUri = $_port.actualNetworkUri

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] ManagedPort: $($_StoragePort | out-string)"

							[void]$_managedPorts.Add($_StoragePort)		  

						}

			        }

			        if ($_managedPorts.Count -eq 0) 
					{ 
			        
			            #Output warning or non-terminating error?
			            write-warning "No storage system ports have an expected network value.  Unable to assign Host Ports to FC/FCoE Network(s)."

			        }

			    }

			    #If user provided the ports
			    else
				{

			        $_managedPorts   = New-Object System.Collections.ArrayList
					#$_unmanagedPorts = New-Object System.Collections.ArrayList

			        ForEach ($_port in $Ports.GetEnumerator())
					{

						[Array]$_unmanagedPorts = @()

						"[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '{0}' Port" -f $_port.name | Write-Verbose

			            # First get the network.  Will error if network does not exist
						Try
						{

							$_sNet = Get-HPOVNetwork -type fc -name $_port.value -ApplianceConnection $_appliance.Name

						}

						Catch
						{

							$PSCmdlet.ThrowTerminatingError($_)

						}

			            #if the network exists, get the port from unmanaged ports list
			            $_tempPort = $_connectedStorageSystem.unmanagedPorts | ? portName -eq $_port.name

			            #update the ports Expected SAN/Network property
			            $_tempPort.expectedNetworkUri  = $_sNet.uri
						$_tempPort.expectedNetworkName = $_sNet.name

						if ($PSBoundParameters['PortGroups'])
						{

							if ($PortGroups.Get_Item($_port.name))
							{

								"[$($MyInvocation.InvocationName.ToString().ToUpper())] Found '{0}' Port Group for '{1}' port." -f $PortGroups.Get_Item($_port.name), $_port.name | Write-Verbose

								$_tempPort.groupName = $PortGroups.Get_Item($_port.name)

							}

							else
							{

								$errorRecord = New-ErrorRecord InvalidOperationException NoPortGroupFoundForPort ObjectNotFound 'PortGroups' -Message ("No associated Port Group found in -PortGroups for '{0}' port.  Please check the input values and try again." -f $_port.name)
								$PSCmdlet.ThrowTerminatingError($errorRecord)

							}

						}

						else
						{

							"[$($MyInvocation.InvocationName.ToString().ToUpper())] Setting 'auto' Port Group for '{0}' port." -f $_port.name | Write-Verbose

							$_tempPort.groupName = "Auto"

						}

			            #add the port to the managed ports list
			            [void]$_managedPorts.Add($_tempPort)

			            #remove the port from the unmanaged ports list
			            [Array]$_unmanagedPorts = ($_connectedStorageSystem.unmanagedPorts | ? portName -ne $_port.name)

						$_connectedStorageSystem.unmanagedPorts = $_unmanagedPorts

			        }

			    }
			        
			    #update managed ports list
			    $_connectedStorageSystem.managedPorts   = $_managedPorts
				$_connectedStorageSystem.unmanagedPorts = $_unmanagedPorts

			    "[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding {0} managed ports. {1} remaining unmanaged ports to be claimed later." -f $_managedPorts.count,$_connectedStorageSystem.unmanagedPorts.count | Write-Verbose 

			    #Validate the $Domain parameter exists in the list of unmanaged domains returned in the connect call
			    if ($_connectedStorageSystem.unmanagedDomains -contains $Domain)				
				{

			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Found Virtual Domain '$Domain'."

			        #The domain exists, update the managedDomain property
			        $_connectedStorageSystem.managedDomain = $Domain

			        #remove the domain from the unManagedDomains property
			        $_unManaged = $_connectedStorageSystem.unmanagedDomains | ? { $_ -ne $Domain }

			        [Array]$_connectedStorageSystem.unmanagedDomains = @($_unManaged)

			    }

			    else 
				{

			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Domain '$Domain' not found. Cleaning up."

					Try
					{

						$reply = Send-HPOVRequest -uri $_connectedStorageSystem.uri -method DELETE -Hostname $_appliance.Name

					}
			        
					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}		

			        $errorRecord = New-ErrorRecord InvalidOperationException StorageDomainResourceNotFound ObjectNotFound 'Domain' -Message "Storage Domain '$Domain' not found.  Please check the storage domain exist on the storage system."
			        $PSCmdlet.ThrowTerminatingError($errorRecord)

			    }

			}

			else 
			{

			    #ERROR
			    $_connectedStorageSystem | Out-Host

				if ($_storageSystemDiscoveryTask.taskErrors.errorCode -eq 'STRM_RESOURCE_ALREADY_PRESENT')
				{

					"[$($MyInvocation.InvocationName.ToString().ToUpper())] {0} {1} {2}" -f  $_storageSystemDiscoveryTask.taskErrors.details, $_storageSystemDiscoveryTask.taskErrors.recommendedActions, $_storageSystemDiscoveryTask.taskErrors.errorCode| Write-Verbose

					$errorRecord = New-ErrorRecord InvalidOperationException $_storageSystemDiscoveryTask.taskErrors[0].errorCode InvalidResult 'StoragSystem' -Message $_storageSystemDiscoveryTask.taskErrors[0].message
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				else
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Task error occurred. Cleaning Up."

					Try
					{

						$reply = Send-HPOVRequest -uri $_connectedStorageSystem.uri -method DELETE -Hostname $_appliance.Name

					}
			        
					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}		

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Generating error message."
			    
					$errorRecord = New-ErrorRecord InvalidOperationException $_storageSystemDiscoveryTask.taskErrors[0].errorCode InvalidResult 'Add-HPOVStorageSystem' -Message "$($_storageSystemDiscoveryTask.taskErrors[0].message)"
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

			}

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request to finalize adding Storage System to appliance"

			Try
			{

				$task = Send-HPOVRequest -method PUT -body $_connectedStorageSystem -uri $_connectedStorageSystem.uri -Hostname $_appliance.Name

			}

			Catch
			{
				
				$task = $null
				
				$PSCmdlet.ThrowTerminatingError($_)

			}			

			[void]$colStatus.Add($task)

		}
        
    }

    end 
	{

        return $colStatus

    }
   
}

function Remove-HPOVStorageSystem 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "default",SupportsShouldProcess = $True,ConfirmImpact = 'High')]
    Param 
	(

        [parameter (Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = "default", HelpMessage = "Enter the Storage System to remove.", Position = 0)]
        [ValidateNotNullOrEmpty()]
        [Alias("uri","name")]
        [object]$StorageSystem,

        [parameter(Mandatory = $false)]
        [switch]$force,
	
		[parameter(Mandatory = $False, ValueFromPipelineByPropertyName, ParameterSetName = "ApplianceRequired", position = 1)]
		[Alias('Appliance')]
		[Object]$ApplianceConnection = $Null

    )

    Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] {

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		if (-not($PSBoundParameters['StorageSystem'])) { $PipelineInput = $True }

		$_TaskCollection = New-Object System.Collections.ArrayList
		$_StorageSystemCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{

        if ($PipelineInput) 
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Pipeline input"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Storage System Object provided: $($StorageSystem | FL * | Out-String)"

			If ('storage-systems' -contains $StorageSystem.category)
			{

				If (-not($StorageSystem.ApplianceConnection))
				{

					$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument "StorageSystem:$($StorageSystem.Name)" -TargetType PSObject -Message "The Storage System resource object provided is missing the source ApplianceConnection property.  Please check the object provided and try again."
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				[void]$_StorageSystemCollection.Add($StorageSystem)

			}

			else
			{

				$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument "StorageSystem:$($StorageSystem.Name)" -TargetType PSObject -Message "The Storage System resource object is not an expected category type [$($StorageSystem.category)].  The allowed resource category type is 'storage-systems'.  Please check the object provided and try again."
                $PSCmdlet.ThrowTerminatingError($errorRecord)

			}

		}

		else 
		{

			ForEach ($_Connection in $ApplianceConnection)
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Appliance $($_Connection.Name) (of $($ApplianceConnection.Count))"

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Storage System Name $($StorageSystem)"

				Try
				{

					$_StorageSystem = Get-HPOVStorageSystem $StorageSystem -ApplianceConnection $_Connection

					$_StorageSystem | % {

						[void]$_StorageSystemCollection.Add($_)

					}

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}				

			}

		}

	}

	End
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing $($_StorageSystemCollection.count) Storage System object resources to remove."

		#Process Storage Resources
		ForEach ($_storagesystem in $_StorageSystemCollection)
		{

			if ($pscmdlet.ShouldProcess($_storagesystem.ApplianceConnection.Name,"Remove Storage System '$($_storagesystem.name)' from appliance")) 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Removing Storage System '$($_storagesystem.name)' from appliance '$($_storagesystem.ApplianceConnection.Name)'."

				if ($PSboundParameters['force'])
				{

					$_storagesystem.uri += "?force=true"

				}

				Try
				{

					$_resp = Send-HPOVRequest $_storagesystem.Uri DELETE -Hostname $_storagesystem.ApplianceConnection.Name

					[void]$_TaskCollection.Add($_resp)

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

			}

			elseif ($PSBoundParameters['WhatIf'])
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] WhatIf parameter was passed."

			}

		}

		Return $_TaskCollection

      }

}

function Get-HPOVStoragePool 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding(DefaultParameterSetName = "Name")]
    Param 
	(

        [parameter(Mandatory = $false, HelpMessage = "Enter the Storage Pool name.", ParameterSetName = "Name", Position = 0)]
        [ValidateNotNullOrEmpty()]
        [Alias('pool', 'PoolName')]
        [string]$Name,

        [parameter(Mandatory = $false, ValueFromPipeline, HelpMessage = "Enter the Storage System Name or provide the Resource Object.", ParameterSetName = "Name", Position = 1)]
        [ValidateNotNullOrEmpty()]
        [Alias('systemName', 'system')]
        [object]$StorageSystem,

		[parameter(Mandatory = $false, ValueFromPipelinebyPropertyName, ParameterSetName = "Name")]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

    )

    Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$colStoragePools = New-Object System.Collections.ArrayList

    }

    Process 
	{

		#Check if StorageSystem is a PSCustomObject
		if ($StorageSystem -is [PSCustomObject] -and $StorageSystem.category -eq 'storage-systems')
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] StorageSystem Object provided.  Using ApplianceConnection property of object."

			$ApplianceConnection = $StorageSystem.ApplianceConnection

		}

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Appliance Connection: $($_Connection.Name)"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting list of Storage Pools"

			$uri = $script:storagePoolUri

			if ($PSBoundParameters['Name'])
			{
			
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] -poolName was provided.  Filtering for '$Name'"

				$Name = $Name -replace ("[*]","%25") -replace ("[&]","%26")

				$uri += "?filter=name matches '$Name'"

			}

			#Send the query
			Try
			{

				$_storagePools = Send-HPOVRequest $uri -ApplianceConnection $_Connection.Name

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}
			
			if ($PSBoundParameters['StorageSystem'])
			{

				if ($StorageSystem -is [String] -and (-not($storageSystem.startswith($script:storageSystemUri))))
				{ 
        
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] StorageSystem Name was provided."

					Try
					{

						$StorageSystem = Get-HPOVStorageSystem -SystemName $StorageSystem -ApplianceConnection $_Connection.Name

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}
			
					if (-not($_storagesystem.uri))
					{
                
						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Storage system $StorageSystem does not exist on the appliance"
            
						$errorRecord = New-ErrorRecord InvalidOperationException StorageSystemResourceNotFound ObjectNotFound 'StorageSystem' -Message "Storage system '$StorageSystem' not found.  Please check the name and try again."

						#Generate Terminating Error
						$PSCmdlet.ThrowTerminatingError($errorRecord)    

					}
             
				}

				elseif ($StorageSystem -is [PsCustomObject] -and $StorageSystem.category -eq "storage-systems") 
				{ 
        
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] StorageSystem Object provided"
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] StorageSystem Name: $($StorageSystem.name)"
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] StorageSystem Uri: $($StorageSystem.uri)"

				}

				$_storagePools.members = $_storagePools.members | ? storageSystemUri -eq $StorageSystem.uri

			}
			
			if ($_storagePools.members)
			{
			
				$_storagePools.members | % {

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding Storage System '$($_.name)' to collection"

					$_.PSObject.TypeNames.Insert(0,'HPOneView.Storage.System.Pool')

					[void]$colStoragePools.Add($_)	

				}
			
			}

		}

    }

    end 
	{

		"Done. {0} storage pool resource(s) found." -f $colStoragePools.count | write-verbose

        if ((-not($colStoragePools)) -and $PSBoundParameters['Name'])
		{
                
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Storage Pool '$Name' not found."
            
                $errorRecord = New-ErrorRecord InvalidOperationException StoragePoolResourceNotFound ObjectNotFound 'Name' -Message "Storage Pool '$Name' not found.  Please check the name and try again."

                #Generate Terminating Error
                $PSCmdlet.ThrowTerminatingError($errorRecord)    

        }

        Return $colStoragePools        

    }

}

function Add-HPOVStoragePool 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding(DefaultParameterSetName = "Default")]
    Param 
	(

        [parameter(Mandatory, ValueFromPipeline, HelpMessage = "Enter the Storage System name.", ParameterSetName = "Default", Position = 0)]
        [ValidateNotNullOrEmpty()]
        [Alias('Hostname', 'name')]
        [object]$StorageSystem,

        [parameter(Mandatory, HelpMessage = "Provide array of Storage Pool names.", ParameterSetName = "Default", Position = 1)]
        [ValidateNotNullOrEmpty()]
        [Alias('PoolName', 'spName', 'cpg')]
        [array]$Pool,

		[parameter(Mandatory = $false, ValueFromPipelineByPropertyName, ParameterSetName = "Default")]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

    )

    Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSboundParameters['StorageSystem']))
		{

			$PipelineInput = $True

		}

		else
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

			$c = 0

			ForEach ($_Connection in $ApplianceConnection) 
			{

				Try 
				{
	
					$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

				}

				Catch [HPOneview.Appliance.AuthSessionException] 
				{

					$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				Catch 
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

				$c++

			}

		}

		$colStatus = New-Object System.Collections.ArrayList

    }
     
    Process 
	{

		ForEach ($_appliance in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing appliance: $($_appliance.Name)"
		
			ForEach ($_pool in $Pool)
			{

			    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$_pool'"

			    #Validate StroageSystem parameter object
			    if ($StorageSystem -is [PSCustomObject] -and $StorageSystem.ApplianceConnection.Name -ne $_appliance.Name)
				{

					$errorRecord = New-ErrorRecord HPOneView.StoragePoolResourceException InvalidateStorageSystemApplianceConnection InvalidArgument 'StorageSystem' -TargetType 'PSObject' -Message "The -StorageSystem object does not appear to originate [$($StorageSystem.ApplianceConnection.Name)] from the same provided ApplianceConnection [$($_appliance.Name)]"
			        $PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				elseif ($StorageSystem -is [PsCustomObject] -and $StorageSystem.category -eq "storage-systems") 
				{ 

			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Storage System resource object was provided: $($StorageSystem | out-string)"
			        
			        $_StorageSystem = $StorageSystem.PSObject.Copy()
			        
			    }
			    
			    #else the PsCustomObject is not the correct Category type, so error.
			    elseif ($StorageSystem -is [PsCustomObject]) 
				{
			    
			        $errorRecord = New-ErrorRecord HPOneView.StoragePoolResourceException InvalidResourceCategoryValue InvalidArgument 'StorageSystem' -TargetType 'PSObject' -Message "The -StorageSystem parameter value is the wrong resource type ($($StorageSystem.category)). The correct resource category 'storage-systems' is allowed.  Please check the value and try again."
			        $PSCmdlet.ThrowTerminatingError($errorRecord)

			    }

			    #Do not allow an array
			    elseif ($StorageSystem -is [Array]) 
				{

			        $errorRecord = New-ErrorRecord HPOneView.StoragePoolResourceException ArrayNotAllow InvalidArgument 'StorageSystem' -TargetType 'PSObject' -Message "The -StorageSystem parameter only accepts [System.String] or [System.Management.Automation.PSCustomObject] value.  Please correct the value and try again."
			        $PSCmdlet.ThrowTerminatingError($errorRecord)

			    }

			    else 
				{

			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Storage System Name is passed $($StoragSystem)"

			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting list of Storage Systems"

			        Try
					{

						$_storagesystem = Get-HPOVStorageSystem -SystemName $StorageSystem -ApplianceConnection $_appliance.Name

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

					#Generate Terminating Error if Storage System resource not found
					if (-not($_storagesystem)) {
					        
					    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Woops! No '$StorageSystem' Storage System found."

					    $errorRecord = New-ErrorRecord HPOneView.StoragePoolResourceException StorageSystemResourceNotFound ObjectNotFound 'Add-HPOVStoragePool' -Message "No Storage System with '$StorageSystem' system name found.  Please check the name or use Add-HPOVStorageSystem to add the Storage System."
					    $PSCmdlet.ThrowTerminatingError($errorRecord)

					}
					
			    }

			    #Get the list of unmanaged and managed pools in the managed domain
			    
			    $_ump = $_storagesystem.unmanagedPools | ? domain -eq $_storagesystem.managedDomain
			    $_mp  = $_storagesystem.managedPools | ? { ($_.domain -eq $_storagesystem.managedDomain) -and ($_.name -eq $_pool) }

			    if ($_mp)
				{

			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Storage pool resource '$($_pool)' already exists in the managed list. Generating non-terminating error"

			        $errorRecord = New-ErrorRecord HPOneView.StoragePoolResourceException StoragePoolResourceExists ResourceExists 'PoolName' -Message "Storage pool resource '$_pool' already exists in the managed list."
			        $PSCmdlet.WriteError($errorRecord) #"Storage pool resource '$p' already exists"

			    }

			    elseif (-not($_ump))
				{

			        #Storage pool resource does not exist in the existing managed list or in the unmanaged list in the managed domain
			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No Storage pool resource with '$_pool' found in the managed Storage System.  Generating terminating error."

			        $errorRecord = New-ErrorRecord HPOneView.StoragePoolResourceException StorageSystemResourceNotFound ObjectNotFound 'PoolName' -Message "No Storage pool resource with '$_pool' found in the managed Storage System."
			        $PSCmdlet.ThrowTerminatingError($errorRecord)

			    }

			    else
				{

			        #Good here... Add the storage pool
			        $_addPool = [PSCustomObject]@{

			            storageSystemUri = $_storagesystem.uri;
			            poolName         = $_pool
			        
					}
			        
			        #add the pool to array of pools to manage
					Try
					{

						$_resp = Send-HPOVRequest -method POST -body $_addPool -uri $storagePoolUri -Hostname $_appliance.Name

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

					[void]$colStatus.Add($_resp)
			        
			    }

			}

		}

    }

    end  
	{

        write-verbose "END Block"

        Return $colStatus

    }

}

function Remove-HPOVStoragePool 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "default",SupportsShouldProcess = $True,ConfirmImpact = 'High')]
    Param
    (
        [parameter (Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = "default",HelpMessage = "Specify the storage pool to remove.",Position=0)]
        [parameter (Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = "StorageSystem",HelpMessage = "Specify the storage pool to remove.",Position=0)]
        [ValidateNotNullOrEmpty()]
        [Alias("uri", "name")]
        [Object]$StoragePool = $null,

        [parameter (Mandatory = $true, ValueFromPipeline = $false, ParameterSetName = "StorageSystem",HelpMessage = "Specify the Storage System Name, URI or Resource Object where the Storage Pool is located to remove.",Position=1)]
        [ValidateNotNullOrEmpty()]
        [Alias("storage")]
        [Object]$StorageSystem = $null,
		
		[parameter (Mandatory = $false)]
		[switch]$Force,
	
		[parameter(Mandatory = $False, ValueFromPipelineByPropertyName, ParameterSetName = "default")]
		[Alias('Appliance')]
		[Object]$ApplianceConnection = $Null

    )

    Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		if (-not($PSBoundParameters['StoragePool'])) { $PipelineInput = $True }

		$_TaskCollection        = New-Object System.Collections.ArrayList
		$_StoragePoolCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{

        if ($PipelineInput) 
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Pipeline input"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Storage Pool Object provided: $($StoragePool | FL * | Out-String)"

			If ('storage-pools' -contains $StoragePool.category)
			{

				If (-not($StoragePool.ApplianceConnection))
				{

					$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument "StoragePool:$($StoragePool.Name)" -TargetType PSObject -Message "The Storage Pool resource object provided is missing the source ApplianceConnection property.  Please check the object provided and try again."
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				[void]$_StoragePoolCollection.Add($StoragePool)

			}

			else
			{

				$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument "StoragePool:$($StoragePool.Name)" -TargetType PSObject -Message "The Storage Pool resource object is not an expected category type [$($StoragePool.category)].  The allowed resource category type is 'storage-pools'.  Please check the object provided and try again."
                $PSCmdlet.ThrowTerminatingError($errorRecord)

			}

		}

		else 
		{

			ForEach ($_Connection in $ApplianceConnection)
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Appliance $($_Connection.Name) (of $($ApplianceConnection.Count))"

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Storage Pool Name $($StoragePool)"

				Try
				{

					$_StoragePool = Get-HPOVStoragePool $StoragePool -ApplianceConnection $_Connection

					$_StoragePool | % {

						[void]$_StoragePoolCollection.Add($_)

					}

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}				

			}

		}

    }

    end 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing $($_StoragePoolCollection.count) Storage Pool object resources to remove."

		#Process Storage Resources
		ForEach ($_storagepool in $_StorageSystemCollection)
		{

			if ($pscmdlet.ShouldProcess($_storagepool.ApplianceConnection.Name,"Remove Storage Pool '$($_storagepool.name)' from appliance")) 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Removing Storage Pool '$($_storagepool.name)' from appliance '$($_storagepool.ApplianceConnection.Name)'."

				if ($PSboundParameters['force'])
				{

					$_storagepool.uri += "?force=true"

				}

				Try
				{

					$_resp = Send-HPOVRequest $_storagepool.Uri DELETE -Hostname $_storagepool.ApplianceConnection.Name

					[void]$_TaskCollection.Add($_resp)

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

			}

			elseif ($PSBoundParameters['WhatIf'])
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] WhatIf parameter was passed."

			}

		}

		Return $_TaskCollection

    }

}

function Get-HPOVStorageVolumeTemplate 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding()]
    Param 
	(

        [parameter(Position = 0, Mandatory = $false, HelpMessage = "Enter the Volume template name.")]
        [ValidateNotNullOrEmpty()]
        [Alias('TemplateName')]
        [string]$Name,

        [parameter(Mandatory = $False, ValueFromPipelineByPropertyName)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

    )

    Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

        ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
            {
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
            {

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
            {

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		if (-not($PSBoundParameters['StoragePool'])) { $PipelineInput = $True }

		$_StorageVolumeTemplateCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{ 

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing $($_Connection.Name) Appliance Connection [of $($ApplianceConnection.Count)]"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting list of Storage Volume Templates"

			Try
			{

				$_StorageVolumeTemplates = Send-HPOVRequest $script:storageVolumeTemplateUri -Hostname $_Connection

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			if ($PSBoundParameters['Name']) 
			{ 
				
				$_StorageVolumeTemplates.members = $_StorageVolumeTemplates.members | ? name -eq $Name
			
			}

			#Generate Terminating Error if resource not found
			if (-not($_StorageVolumeTemplates.members) -and $Name)
			{
                
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] '$_StorageVolumeTemplates' Storage Volume Template not found."
                    
				$errorRecord = New-ErrorRecord InvalidOperationException StorageVolumeResourceNotFound ObjectNotFound 'Name' -Message "No Storage Volume with '$Name' name found.  Please check the name or use New-HPOVStorageVolumeTemplate to create the volume template."

				#Generate Terminating Error
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			elseif (-not($_StorageVolumeTemplates)) 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No Storage Volume Templates found."

			}

			else
			{

				$_StorageVolumeTemplates.members | % {

					$_.PSObject.TypeNames.Insert(0,'HPOneView.Storage.VolumeTemplate')

					[void]$_StorageVolumeTemplateCollection.Add($_)

				}

			}

		}

	}

	End
	{

		Return $_StorageVolumeTemplateCollection
    
    }

}

function New-HPOVStorageVolumeTemplate 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding(DefaultParameterSetName = "default")]
    Param 
	(

        [parameter(Mandatory = $true, HelpMessage = "Enter the Volume Template Name.", ParameterSetName = "default")]
        [ValidateNotNullOrEmpty()]
        [Alias('templateName')]
        [string]$Name,

        [parameter(Mandatory = $false, ParameterSetName = "default")]
        [ValidateNotNullOrEmpty()]
		[string]$Description = $null,

        [parameter(Mandatory = $true, ValueFromPipeline, HelpMessage = "Enter the Storage Pool Name, URI or provide the resource object.", ParameterSetName = "default")]
        [ValidateNotNullOrEmpty()]
		[object]$StoragePool = $Null,

		[parameter(Mandatory = $false, HelpMessage = "Enter the Storage Pool Name that will be used for snapshot storage, URI or provide the resource object.", ParameterSetName = "default")]
        [ValidateNotNullOrEmpty()]
		[object]$SnapshotStoragePool = $Null,

        [parameter(Mandatory = $false, HelpMessage = "Enter the Storage System Name, URI or provide the resource object.", ParameterSetName = "default")]
        [ValidateNotNullOrEmpty()]
		[object]$StorageSystem = $Null,

        [parameter(Mandatory = $true, HelpMessage = "Enter the requested capacity in GB.", ParameterSetName = "default")]
        [ValidateScript({$_ -ge 1})]
        [Alias("size")]
        [int64]$capacity,

        [parameter(Mandatory = $false, ParameterSetName = "default")]
        [switch]$full,

        [parameter(Mandatory = $false, ParameterSetName = "default")]
        [switch]$shared,

		[parameter(Mandatory = $true, ValueFromPipelinebyPropertyName, ParameterSetName = "default")]
		[ValidateNotNullorEmpty()]
		[object]$ApplianceConnection = $null

    )

    Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if (-not($PSboundParameters['StoragePool']))
		{

			$PipelineInput = $True

		}

		if (-not($ApplianceConnection -is [HPOneView.Appliance.Connection]) -and (-not($ApplianceConnection -is [System.String])) -and -not($PipelineInput))
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException InvalidApplianceConnectionDataType InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter is not type [HPOneView.Appliance.Connection] or [System.String].  Please correct this value and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif  ($ApplianceConnection.Count -gt 1)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException MultipleApplianceConnections InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter contains multiple Appliance Connections.  This CMDLET only supports 1 Appliance Connection in the ApplianceConnect parameter value.  Please correct this and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif (-not($PipelineInput))
		{

			Try 
			{
	
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError 'ApplianceConnection' -TargetType $ApplianceConnection.GetType().Name -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}

		$colStatus = New-Object System.Collections.ArrayList

    }

    Process 
	{

		#Build the Object
        $_svt = NewObject -StorageVolumeTemplate
		
        $_svt.name         = $Name
        $_svt.description  = $description
        
		if ([bool]$full)
		{
			
			$provisionType = "Full"
		
		}
        
		else 
		{
			
			$provisionType = "Thin"
		
		}
		
		$_svt.provisioning.provisionType = $provisionType

        #Storage Pool Name
        if ($StoragePool -is [String] -and (-not($storagePool.StartsWith($storagePoolUri))))
		{
            
            write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] StoragePool name provided as parameter value: $($StoragePool)"

            #First look for the Storage Pool.
            if ($StorageSystem -is [string]) 
			{ 

				Try
				{
					
					$StoragePool = Get-HPOVStoragePool $storagePool $StorageSystem -ApplianceConnection $ApplianceConnection

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}
				 
			}

            elseif ($StorageSystem -is [PsCustomObject])
			{ 
				
				Try
				{
					
					$StoragePool = Get-HPOVStoragePool $storagePool $StorageSystem.uri -ApplianceConnection $ApplianceConnection

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}
			
			}

            else 
			{
				
				Try
				{
					
					$StoragePool = Get-HPOVStoragePool $storagePool -ApplianceConnection $ApplianceConnection

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

			}

            #If multiple Storage Pool Resources are returned that are of the same name, generate error and indicate the -StorageSystem parameter is needed.
            #Validate that the storage pool object is unique and not a collection
            if($StoragePool -is [Array] -and (-not($StorageSystem)))
			{

                write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Multiple Storage Pool resources of the name '$tmpStoragePool'. $($storagePool.count) resources found."
                
				$errorRecord = New-ErrorRecord InvalidOperationException InvalidStoragePoolResource ObjectNotFound 'StoragePool' -TargetType 'Array' -Message "Multiple Storage Pools it the '$tmpStoragePool' name were found.  Please use the -StorageSystem parameter to specify the Storage System the Pool is associated with, or use the Get-HPOVStoragePool cmdlet to get the Storage Pool resource and pass as the -StoragePool parameter value."
                
                #Generate Terminating Error
                $PSCmdlet.ThrowTerminatingError($errorRecord)
            }

        }

        #Storage Pool URI
        elseif ($StoragePool -is [String] -and $StoragePool.StartsWith($storagePoolUri)) 
		{

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] StoragePool URI provided: $StoragePool"

			Try
			{
				
				$StoragePool = Send-HPOVRequest $StoragePool -Hostname $ApplianceConnection

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

        }

        #Storage Pool Object
        elseif ($StoragePool -is [PsCustomObject] -and $StoragePool.category -eq "storage-pools") 
		{

            write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] StoragePool resource provided."
            write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] StoragePool Name: $($StoragePool.name)"
            write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] StoragePool URI: $($StoragePool.uri)"

        }

        #PsCustomObject provided but wrong category, which would be wrong resource, so generate error
        elseif ($StoragePool -is [PsCustomObject] -and $StoragePool.category -ne "storage-pools") 
		{

            $errorRecord = New-ErrorRecord ArgumentException WrongCategoryType InvalidArgument 'StoragePool' -TargetType 'PSObject' -Message "The StoragePool resource category '$($StoragePool.category)' is not the expected value.  The resource category should be 'storage-pools'.  Please check the value and try again."
            
            #Generate Terminating Error
            $PSCmdlet.ThrowTerminatingError($errorRecord)        

        }

        #End catch and will be error if reaching this point
        else 
		{ 
        
            $errorRecord = New-ErrorRecord ArgumentException InvalidArgumentType InvalidArgument 'StoragePool' -TargetType $StoragePool.gettype().Name -Message "The StoragePool data type '$($StoragePool.gettype().fullname)' is an unsupported data type.  Only [System.String] or [System.ObjectSystem.Management.Automation.PSCustomObject] are supported date types.  Please check the value and try again."
            
            #Generate Terminating Error
            $PSCmdlet.ThrowTerminatingError($errorRecord)        
        
        }

		if ($PSboundParameters['SnapShotStoragePool'])
		{

			if ($SnapShotStoragePool -is [String] -and $SnapShotStoragePool.StartsWith($storagePoolUri))
			{

				if ($StorageSystem -is [string]) 
				{ 

					Try
					{
						
						$SnapShotStoragePool = Get-HPOVStoragePool $SnapShotStoragePool $StorageSystem -ApplianceConnection $ApplianceConnection

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}
					 
				}

				elseif ($StorageSystem -is [PsCustomObject])
				{ 
					
					Try
					{
						
						$SnapShotStoragePool = Get-HPOVStoragePool $SnapShotStoragePool $StorageSystem.uri -ApplianceConnection $ApplianceConnection

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}
				
				}

				else 
				{
					
					Try
					{
						
						$SnapShotStoragePool = Get-HPOVStoragePool $SnapShotStoragePool -ApplianceConnection $ApplianceConnection

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

				}

			}

			write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding SnapShotStoragePool resource: $($SnapShotStoragePool.name)"

			$_svt.snapshotPoolUri = $SnapShotStoragePool.uri

		}

		else 
		{

			write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No SnapShotStoragePool resource provided. Setting Snapshot Pool to: $($StoragePool.name)"

			$_svt.snapshotPoolUri = $StoragePool.uri

		}

		$_svt.storageSystemUri            = $StoragePool.storageSystemUri
		$_svt.provisioning.capacity       = [int64]($capacity * 1GB)
        $_svt.provisioning.shareable      = [bool]$shared
        $_svt.provisioning.storagePoolUri = $StoragePool.uri

        #Send the request
		Try
		{

			$_resp = Send-HPOVRequest -method POST -uri $storageVolumeTemplateUri -body $_svt -Hostname $ApplianceConnection.Name

		}

		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}
        
		[void]$colStatus.Add($_resp)

    }

	End
	{

		Return $colStatus

	}

}

function Remove-HPOVStorageVolumeTemplate 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "default",SupportsShouldProcess = $True,ConfirmImpact = 'High')]
    Param 
	(

        [parameter (Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = "default", HelpMessage = "Specify the storage pool to remove.", Position = 0)]
        [ValidateNotNullOrEmpty()]
        [Alias('uri', 'name', 'templateName')]
        [Object]$Template = $null,
	
		[parameter(Mandatory = $False, ValueFromPipelineByPropertyName, ParameterSetName = "default", position = 1)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = $Null,

		[switch]$Force
    
    )

	Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		if (-not($PSBoundParameters['Template'])) { $PipelineInput = $True }

		$_TaskCollection = New-Object System.Collections.ArrayList
		$_SVTCollection  = New-Object System.Collections.ArrayList

    }

    Process 
	{

		if ($PipelineInput) 
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Pipeline input"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] SVT Object provided: $($Template | FL * | Out-String)"

			If ($Template.category -eq 'storage-volume-templates')
			{

				If (-not($Template.ApplianceConnection))
				{

					$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument "Template:$($Template.Name)" -TargetType PSObject -Message "The Template resource provided is missing the source ApplianceConnection property.  Please check the object provided and try again."
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				[void]$_SVTCollection.Add($Template)

			}

			else
			{

				$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument "Template:$($Template.Name)" -TargetType PSObject -Message "The Template resource is not an expected category type [$($Template.category)].  Allowed resource category type is 'storage-volume-templates'.  Please check the object provided and try again."
                $PSCmdlet.ThrowTerminatingError($errorRecord)

			}

		}

		else 
		{

			foreach ($_svt in $Template) 
			{

				#SVT passed is a URI
				if (($_svt -is [String]) -and [System.Uri]::IsWellFormedUriString($_svt,'Relative')) 
				{

				    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Received URI: $($_svt)"

				    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting SVT object"

					if (($ApplianceConnection | Measure-Object).Count -gt 1)
					{

						$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException MultipleApplianceConnections InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter contains multiple Appliance Connections.  This CMDLET only supports 1 Appliance Connection in the ApplianceConnect parameter value when using a Storage Volume Template URI value.  Please correct this and try again.'
						$PSCmdlet.ThrowTerminatingError($errorRecord)

					}

					Try
					{

						$_svtObject = Send-HPOVRequest $_svt -ApplianceConnection $ApplianceConnection

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

					[void]$_SVTCollection.Add($_svtObject)

				}

				#SVT passed is the Name
				elseif (($_svt -is [string]) -and (-not($_svt.startsWith("/rest")))) 
				{

				    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Received SVT Name $($_svt)"

				    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting SVT object from Get-HPOVStorageVolumeTemplate"

					ForEach ($_Connection in $ApplianceConnection)
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$_Connection' Appliance Connection [of $($ApplianceConnection.count)]"

						Try
						{

							$_svtObject = Get-HPOVStorageVolumeTemplate $_svt -ApplianceConnection $_Connection

						}

						Catch
						{
							
							$PSCmdlet.ThrowTerminatingError($_)

						}

						$_svtObject | % {

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding '$($_.name)' SVT to collection."

							[void]$_SVTCollection.Add($_)

						}

					}

				}

				#SVT passed is the object
				elseif ($_svt -is [PSCustomObject] -and $_svt.category -ieq 'storage-volume-templates') 
				{
				    
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] SVT Object provided: $($_svt | FL * | out-string)"

					[void]$_SVTCollection.Add($_svt)
				
				}

				else 
				{

				    $errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'Template' -TargetType 'PSObject' -Message "Invalid SVT parameter: $($_svt | FL * | Out-String)"
				    $PSCmdlet.WriteError($errorRecord)

				}

			}

		}

	}

	End
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing $($_SVTCollection.count) SVT resources to remove."

		#Process SVT Resources
		ForEach ($_svtObject in $_SVTCollection)
		{

			if ($pscmdlet.ShouldProcess($_svtObject.name,"Remove SVT from appliance '$($_svtObject.ApplianceConnection.Name)'?'")) 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Removing SVT '$($_svtObject.name)' from appliance '$($_svtObject.ApplianceConnection.Name)'."

				Try
				{
					
					if ($PSBoundParameters['Force'])
					{

						$_svtObject.uri += "?force=true"

					}

					$_resp = Send-HPOVRequest $_svtObject.Uri DELETE -Hostname $_svtObject.ApplianceConnection.Name

					[void]$_TaskCollection.Add($_resp)

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

			}

			elseif ($PSBoundParameters['WhatIf'])
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] WhatIf parameter was passed."

			}

		}

		Return $_TaskCollection

	}

}

function Get-HPOVStorageVolumeTemplatePolicy 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml
    
    [CmdLetBinding(DefaultParameterSetName = "default")]
    Param 
	(
	
		[parameter(Mandatory = $False)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

	)

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_SVTPolicyCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_Connection.Name)' Appliance Connection [of $($ApplianceConnection.Count)]"
			
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting global setting value."

			Try
			{

				$_Policy = Send-HPOVRequest $applStorageVolumeTemplateRequiredPolicy -Hostname $_Connection

			}
			
			Catch
			{

				$PScmdlet.ThrowTerminatingError($_)

			}

			$_Policy.PSObject.TypeNames.Insert(0,'HPOneView.Appliance.GlobalSetting')

			[void]$_SVTPolicyCollection.Add($_Policy)

		}

    }

	End
	{

		Return $_SVTPolicyCollection

	}

}

function Set-HPOVStorageVolumeTemplatePolicy 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml
    
    [CmdLetBinding(DefaultParameterSetName = "default")]
    Param 
	(
    
        [parameter(Mandatory = $True, HelpMessage = "Enable Storage Volume Template global policy.", ParameterSetName = "Enable")]
        [switch]$Enable,
              
        [parameter(Mandatory = $True, HelpMessage = "Disable Storage Volume Template global policy.", ParameterSetName = "Disable")]
        [switch]$Disable,

		[parameter(Mandatory = $False)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}
    
    )

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_SVTPolicyCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_Connection.Name)' Appliance Connection [of $($ApplianceConnection.Count)]"

			$_request = NewObject -GlobalSetting

			$_request.name = 'StorageVolumeTemplateRequired'

			switch ($PsCmdlet.ParameterSetName) 
			{

				'Enable' 
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User requested to ENABLE the policy"

					$_request.value = 'true'

				}

				'Disable' 
				{
					
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User requested to DISABLE the policy"
					
					$_request.value = 'false'
            
				}

			}

			try
			{

				$_updatedpolicy = Send-HPOVRequest $applStorageVolumeTemplateRequiredPolicy PUT $_request -Hostname $_Connection 

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$_updatedpolicy.PSObject.TypeNames.Insert(0,'HPOneView.Appliance.GlobalSetting')

			[void]$_SVTPolicyCollection.Add($_updatedpolicy)

		}
		
    }

    end 
	{

        Return $_SVTPolicyCollection

    }

}

function Get-HPOVStorageVolume 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding(DefaultParameterSetName = "Name")]
    Param 
    (

        [parameter(Mandatory = $false, HelpMessage = "Enter the Volume name.", ParameterSetName = "Name", Position = 0)]
        [ValidateNotNullOrEmpty()]
        [Alias('Name')]
        [string]$VolumeName = $Null,

        [parameter(Mandatory = $false, HelpMessage = "Show only available storage volumes", ParameterSetName = "Name")]
        [switch]$Available,

        [parameter(Mandatory = $false)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

    )

    Begin 
    {

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0

        ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
            {
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
            {

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
            {

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}
		
		Write-Verbose -message ("ParameterSet: " + $PsCmdLet.ParameterSetName)
        
        $volumeCollection = New-Object System.Collections.ArrayList

    }

    Process 
    { 
        
        ForEach ($_Connection in $ApplianceConnection) 
        {

			if ($VolumeName)
			{


			    $VolumeName = $VolumeName -replace "[*]","%25" -replace "[?]","%26" 
			}
		    
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting list of Storage Volumes"

            if ($VolumeName -and (-not([bool]$available))) 
            { 
            
                $uri = $script:storageVolumeUri + "?filter=name matches '$VolumeName'"
                
            }
            
            elseif ($VolumeName -and [bool]$available) 
            {
            
                $uri = $script:attachableVolumesUri + "?filter=name matches '$VolumeName'"
            
            }
            
            elseif ((-not ($VolumeName)) -and [bool]$available) 
            {
            
                $uri = $script:attachableVolumesUri 
                
            }
            
            else 
            {
            
                $uri = $script:storageVolumeUri 
                
            }
            
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Query: $($uri)"

            #Send the query
			Try
			{

				$storageVolumes = Send-HPOVRequest $uri -appliance $_Connection

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

            #Generate Terminating Error if resource not found
            if (-not($storageVolumes.members))
            {
                
                if ($VolumeName) 
                { 
                    
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] '$VolumeName' Storage Volume found."
                        
                    $errorRecord = New-ErrorRecord HPOneView.StorageVolumeResourceException StorageVolumeResourceNotFound ObjectNotFound 'Get-HPOVStorageVolume' -Message "No Storage Volume with '$VolumeName' name found.  Please check the name or use New-HPOVStorageVolume to create the volume."
                    $PSCmdlet.ThrowTerminatingError($errorRecord)

                }

                else 
                {

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No Storage Volumes found."

                }
                        
            }
                
            else 
            {

		        $storageVolumes.members | % { 

                    $_.PSObject.TypeNames.Insert(0,"HPOneView.Storage.Volume") 
                    
                    [void]$volumeCollection.Add($_)
                    
                } 	

            }

            if ($Available) 
            {
            
                Write-Verbose "Done. $($storageVolumes.count) attachable storage volume(s) found on $($_Connection.name)." 
                
            }
            
            else 
            {
            
                Write-Verbose "Done. $($storageVolumes.count) storage volume(s) found on $($_Connection.name)." 
                
            }

        }

        
    }

    End 
    {

        Return $volumeCollection

    }

}

function Get-HPOVStorageVolumeSnapShot
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding()]
    Param 
    (

        [parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [ValidateNotNullOrEmpty()]
        [Alias('Name')]
        [Object]$Volume,

        [parameter(Mandatory = $false, ValueFromPipelineByPropertyName)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Object]$ApplianceConnection

    )

    Begin 
    {

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSBoundParameters['Volume']))
		{

			$PipelineInput = $true

		}

		else
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

			Try 
            {
			
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
            {

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
            {

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}
        
        $_VolumeSnapshotCollection = New-Object System.Collections.ArrayList

    }

    Process 
    { 
        
		#Generate error Volume is not an object
		if (-not($Volume -is [PSCustomObject]) -and $Volume.category -ne 'storage-volumes')
		{

			$errorRecord = New-ErrorRecord HPOneView.StorageVolumeResourceException InvalidStorageVolumeResource InvalidArgument 'Volume' -TargetType $Volume.GetType().Name -Message "The provided Volume parameter value is not a supported type or object.  Please provide a Storage Volume resource object and try again."
            $PSCmdlet.ThrowTerminatingError($errorRecord)

		}


		"[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Storage Volume: {0}" -f $Volume.name | Write-Verbose

		$uri = $Volume.uri + '/snapshots'

		#Send the query
		Try
		{

			$_VolumeSnapshots = Send-HPOVRequest $uri -appliance $Volume.ApplianceConnection.Name

		}

		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

		if (-not($_VolumeSnapshots.members))
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No Storage Volume Snapshots found."

		}
            

        else 
        {

		    $_VolumeSnapshots.members | % { 

                $_.PSObject.TypeNames.Insert(0,"HPOneView.Storage.VolumeSnapshot") 
                    
                [void]$_VolumeSnapshotCollection.Add($_)
                    
            } 	

        }

    }

    End 
    {

        Return $_VolumeSnapshotCollection

    }

}

function New-HPOVStorageVolumeSnapshot
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding()]
    Param 
    (

        [parameter(Mandatory, ValueFromPipeline)]
        [ValidateNotNullOrEmpty()]
        [Object]$Volume,

		[parameter(Mandatory = $false, Position = 0)]
		[String]$Name = '{volumeName}_{timestamp}',

		[parameter(Mandatory = $false, Position = 1)]
		[String]$Description,

        [parameter(Mandatory = $false, ValueFromPipelineByPropertyName)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Object]$ApplianceConnection

    )

    Begin 
    {

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSBoundParameters['Volume']))
		{

			$PipelineInput = $true

		}

		else
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

			Try 
            {
			
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
            {

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
            {

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}
        
        $_VolumeSnapshotCollection = New-Object System.Collections.ArrayList

    }

    Process 
    { 
        
		#Generate error Volume is not an object
		if (-not($Volume -is [PSCustomObject]) -and $Volume.category -ne 'storage-volumes')
		{

			$errorRecord = New-ErrorRecord HPOneView.StorageVolumeResourceException InvalidStorageVolumeResource InvalidArgument 'Volume' -TargetType $Volume.GetType().Name -Message "The provided Volume parameter value is not a supported type or object.  Please provide a Storage Volume resource object and try again."
            $PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		"[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Storage Volume: {0}" -f $Volume.name | Write-Verbose

		$uri = $Volume.uri + '/snapshots'

		#Send the query
		Try
		{

			$_VolSnapshot = NewObject -VolSnapshot

			$_VolSnapshot.name        = $Name
			$_VolSnapshot.description = $Description

			$_VolumeSnapshotResp = Send-HPOVRequest $uri POST $_VolSnapshot -appliance $Volume.ApplianceConnection.Name

			[void]$_VolumeSnapshotCollection.Add($_VolumeSnapshotResp)

		}

		Catch
		{

			#Return any task resources at this point, then generate error
			$_VolumeSnapshotCollection

			$PSCmdlet.ThrowTerminatingError($_)

		}

    }

    End 
    {

        Return $_VolumeSnapshotCollection

    }

}

function Remove-HPOVStorageVolumeSnapshot
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding(DefaultParameterSetName = "default", SupportsShouldProcess = $True, ConfirmImpact = 'High')]
    Param 
    (

        [parameter(Mandatory, ValueFromPipeline)]
        [ValidateNotNullOrEmpty()]
        [Object]$Snapshot,

        [parameter(Mandatory = $false, ValueFromPipelineByPropertyName)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Object]$ApplianceConnection

    )

    Begin 
    {

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSBoundParameters['Snapshot']))
		{

			$PipelineInput = $true

		}

		else
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

			Try 
            {
			
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
            {

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
            {

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}
        
        $_VolumeSnapshotCollection = New-Object System.Collections.ArrayList
		$_TaskCollection           = New-Object System.Collections.ArrayList

    }

    Process 
    { 
        
		#Generate error Snapshot is not an object or correct object
		if (-not($Snapshot -is [PSCustomObject]) -and $Snapshot.category -ne 'storage-volumes' -and (-not($Snapshot -match '/snapshots/')))
		{

			$errorRecord = New-ErrorRecord HPOneView.StorageVolumeResourceException InvalidStorageVolumeResource InvalidArgument 'Snapshot' -TargetType $Snapshot.GetType().Name -Message "The provided Volume Snapshot parameter value is not a supported type or object.  Please provide a Storage Volume Snapshot resource object and try again."
            $PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		"[$($MyInvocation.InvocationName.ToString().ToUpper())] Received Storage Volume Snapshot: {0}" -f $Snapshot.name | Write-Verbose

		[void]$_VolumeSnapshotCollection.Add($Snapshot)

    }

    End 
    {

        "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing {0} Storage Volume Snapshot resources to remove." -f $_VolumeSnapshotCollection.count | Write-Verbose 

		#Process Resources
		ForEach ($_resource in $_VolumeSnapshotCollection)
		{

			if ($pscmdlet.ShouldProcess($_resource.ApplianceConnection.Name,("remove volume snapshot '{0}'" -f $_resource.name))) 
			{

				"[$($MyInvocation.InvocationName.ToString().ToUpper())] Removing resource '{0}' from appliance '{1}'." -f $_resource.name,$_resource.ApplianceConnection.Name | Write-Verbose 

				Try
				{
					
					$_resp = Send-HPOVRequest $_resource.Uri DELETE -Hostname $_resource.ApplianceConnection.Name

					[void]$_TaskCollection.Add($_resp)

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

			}

			elseif ($PSBoundParameters['WhatIf'])
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] WhatIf parameter was passed."

			}

		}

		Return $_TaskCollection

    }

}

function ConvertTo-HPOVStorageVolume
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding()]
    Param 
    (

        [parameter(Mandatory, ValueFromPipeline)]
        [ValidateNotNullOrEmpty()]
        [Object]$Snapshot,

		[parameter(Mandatory, Position = 0)]
		[ValidateNotNullOrEmpty()]
		[String]$Name,

		[parameter(Mandatory = $false, Position = 1)]
		[ValidateNotNullOrEmpty()]
		[String]$Description,

		[parameter(Mandatory = $false, Position = 2)]
		[ValidateSet('Private', 'Shared')]
		[String]$SharingMode,

        [parameter(Mandatory = $false, ValueFromPipelineByPropertyName)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Object]$ApplianceConnection

    )

    Begin 
    {

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSBoundParameters['Volume']))
		{

			$PipelineInput = $true

		}

		else
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

			Try 
            {
			
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
            {

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
            {

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}
        
        $_VolumeSnapshotTaskCollection = New-Object System.Collections.ArrayList

    }

    Process 
    { 
        
		#Generate error Snapshot is not an object or correct object
		if (-not($Snapshot -is [PSCustomObject]) -and $Snapshot.category -ne 'storage-volumes' -and (-not($Snapshot -match '/snapshots/')))
		{

			$errorRecord = New-ErrorRecord HPOneView.StorageVolumeResourceException InvalidStorageSnapshotResource InvalidArgument 'Snapshot' -TargetType $Snapshot.GetType().Name -Message "The provided Snapshot parameter value is not a supported type or object.  Please provide a Storage Volume Snapshot resource object and try again."
            $PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		"[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Storage Volume Snapshot: {0}" -f $Snapshot.name | Write-Verbose

		$_ConvertSnapshotToVol             = NewObject -ConvertSnapshotToVol
		$_ConvertSnapshotToVol.name        = $Name
		$_ConvertSnapshotToVol.description = $Description

		#Get parent volume snapshotUri value
		Try
		{

			$_ParentVol = Send-HPOVRequest $Snapshot.storageVolumeUri -Hostname $Snapshot.ApplianceConnection.Name

		}

		Catch
		{

			$PScmdlet.ThrowTerminatingError($_)

		}

		$_ConvertSnapshotToVol.snapshotPoolUri                       = $_ParentVol.snapshotPoolUri
		$_ConvertSnapshotToVol.provisioningParameters.storagePoolUri = $_ParentVol.storagePoolUri	
		$_ConvertSnapshotToVol.snapshotUri                           = $Snapshot.uri

		if (-not($PSBoundParameters['SharingMode']))
		{

			$_ConvertSnapshotToVol.provisioningParameters.shareable = $_ParentVol.shareable

		}

		else
		{

			$_ConvertSnapshotToVol.provisioningParameters.shareable = $SharingMode

		}
		
		#Send the query
		Try
		{

			$_VolumeSnapshotResp = Send-HPOVRequest $StorageVolumeUri POST $_ConvertSnapshotToVol -appliance $Snapshot.ApplianceConnection.Name

			[void]$_VolumeSnapshotTaskCollection.Add($_VolumeSnapshotResp)

		}

		Catch
		{

			#Return any task resources at this point, then generate error
			$_VolumeSnapshotTaskCollection

			$PSCmdlet.ThrowTerminatingError($_)

		}

    }

    End 
    {

        Return $_VolumeSnapshotTaskCollection

    }

}

function New-HPOVStorageVolume 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml
    
    [CmdletBinding(DefaultParameterSetName = "default")]
    Param 
	(

        [parameter (Mandatory, HelpMessage = "Specify the name of the storage volume.", Position = 0)]
        [ValidateNotNullOrEmpty()]
        [Alias("name")]
        [string]$volumeName,

        [parameter(Mandatory = $false, ParameterSetName = "default", Position = 1)]
        [string]$description = "",

        [parameter(Mandatory, ValueFromPipeline, ParameterSetName = "default", Position = 2)]
        [ValidateNotNullOrEmpty()]
        [Alias("pool","poolName")]
        [object]$StoragePool,

        [parameter(Mandatory = $false, HelpMessage = "Enter the Storage System Name, URI or provide the resource object.", ParameterSetName = "default")]
        [ValidateNotNullOrEmpty()]
		[object]$StorageSystem = $Null,

        [parameter(Mandatory, ParameterSetName = "template")]
        [ValidateNotNullOrEmpty()]
        [Alias('template','svt')]
        [object]$VolumeTemplate,

        [parameter(Mandatory, ParameterSetName = "default", Position = 3)]
        [parameter(Mandatory = $false, ParameterSetName = "template", Position = 2)]
        [ValidateScript({$_ -ge 1})]
        [Alias("size")]
        [int64]$capacity,

        [parameter(Mandatory = $false, ParameterSetName = "default", HelpMessage = "Create Thick provisioned volume.")]
        [switch]$full,

        [parameter(Mandatory = $false, ParameterSetName = "default", HelpMessage = "Allow the volume to be shared between hosts (i.e. shared datastore).")]
        [parameter(Mandatory = $false, ParameterSetName = "template", HelpMessage = "Allow the volume to be shared between hosts (i.e. shared datastore).")]
        [switch]$shared,

		[parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "default")]
		[parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "template")]
		[ValidateNotNullorEmpty()]
		[object]$ApplianceConnection = $null

    )

	Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSBoundParameters['StoragePool']))
		{

			$PipelineInput = $True

		}

		else
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

			if (-not($ApplianceConnection -is [HPOneView.Appliance.Connection]) -and (-not($ApplianceConnection -is [System.String])))
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException InvalidApplianceConnectionDataType InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter is not type [HPOneView.Appliance.Connection] or [System.String].  Please correct this value and try again.'
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			elseif  ($ApplianceConnection.Count -gt 1)
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException MultipleApplianceConnections InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter contains multiple Appliance Connections.  This CMDLET only supports 1 Appliance Connection in the ApplianceConnect parameter value.  Please correct this and try again.'
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			else
			{

				Try 
				{
	
					$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

				}

				Catch [HPOneview.Appliance.AuthSessionException] 
				{

					$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError 'ApplianceConnection' -TargetType $ApplianceConnection.GetType().Name -Message $_.Exception.Message -InnerException $_.Exception
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				Catch 
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

			}

		}

		$colStatus = New-Object System.Collections.ArrayList

    }

    Process 
	{

        $_newVolume = NewObject -StorageVolume

        $_newVolume.isPermanent = $true
        $_newVolume.name        = $volumeName
        $_newVolume.description = $description

        $_newVolume.provisioningParameters.storagePoolUri    = $null
        $_newVolume.provisioningParameters.requestedCapacity = $null
        $_newVolume.provisioningParameters.provisionType     = "Thin"
        $_newVolume.provisioningParameters.shareable         = $false

        #Check to see if Storage Volume Template Global Setting is enabled
		Try
		{

			$_storageVolumeTemplateRequiredGlobalPolicy = (Send-HPOVRequest $applStorageVolumeTemplateRequiredPolicy -Hostname $ApplianceConnection.Name).value

		}

		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}
        

        if ($_storageVolumeTemplateRequiredGlobalPolicy -ieq "True" -and (-not($VolumeTemplate)))
		{ 
        
            $errorRecord = New-ErrorRecord HPOneView.StorageVolumeResourceException StorageVolumeTemplateRequired InvalidArgument 'StorageVolumeTemplate' -Message "Storage Volumes cannot be created without providing a Storage Volume Template due to global policy setting.  Please provide a Storage Volume Template and try again."
            $PSCmdlet.ThrowTerminatingError($errorRecord)
        
        }

        else 
		{

            Switch ($PsCmdlet.ParameterSetName) 
			{
                
                "default" 
				{

                    switch ($StoragePool.Gettype().Name) 
					{

                        "String" 
						{ 
                        
                            #parameter is correct URI
                            if ($StoragePool.StartsWith($storagePoolUri))
							{

                                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] StoragePool URI provided by caller."
                                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request." 
                                                       
								Try
								{

									$_sp = Send-HPOVRequest $StoragePool -Hostname $ApplianceConnection.Name

								}

								Catch
								{

									$PSCmdlet.ThrowTerminatingError($_)

								}
                                
                            
                            }

                            #Parameter is incorrect URI value
                            elseif ($StoragePool.StartsWith("/rest")) 
							{

                                #Invalid parameter value, generate terminating error.
                                $errorRecord = New-ErrorRecord HPOneView.StorageVolumeResourceException InvalidArgumentValue InvalidArgument 'StoragePool' -Message "Invalid StoragePool parameter value: $($StoragePool | out-string). Please correct and try again."
                                $PSCmdlet.ThrowTerminatingError($errorRecord)

                            }

                            #Parameter is Storage Pool name
                            else 
							{
                                
                                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] StoragePool Name provided by caller."
                                
                                #Get specific storage pool from provided StorageSystem
                                if ($PSBoundParameters['StorageSystem']) 
								{ 

									#First look for the StorageSystem parameter value, and get the StoragePool by filtering on the StorageSystem value.
									Try
									{
										
										if ($PSBoundParameters['StorageSystem'])
										{

											$StoragePool = Get-HPOVStoragePool $StoragePool $StorageSystem -ApplianceConnection $ApplianceConnection

										}

										else
										{

											$StoragePool = Get-HPOVStoragePool $StoragePool -ApplianceConnection $ApplianceConnection
										
										}

									}
									
									Catch
									{
									
										$PSCmdlet.ThrowTerminatingError($_)
									
									}

								}

								else 
								{
										
									Try
									{
											
										$StoragePool = Get-HPOVStoragePool $storagePool -ApplianceConnection $ApplianceConnection
									
									}
									
									Catch
									{
									
										$PSCmdlet.ThrowTerminatingError($_)
									
									}
									
								}
									
								#If multiple Storage Pool Resources are returned that are of the same name, generate error and indicate the -StorageSystem parameter is needed.
								#Validate that the storage pool object is unique and not a collection
								if(($StoragePool | Measure-Object).Count -gt 1)
								{
									
									write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Multiple Storage Pool resources of the name	'$tmpStoragePool'. $($storagePool.count) resources found."
									    
									$errorRecord = New-ErrorRecord InvalidOperationException InvalidStoragePoolResource ObjectNotFound 'StoragePool' -TargetType 'Array'	-Message 	"Multiple Storage Pools it the '$tmpStoragePool' name were found.  Please use the -StorageSystem parameter to specify the Storage System the	Pool is associated with, or use the Get-HPOVStoragePool cmdlet to get the	Storage Pool resource and pass as the -StoragePool parameter value."
									    
									#Generate Terminating Error
									$PSCmdlet.ThrowTerminatingError($errorRecord)

								}


                                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] StorageSystem name provided: $StorageSystem"
                                
                                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request."

								Try
								{

									$_sp = Get-HPOVStoragePool $StoragePool -storageSystem $StorageSystem -ApplianceConnection $ApplianceConnection.Name

								}

								Catch
								{

									$PSCmdlet.ThrowTerminatingError($_)

								}
                                    
                            }

                        }

                        "PSCustomObject" 
						{ 
                        
                            #Validate the object
                            if ($StoragePool.category -eq 'storage-pools') 
							{ 
								
								#Check the StoragePool object to make sure the ApplianceConnection property matches the ApplianceConnection parameter from caller
								if ($StoragePool.ApplianceConnection.Name -ne $ApplianceConnection.Name)
								{

									$errorRecord = New-ErrorRecord HPOneView.StorageVolumeResourceException InvalidStoragePoolObject InvalidArgument 'StoragePool' -TargetType 'PSObject' -Message "The provided StoragePool object does not appear to originate from the same ApplianceConnection specified -  ApplianceConnection: $($ApplianceConnection.Name) StorageVolume ApplianceConnection $($StorageVolume.ApplianceConnection.Name)."
									$PSCmdlet.ThrowTerminatingError($errorRecord)

								}
								
								$_sp = $StoragePool.PSObject.Copy()
							
							}

                            else 
							{

                                $errorRecord = New-ErrorRecord HPOneView.StorageVolumeResourceException InvalidStoragePoolCategory InvalidArgument 'StoragePool' -TargetType 'PSObject' -Message "Invalid StoragePool parameter value.  Expected Resource Category 'storage-pools', received '$($VolumeTemplate.category)'."
                                $PSCmdlet.ThrowTerminatingError($errorRecord)

                            }                        
                        
                        }

                    }

                    #Amend the request body
                    $_newVolume.provisioningParameters.storagePoolUri    = $_sp.uri
                    $_newVolume.provisioningParameters.requestedCapacity = $capacity * 1GB

                    #Check for the presence of the $full and $shared parameters and set values if so
                    if($full.isPresent)
					{
						
						$_newVolume.provisioningParameters.provisionType = "Full"
					
					}

                    if($shared.isPresent)
					{
						
						$_newVolume.provisioningParameters.shareable = $true
					
					}

                }

                "template" 
				{

                    switch ($VolumeTemplate.gettype().name) 
					{

                        "String" 
						{
                            
                            if ($VolumeTemplate.StartsWith($script:storageVolumeTemplateUri))
							{

                                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] VolumeTemplate URI provided by caller."

                                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request."   
								                     
                                Try
								{

									$_svt = Send-HPOVRequest $VolumeTemplate -HostName $ApplianceConnection.Name

								}
								
								Catch
								{

									$PSCmdlet.ThrowTerminatingError($_)

								}
                            
                            }

                            elseif ($VolumeTemplate.StartsWith("/rest")) 
							{

                                #Invalid parameter value, generate terminating error.
                                $errorRecord = New-ErrorRecord HPOneView.StorageVolumeResourceException InvalidVolumeTemplateArgumentValue InvalidArgument 'VolumeTemplate' -Message "Invalid VolumeTemplate parameter value: $($VolumeTemplate | out-string)"
                                $PSCmdlet.ThrowTerminatingError($errorRecord)

                            }

                            else 
							{
                                
                                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] VolumeTemplate Name provided by caller."

                                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request."

                                #Get the storage volume template resource.  Terminating error will throw from the Get-* if no resource is found.
								Try
								{

									$_svt = Get-HPOVStorageVolumeTemplate -templateName $VolumeTemplate
								
								}
								
								Catch
								{

									$PSCmdlet.ThrowTerminatingError($_)

								}

                            }

                        }

                        "PSCustomObject" 
						{

                            #Validate the object
                            if ($VolumeTemplate.category -eq 'storage-volume-templates') 
							{ 
								
								#Check the StorageVolumeTemplate object to make sure the ApplianceConnection property matches the ApplianceConnection parameter from caller
								if ($VolumeTemplate.ApplianceConnection.Name -ne $ApplianceConnection.Name)
								{

									$errorRecord = New-ErrorRecord HPOneView.StorageVolumeResourceException InvalidStorageVolumeTemplateObject InvalidArgument 'VolumeTemplate' -TargetType 'PSObject' -Message "The provided VolumeTemplate object does not appear to originate from the same ApplianceConnection specified -  ApplianceConnection: $($ApplianceConnection.Name) StorageVolume ApplianceConnection $($VolumeTemplate.ApplianceConnection.Name)."
									$PSCmdlet.ThrowTerminatingError($errorRecord)

								}

								$_svt = $VolumeTemplate.PSObject.Copy()
							
							}

                            else 
							{

                                $errorRecord = New-ErrorRecord HPOneView.StorageVolumeResourceException InvalidVolumeTemplateCategory InvalidArgument 'VolumeTemplate' -Message "Invalid VolumeTemplate parameter value.  Expected Resource Category 'storage-volume-templates', received '$($VolumeTemplate.category)'."
                                $PSCmdlet.ThrowTerminatingError($errorRecord)

                            }

                        }

                        default 
						{ 
						
							$errorRecord = New-ErrorRecord HPOneView.StorageVolumeResourceException InvalidVolumeTemplateObjetType InvalidArgument 'VolumeTemplate' -TargetType $VolumeTemplate.GetType().Name -Message "Invalid VolumeTemplate parameter value.  Allowed parameter types 'System.String' or 'PSCustomObject' are allowed."
                            $PSCmdlet.ThrowTerminatingError($errorRecord)
						
						}

                    }

                    #Amend the request body
                    $_newVolume.templateUri                              = $_svt.uri
                    $_newVolume.provisioningParameters.storagePoolUri    = $null
                    $_newVolume.provisioningParameters.requestedCapacity = $_svt.provisioning.capacity
                    $_newVolume.provisioningParameters.provisionType     = $null
                    $_newVolume.provisioningParameters.shareable         = $_svt.provisioning.shareable

                    #Check if capacity and shareable parameters were overridden in the request and update the object
                    if($capacity)
					{

                        $_newVolume.provisioningParameters.requestedCapacity = $capacity * 1GB

                    }

                    if($shared.isPresent -ne $_svt.provisioning.shareable)
					{

                        $_newVolume.provisioningParameters.shareable = (-not($_svt.provisioning.shareable))

                    }

                }

            }

            #Send the request
			Try
			{

				$resp = Send-HPOVRequest -method POST -body $_newVolume -uri $script:storageVolumeUri

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			[void]$colStatus.Add($resp)
            
        }

    }

    end 
	{
		
		Return $colStatus

    }

}

function Add-HPOVStorageVolume 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml
    
    [CmdletBinding(DefaultParameterSetName = "default")]
    Param 
	(

        [parameter(Mandatory = $true, ValueFromPipeline = $True, Position = 0, ParameterSetName = "default")]
		[parameter(Mandatory = $true, ValueFromPipeline = $True, Position = 0, ParameterSetName = "StorageDeviceName")]
        [ValidateNotNullOrEmpty()]
        [object]$StorageSystem,

        [parameter (Mandatory = $true, HelpMessage = "Specify the name of the storage volume.", Position = 1, ParameterSetName = "default")]
        [ValidateNotNullOrEmpty()]
        [Alias("volid","id","wwn")]
        [ValidateScript({if ($_ -match $script:wwnLongAddressPattern) {$true} else { Throw "The input value '$_' does not match the required format of 'AA:BB:CC:DD:EE:AA:BB:CC:DD:EE:AA:BB:CC:DD:EE:AA'. Please correct and try again." }})]
        [string]$VolumeID,

		[parameter (Mandatory = $true, ParameterSetName = "StorageDeviceName", HelpMessage = "Specify the Storage Device Name of the storage volume.")]
        [ValidateNotNullOrEmpty()]
        [string]$StorageDeviceName,

        [parameter (Mandatory = $true, ParameterSetName = "default", HelpMessage = "Specify the name of the storage volume.", Position = 2)]
		[parameter (Mandatory = $true, ParameterSetName = "StorageDeviceName", HelpMessage = "Specify the name of the storage volume.", Position = 2)]
        [ValidateNotNullOrEmpty()]
        [Alias("name")]
        [string]$VolumeName,

        [parameter(Mandatory = $false, ParameterSetName = "default", Position = 3)]
		[parameter(Mandatory = $false, ParameterSetName = "StorageDeviceName", Position = 3)]
        [string]$Description = "",

        [parameter(Mandatory = $false, ParameterSetName = "default", HelpMessage = "Allow the volume to be shared between hosts (i.e. shared datastore).")]
		[parameter(Mandatory = $false, ParameterSetName = "StorageDeviceName", HelpMessage = "Allow the volume to be shared between hosts (i.e. shared datastore).")]
        [switch]$Shared,

		[parameter(Mandatory = $true, ParameterSetName = "default", ValueFromPipelineByPropertyName)]
		[parameter(Mandatory = $true, ParameterSetName = "StorageDeviceName", ValueFromPipelineByPropertyName)]
		[ValidateNotNullorEmpty()]
		[object]$ApplianceConnection = $null

    )

	Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if (-not($ApplianceConnection -is [HPOneView.Appliance.Connection]) -and (-not($ApplianceConnection -is [System.String])))
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException InvalidApplianceConnectionDataType InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter is not type [HPOneView.Appliance.Connection] or [System.String].  Please correct this value and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif  ($ApplianceConnection.Count -gt 1)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException MultipleApplianceConnections InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter contains multiple Appliance Connections.  This CMDLET only supports 1 Appliance Connection in the ApplianceConnect parameter value.  Please correct this and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		else
		{

			Try 
			{
	
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError 'ApplianceConnection' -TargetType $ApplianceConnection.GetType().Name -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}

		$colStatus = New-Object System.Collections.ArrayList

    }

    Process 
	{

		#Create new addVolume object
		Switch ($PSCmdlet.ParameterSetName)
		{

			'default'
			{

				$_addVolume = NewObject -AddStorageVolume
				$_addVolume.wwn = $VolumeID

			}

			'StorageDeviceName'
			{

				$_addVolume = NewObject -AddStorageVolumeV3
				$_addVolume.storageSystemVolumeName = $StorageDeviceName				

			}

		}
        
		$_addVolume.name                             = $volumeName
		$_addVolume.description                      = $description
		$_addVolume.provisioningParameters.shareable = $shared.IsPresent

        Switch ($StorageSystem.GetType().Name) 
		{

            "String" 
			{
                            
                if ($StorageSystem.StartsWith($script:storageSystemUri))
				{

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] StorageSystem URI provided by caller."
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request."   
					                     
					Try
					{

						$_ss = Send-HPOVRequest $StorageSystem -Hostname $ApplianceConnection.Name

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}
                    
                }

                elseif ($StorageSystem.StartsWith("/rest")) 
				{

                    #Invalid parameter value, generate terminating error.
                    $errorRecord = New-ErrorRecord HPOneView.StorageVolumeResourceException InvalidArgumentValue InvalidArgument 'New-HPOVStorageVolume' -Message "Invalid StorageSystem parameter value: $($StorageSystem | out-string)"
                    $PSCmdlet.ThrowTerminatingError($errorRecord)

                }

                else 
				{
                                
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] StorageSystem Name provided by caller."
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request."

                    #Get the storage volume template resource.  Terminating error will throw from the Get-* if no resource is found.

					Try
					{

						$_ss = Get-HPOVStorageSystem $StorageSystem -ApplianceConnection $ApplianceConnection
					
					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

                }

            }

            "PSCustomObject" 
			{

                #Validate the object
                if ($StorageSystem.category -eq 'storage-systems' -and $StorageSystem.ApplianceConnection.Name -eq $ApplianceConnection.Name) 
				{ 
					
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Storage System Object provided: $($StorageSystem.name)"

					$_ss = $StorageSystem.PSObject.Copy()
				
				}

                else 
				{

                    $errorRecord = New-ErrorRecord HPOneView.StorageVolumeResourceException InvalidStorageSystemCategory InvalidArgument 'StorageSystem' -TargetType PSObject -Message "Invalid StorageSystem parameter value.  Expected Resource Category 'storage-systems', received '$($VolumeTemplate.category)'."
                    $PSCmdlet.ThrowTerminatingError($errorRecord)

                }

            }

            default 
			{
			
				$errorRecord = New-ErrorRecord HPOneView.StorageVolumeResourceException InvalidStorageSystemObject InvalidArgument 'StorageSystem' -TargetType $StorageSystem.GetType().Name -Message "Invalid StorageSystem parameter value object type.  Only [PSCustomObject] or [String] values are allowed."
                $PSCmdlet.ThrowTerminatingError($errorRecord)
			
			}
        
		}

        $_addVolume.storageSystemUri = $_ss.uri

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Add Storage Volume Object: $($_addVolume | Out-String)"

        #Send the request
        
		Try
		{

			$_resp = Send-HPOVRequest POST $_addVolume $storageVolumeUri -Hostname $ApplianceConnection.Name

		}

		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

		[void]$colStatus.Add($_resp)
		
    }

    End 
	{

        Return $colStatus

    }

}

function Set-HPOVStorageVolume 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml
    
    [CmdletBinding(DefaultParameterSetName = "default")]
    Param 
	(

        [parameter (Mandatory = $true, ValueFromPipeline = $true, HelpMessage = "Specify the original Storage VOlume Name, URI or Object.", Position = 0)]
        [ValidateNotNullOrEmpty()]
        [Object]$SourceVolume,

        [parameter (Mandatory = $false, HelpMessage = "Specify the name of the storage volume.", Position = 1)]
        [ValidateNotNullOrEmpty()]
        [String]$VolumeName,

        [parameter(Mandatory = $false, ParameterSetName = "default", Position = 2)]
        [String]$Description = "",

        [parameter(Mandatory = $false, ParameterSetName = "default", Position = 3)]
        [ValidateScript({$_ -ge 1})]
        [Alias("size")]
        [int64]$Capacity,

		[parameter(Mandatory = $false, ParameterSetName = "default", Position = 2)]
        [ValidateNotNullOrEmpty()]
        [Object]$SnapShotStoragePool,

        [parameter(Mandatory = $false, ParameterSetName = "default", HelpMessage = "Allow the volume to be shared between hosts (i.e. shared datastore).")]
        [bool]$Shared,

		[parameter(Mandatory = $true, ParameterSetName = "default", ValueFromPipelineByPropertyName)]
		[ValidateNotNullorEmpty()]
		[object]$ApplianceConnection = $null

    )

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSBoundParameters['SourceVolume']))
		{

			$PipelineInput = $True

		}

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if (-not($ApplianceConnection -is [HPOneView.Appliance.Connection]) -and (-not($ApplianceConnection -is [System.String])) -and (-not($PipelineInput)))
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException InvalidApplianceConnectionDataType InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter is not type [HPOneView.Appliance.Connection] or [System.String].  Please correct this value and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif  ($ApplianceConnection.Count -gt 1)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException MultipleApplianceConnections InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter contains multiple Appliance Connections.  This CMDLET only supports 1 Appliance Connection in the ApplianceConnect parameter value.  Please correct this and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif (-not($PipelineInput))
		{

			Try 
			{
	
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError 'ApplianceConnection' -TargetType $ApplianceConnection.GetType().Name -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}

		$colStatus = New-Object System.Collections.ArrayList

    }

    Process 
	{

        #Get Source Volume resource
        Switch ($SourceVolume.GetType().Name) 
		{

            "String" 
			{ 
                 
                #parameter is correct URI
                if ($sourceVolume.StartsWith($script:storageVolumeUri))
				{

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Storage Volume URI provided by caller: $sourceVolume"

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting volume resource object" 
                                                       
                    $SourceVolume = Send-HPOVRequest $SourceVolume -hostname $ApplianceConnection
                            
                }

                #Parameter is incorrect URI value
                elseif ($sourceVolume.StartsWith("/rest")) 
				{

                    #Invalid parameter value, generate terminating error.
                    $errorRecord = New-ErrorRecord HPOneView.StorageVolumeResourceException InvalidArgumentValue InvalidArgument 'SourceVolume' -Message "Invalid Storage Volume parameter value: $($SourceVolume | out-string). Please correct and try again."
                    $PSCmdlet.ThrowTerminatingError($errorRecord)

                }

                #Parameter is Storage Pool name
                else 
				{
                                
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Storage Volume Name provided by caller."
                                
                    $SourceVolume = Get-HPOVStorageVolume $SourceVolume -ApplianceConnection $ApplianceConnection

                }
                
            }

            "PSCustomObject" 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Storage Volume Object provided by caller."

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $($SourceVolume | FL * | Out-String)"

                #Validate the object
                if (-not($SourceVolume.category -eq 'storage-volumes'))
				{

                    $errorRecord = New-ErrorRecord HPOneView.StorageVolumeResourceException InvalidStoragePoolCategory InvalidArgument 'Set-HPOVStorageVolume' -Message "Invalid Storage Volume parameter value.  Expected Resource Category 'storage-volumes', received '$($sourceVolume.category)'."
                    $PSCmdlet.ThrowTerminatingError($errorRecord)

                }          
                
            }

        }

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] ORIGINAL Storage Volume object properties: $($SourceVolume | out-string)"

        $SourceVolume = $SourceVolume | Select-Object * -ExcludeProperty deviceVolumeName,wwn,raidLevel,storagePoolUri,allocatedCapacity,deviceType,category,refreshState,created,modified,stateReason,status,state

        #Volume Object updates
        switch ($PSboundParameters.keys) 
		{

            'volumeName'
			{ 
				
				$SourceVolume.name = $volumeName 
			
			}

            'description'
			{ 
				
				$SourceVolume.description = $description 
			
			}

            'capacity' 
			{ 
            
                [int64]$capacity = $capacity * 1GB

                if ([int64]$capacity -gt [int64]$SourceVolume.provisionedCapacity) 
				{ 
					
					$SourceVolume.provisionedCapacity = $capacity 
				
				}

                #Generate Terminating Error
                else 
				{ 
                
                    $errorRecord = New-ErrorRecord HPOneView.StorageVolumeResourceException InvalidStorageVolumeCapacityValue InvalidArgument 'Capacity' -TargetType 'Int' -Message "Invalid 'capacity' Storage Volume parameter value.  The value '$([int64]$capacity)' is less than the original volume size $([int64]$SourceVolume.provisionedCapacity).  Volume capacity cannot be reduced, only increased."
                    $PSCmdlet.ThrowTerminatingError($errorRecord)
                
                }

            }

			'SnapShotStoragePool'
			{

				switch ($StoragePool.Gettype().Name) 
				{

                    "String" 
					{ 
                    
                        #parameter is correct URI
                        if ($SnapShotStoragePool.StartsWith($script:storagePoolUri))
						{

                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] SnapShotStoragePool URI provided by caller."

                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request." 
                                                   
							Try
							{

								$SnapShotStoragePool = Send-HPOVRequest $SnapShotStoragePool -Hostname $ApplianceConnection

							}

							Catch
							{

								$PSCmdlet.ThrowTerminatingError($_)

							}
                            
                        
                        }

                        #Parameter is incorrect URI value
                        elseif ($SnapShotStoragePool.StartsWith("/rest")) 
						{

                            #Invalid parameter value, generate terminating error.
                            $errorRecord = New-ErrorRecord HPOneView.StorageVolumeResourceException InvalidArgumentValue InvalidArgument 'SnapShotStoragePool' -Message "Invalid SnapShotStoragePool parameter value: $($SnapShotStoragePool | out-string). Please correct and try again."
                            $PSCmdlet.ThrowTerminatingError($errorRecord)

                        }

                        #Parameter is Storage Pool name
                        else 
						{
                            
                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] SnapShotStoragePool Name provided by caller."

							Try
							{

								$SnapShotStoragePool = Get-HPOVStoragePool $SnapShotStoragePool -ApplianceConnection $ApplianceConnection.Name

							}

							Catch
							{

								$PSCmdlet.ThrowTerminatingError($_)

							}

                            if ($SnapShotStoragePool -and $SnapShotStoragePool.count -gt 1) 
							{

                                $errorRecord = New-ErrorRecord HPOneView.StorageVolumeResourceException MultipleStoragePoolsFound InvalidResult 'SnapShotStoragePool' -Message "Multiple StoragePool resources found with the name '$SnapShotStoragePool'.  Please use the Get-HPOVStoragePool with -StorageSystem parameter to specify the Storage System the Storage Pool is to be used."
                                $PSCmdlet.ThrowTerminatingError($errorRecord)

                            }

                        }

                    }

                    "PSCustomObject" 
					{ 
                    
                        #Validate the object
                        if ($SnapShotStoragePool.category -eq 'storage-pools') 
						{ 
							
							#Check the StoragePool object to make sure the ApplianceConnection property matches the ApplianceConnection parameter from caller
							if ($SnapShotStoragePool.ApplianceConnection.Name -ne $ApplianceConnection.Name)
							{

								$errorRecord = New-ErrorRecord HPOneView.StorageVolumeResourceException InvalidStoragePoolObject InvalidArgument 'SnapShotStoragePool' -TargetType 'PSObject' -Message "The provided SnapShotStoragePool object does not appear to originate from the same ApplianceConnection specified -  ApplianceConnection: $($ApplianceConnection.Name) StorageVolume ApplianceConnection $($SnapShotStoragePool.ApplianceConnection.Name)."
								$PSCmdlet.ThrowTerminatingError($errorRecord)

							}
						
						}

                        else 
						{

                            $errorRecord = New-ErrorRecord HPOneView.StorageVolumeResourceException InvalidStoragePoolCategory InvalidArgument 'SnapShotStoragePool' -TargetType 'PSObject' -Message "Invalid SnapShotStoragePool parameter value.  Expected Resource Category 'storage-pools', received '$($SnapShotStoragePool.category)'."
                            $PSCmdlet.ThrowTerminatingError($errorRecord)

                        }                        
                    
                    }

                }

				$SourceVolume.snapshotPoolUri = $SnapShotStoragePool

			}

            'shared'
			{ 
				
				$SourceVolume.shared = [Bool]$shared 
			
			}

            'Permanent'
			{ 
				
				$SourceVolume.Permanent = [Bool]$Permanent 
			
			}
            
        }
        
        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Updated Storage Volume object properties: $($SourceVolume | FL * | out-string)"

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending updated storage volume to appliance."

		Try
		{

			$_resp = Send-HPOVRequest $SourceVolume.uri PUT $SourceVolume -Hostname $ApplianceConnection

		}

		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

		[void]$colStatus.Add($_resp)
        

    }

    end 
	{

        Return $colStatus

    }

}

function Remove-HPOVStorageVolume 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding(SupportsShouldProcess = $True,ConfirmImpact = 'High')]
    Param 
	(

        [parameter (Mandatory, ValueFromPipeline, ParameterSetName = "default", HelpMessage = "Specify the storage volume to remove.", Position = 0)]
        [ValidateNotNullOrEmpty()]
        [Alias('uri', 'name')]
        [Object]$StorageVolume,

        [parameter(Mandatory = $false, HelpMessage = "Specify whether to delete the export reference or export and provisioning volume.")]
        [Switch]$ExportOnly,
	
		[parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "default")]
        [ValidateNotNullOrEmpty()]
		[Alias('Appliance')]
		[Object]$ApplianceConnection = $Null

    )

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSBoundParameters['SourceVolume']))
		{

			$PipelineInput = $True

		}

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if (-not($ApplianceConnection -is [HPOneView.Appliance.Connection]) -and (-not($ApplianceConnection -is [System.String])) -and (-not($PipelineInput)))
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException InvalidApplianceConnectionDataType InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter is not type [HPOneView.Appliance.Connection] or [System.String].  Please correct this value and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif  ($ApplianceConnection.Count -gt 1)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException MultipleApplianceConnections InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter contains multiple Appliance Connections.  This CMDLET only supports 1 Appliance Connection in the ApplianceConnect parameter value.  Please correct this and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif (-not($PipelineInput))
		{

			Try 
			{
	
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError 'ApplianceConnection' -TargetType $ApplianceConnection.GetType().Name -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}

		$_TaskCollection    = New-Object System.Collections.ArrayList
		$_VolumeCollection  = New-Object System.Collections.ArrayList

    }

    Process 
	{

		if ($PipelineInput) 
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Pipeline input"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Storage Volume Object provided: $($StorageVolume | FL * | Out-String)"

			If ($StorageVolume.category -eq 'storage-volumes')
			{

				If (-not($StorageVolume.ApplianceConnection))
				{

					$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument "StorageVolume:$($StorageVolume.Name)" -TargetType PSObject -Message "The Storage Volume resource provided is missing the source ApplianceConnection property.  Please check the object provided and try again."
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				[void]$_VolumeCollection.Add($StorageVolume)

			}

			else
			{

				$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument "StorageVolume:$($StorageVolume.Name)" -TargetType PSObject -Message "The Storage Volume resource is not an expected category type [$($StorageVolume.category)].  Allowed resource category type is 'storage-volumes'.  Please check the object provided and try again."
                $PSCmdlet.ThrowTerminatingError($errorRecord)

			}

		}

		else 
		{

			foreach ($_vol in $StorageVolume) 
			{

				#Volume passed is a URI
				if (($_vol -is [String]) -and [System.Uri]::IsWellFormedUriString($_vol,'Relative')) 
				{

				    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Received URI: $($_vol)"

				    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Volume object"

					if (($ApplianceConnection | Measure-Object).Count -gt 1)
					{

						$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException MultipleApplianceConnections InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter contains multiple Appliance Connections.  This CMDLET only supports 1 Appliance Connection in the ApplianceConnect parameter value when using a Storage Volume Template URI value.  Please correct this and try again.'
						$PSCmdlet.ThrowTerminatingError($errorRecord)

					}

					Try
					{

						$_volObject = Send-HPOVRequest $_vol -ApplianceConnection $ApplianceConnection

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

					[void]$_VolumeCollection.Add($_volObject)

				}

				#Volume passed is the Name
				elseif (($_vol -is [string]) -and (-not($_vol.startsWith("/rest")))) 
				{

				    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Received Volume Name $($_vol)"

				    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Volume object from Get-HPOVStorageVolume"

					ForEach ($_Connection in $ApplianceConnection)
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$_Connection' Appliance Connection [of $($ApplianceConnection.count)]"

						Try
						{

							$_volObject = Get-HPOVStorageVolume $_vol -ApplianceConnection $_Connection

						}

						Catch
						{
							
							$PSCmdlet.ThrowTerminatingError($_)

						}

						$_volObject | % {

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding '$($_.name)' Volume to collection."

							[void]$_VolumeCollection.Add($_)

						}

					}

				}

				#Volume passed is the object
				elseif ($_vol -is [PSCustomObject] -and $_vol.category -ieq 'storage-volumes') 
				{
				    
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Volume Object provided: $($_vol | FL * | out-string)"

					[void]$_VolumeCollection.Add($_vol)
				
				}

				else 
				{

				    $errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'StorageVolume' -TargetType 'PSObject' -Message "Invalid Volume parameter: $($_vol | FL * | Out-String)"
				    $PSCmdlet.WriteError($errorRecord)

				}

			}

		}

    }

	End
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing {$($_VolumeCollection.count)} Volume resources to remove."

		#Process Volume Resources
		ForEach ($_volObject in $_VolumeCollection)
		{

			if ((-not($PSBoundParameters['ExportOnly'])) -and $pscmdlet.ShouldProcess($_volObject.name,"Remove Storage Volume from appliance '$($_volObject.ApplianceConnection.Name)'?'")) 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Removing Volume '$($_volObject.name)' and Export from appliance '$($_volObject.ApplianceConnection.Name)'."

				Try
				{
					
					if ($PSBoundParameters['Force'])
					{

						$_volObject.uri += "?force=true"

					}

					$_resp = Send-HPOVRequest $_volObject.Uri DELETE -Hostname $_volObject.ApplianceConnection.Name

					[void]$_TaskCollection.Add($_resp)

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

			}

			elseif ($PSBoundParameters['ExportOnly'] -and $pscmdlet.ShouldProcess($_volObject.name,"Remove Storage Volume from appliance '$($_volObject.ApplianceConnection.Name)'?'")) 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Removing Volume Export '$($_volObject.name)' from appliance '$($_volObject.ApplianceConnection.Name)'."

				Try
				{
					
					if ($PSBoundParameters['Force'])
					{

						$_volObject.uri += "?force=true"

					}

					$_resp = Send-HPOVRequest $_volObject.Uri DELETE -Hostname $_volObject.ApplianceConnection.Name -addHeader @{exportOnly = [bool]$ExportOnly}

					[void]$_TaskCollection.Add($_resp)

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

			}

			elseif ($PSBoundParameters['WhatIf'])
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] WhatIf parameter was passed."

			}

		}

		Return $_TaskCollection

	}

}

function Get-HPOVSanManager 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding()]
    Param 
	(

        [parameter(Position = 0, Mandatory = $false, HelpMessage = "Enter the SAN Manager Hostname or IP Address.")]
        [ValidateNotNullOrEmpty()]
        [Alias('Name')]
        [string]$SanManager = $Null,

		[parameter(Mandatory = $false, HelpMessage = "Enter the Appliance Name or Object")]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

    )

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$SanManagerCollection = New-Object System.Collections.ArrayList
        
	}
	
	Process 
	{

		ForEach ($Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($Connection.Name)' Appliance (of $($Appliance.Count))"

			if ($SanManager)
			{
				
				$SanManager = $SanManager -replace ("[*]","%25") -replace ("[&]","%26")

			}


			#Send Request
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting list of SAN Managers"

			Try
			{

				$_sanManagers = Send-HPOVRequest ($fcSanManagersUri + "?sort=name:asc") -Hostname $_connection.Name

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			#Filter results for specific SAN Manager
			if ($SanManager) 
			{ 
			
			    $_sanManagers.members = $_sanManagers.members | ? name -eq $SanManager

			    #Generate Terminating Error if resource not found
			    if (-not($_sanManagers.members)) 
				{

			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Requested Managed SAN '$($SanManager)' not found on $($_connection.Name)."
			            
			        $errorRecord = New-ErrorRecord InvalidOperationException SanManagerResourceNotFound ObjectNotFound 'SanManager' -Message "Request SAN Manager '$($SanManager)' not found on $($_connection.Name).  Please check the name and try again."
			            
			        #Generate Terminating Error
			        $PSCmdlet.ThrowTerminatingError($errorRecord)

			    }

			}

			if (-not($_sanManagers.members)) 
			{

			    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No SAN Managers found."
			            
			}

			else 
			{

				$_sanManagers.members | % { 
					
					$_.PSObject.TypeNames.Insert(0,"HPOneView.Storage.SanManager") 
				
					[void]$SanManagerCollection.Add($_)
				
				}

			}

		}

    }

    End 
	{

        Return $SanManagerCollection

    }

}

function Add-HPOVSanManager 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding(DefaultParameterSetName = "BNA")]
    Param 
	(

        [parameter(Mandatory = $true, HelpMessage = "Specify the SAN Manager Type.  Accepted values are: BNA or HP.", Position = 0, ParameterSetName = "HPCisco")]
		[parameter(Mandatory = $true, HelpMessage = "Specify the SAN Manager Type.  Accepted values are: BNA or HP.", Position = 0, ParameterSetName = "BNA")]
        [ValidateSet("Brocade","BNA","Brocade Network Advisor","HP","Cisco")]
        [string]$Type,

		[parameter(Mandatory = $true, HelpMessage = "Enter the SAN Manager Hostname or IP Address.", Position = 1, ParameterSetName = "HPCisco")]
        [parameter(Mandatory = $true, HelpMessage = "Enter the SAN Manager Hostname or IP Address.", Position = 1, ParameterSetName = "BNA")]
        [ValidateNotNullOrEmpty()]
        [string]$Hostname = $null,

		[parameter(Mandatory = $false, HelpMessage = "Enter the SAN Manager TCP Port (HTTPS port for BNA, SNMP Port for HP).", Position = 2, ParameterSetName = "HPCisco")]
        [parameter(Mandatory = $false, HelpMessage = "Enter the SAN Manager TCP Port (HTTPS port for BNA, SNMP Port for HP).", Position = 2, ParameterSetName = "BNA")]
        [ValidateNotNullOrEmpty()]
        [ValidateRange(1,65535)]
        [int]$Port = 0,
         
		[parameter(Mandatory = $true, HelpMessage = "Enter the administrative user name (i.e. Administrator).", Position = 3, ParameterSetName = "HPCisco")]
        [parameter(Mandatory = $true, HelpMessage = "Enter the administrative user name (i.e. Administrator).", Position = 3, ParameterSetName = "BNA")]
        [ValidateNotNullOrEmpty()]
        [string]$Username = $Null,

		[parameter(Mandatory = $true, HelpMessage = "Enter the administrative account password (i.e. password).", Position = 4, ParameterSetName = "HPCisco")]
        [parameter(Mandatory = $true, HelpMessage = "Enter the administrative account password (i.e. password).", Position = 4, ParameterSetName = "BNA")]
        [ValidateNotNullOrEmpty()]
        [string]$Password = $Null,

		[parameter(Mandatory = $true, HelpMessage = "Enter the SNMPv3 User Account.", ParameterSetName = "HPCisco")]
		[string]$SnmpUserName,

		[parameter(Mandatory = $false, HelpMessage = "Enter the SNMPv3 Authentication Level 'None', 'AuthOnly', or 'AuthAndPriv'", ParameterSetName = "HPCisco")]
		[ValidateSet("None","AuthOnly","AuthAndPriv")]
		[ValidateNotNullOrEmpty()]
		[string]$SnmpAuthLevel = "None",

		[parameter(Mandatory = $false, HelpMessage = "Enter the SNMPv3 Authentication Encryption Protocol SHA or MD5", ParameterSetName = "HPCisco")]
		[ValidateSet("sha","md5")]	
		[ValidateNotNullOrEmpty()]
		[string]$SnmpAuthProtocol,

		[parameter(Mandatory = $false, HelpMessage = "Enter the SNMPv3 Authentication account password (i.e. password).", ParameterSetName = "HPCisco")]
		[ValidateNotNullOrEmpty()]
		[string]$SnmpAuthPassword,

		[parameter(Mandatory = $false, HelpMessage = "Enter the SNMPv3 Privacy Protocol DES or AES", ParameterSetName = "HPCisco")]
		[ValidateSet("aes-128","des56","3des")]	
		[ValidateNotNullOrEmpty()]
		[string]$SnmpPrivProtocol,

		[parameter(Mandatory = $false, HelpMessage = "Enter the SNMPv3 Privacy Password", ParameterSetName = "HPCisco")]
		[ValidateNotNullOrEmpty()]
		[string]$SnmpPrivPassword,

	    [parameter(Mandatory = $false, ParameterSetName = "BNA")]
	    [switch]$UseSsl,
		
		[parameter(Mandatory = $false)]
		[switch]$Async,

		[parameter(Mandatory = $false, HelpMessage = "Enter the Appliance Name or Object")]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

	)

    Begin 
    {
        
        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$TaskCollection = New-Object System.Collections.ArrayList

		if ($SnmpAuthLevel -eq "AuthOnly" -and 
			(-not $SnmpAuthProtocol -or 
			-not $SnmpAuthPassword)) 
		{

			#Generate Terminateing error
            $errorRecord = New-ErrorRecord HPOneView.SanManagerResourceException MissingRequiredParameters InvalidArgument 'Add-HPOVSanManager' -Message "The -SnmpAuthLevel parameter was set to 'AuthOnly', but did not include both -SnmpAuthProtocol and -SnmpAuthPassword parameters."
            $PsCmdlet.ThrowTerminatingError($errorRecord)
		}

		if ($SnmpAuthLevel -eq "AuthAndPriv" -and (
			-not $SnmpAuthProtocol -or 
			-not $SnmpAuthPassword -or 
			-not $SnmpPrivProtocol -or 
			-not $SnmpPrivPassword )) 
		{

			#Generate Terminateing error
            $errorRecord = New-ErrorRecord HPOneView.SanManagerResourceException MissingRequiredParameters InvalidArgument 'Add-HPOVSanManager' -Message "The -SnmpAuthLevel parameter was set to 'AuthAndPriv', but did not include -SnmpAuthProtocol, -SnmpAuthPassword, -SnmpPrivProtocol and -SnmpPrivPassword parameters."
            $PsCmdlet.ThrowTerminatingError($errorRecord)
		}

		#Cisco MDS/Nexus SNMP Auth parameter validation
		if ($type -eq 'Cisco' -and $SnmpAuthLevel -eq 'None')
		{

			$errorRecord = New-ErrorRecord HPOneView.SanManagerResourceException UnsupportedSnmpAuthLevel InvalidArgument 'SnmpAuthLevel' -Message "The -SnmpAuthLevel parameter value $($SnmpAuthLevel) is invalid for configuring a Cisco SAN Manager.  Please specify either 'AuthOnly' or 'AuthAndPriv' and try again."
            $PsCmdlet.ThrowTerminatingError($errorRecord)

		}

		#Cisco MDS/Nexus SNMP Auth parameter validation
		if ($type -eq 'Cisco' -and $SnmpPrivProtocol -eq '3DES')
		{

			$errorRecord = New-ErrorRecord HPOneView.SanManagerResourceException UnsupportedSnmpPrivProtocol InvalidArgument 'SnmpPrivProtocol' -Message "The -SnmpPrivProtocol parameter value $($SnmpPrivProtocol) is invalid for configuring a Cisco SAN Manager.  Please specify either 'des56' or 'aes-128' and try again."
            $PsCmdlet.ThrowTerminatingError($errorRecord)

		}

		switch ($SnmpAuthLevel)
		{

			"None"
			{
			
				$_SnmpAuthLevel = 'NOAUTHNOPRIV'
			
			}
			
			"AuthOnly"
			{
			
				$_SnmpAuthLevel = 'AUTHNOPRIV'
			
			}
			
			"AuthAndPriv"
			{
			
				$_SnmpAuthLevel = 'AUTHPRIV'

			}

		}

	}

    Process 
	{

		ForEach ($_connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing $($_connection.Name) (of $($ApplianceConnection.Count))"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] SAN Manager Type requested: $Type"

			#Basic SAN Manager Object
			$_sanmanager = NewObject -SanManager

			$_sanmanagerhostconnectinfo = NewObject -SanManagerConnectInfo
			$_sanmanagerhostconnectinfo.name = "Host"
			$_sanmanagerhostconnectinfo.Value = $Hostname
			[void]$_sanmanager.connectionInfo.Add($_sanmanagerhostconnectinfo)

			$_sanmanagerhostconnectinfo = NewObject -SanManagerConnectInfo
			$_sanmanagerhostconnectinfo.name = "Username"
			$_sanmanagerhostconnectinfo.Value = $Username
			[void]$_sanmanager.connectionInfo.Add($_sanmanagerhostconnectinfo)

			$_sanmanagerhostconnectinfo = NewObject -SanManagerConnectInfo
			$_sanmanagerhostconnectinfo.name = "Password"
			$_sanmanagerhostconnectinfo.Value = $Password
			[void]$_sanmanager.connectionInfo.Add($_sanmanagerhostconnectinfo)

			#Get SAN Manager Providers
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting available SAN Manager Providers"
			
			$_SanManagerProviders = Send-HPOVRequest $script:fcSanManagerProvidersUri -Hostname $_connection.Name

			switch ($type) 
			{
				
				{ @('Brocade','BNA','Brocade Network Advisor') -contains $_ } 
				{ 
					
					if ($Port -eq 0) 
					{ 
						
						$Port = 5989 
					
					}

					$_SanManagerProviderUri = ($_SanManagerProviders.members | ? name -eq 'Brocade San Plugin').deviceManagersUri

					$_sanmanagerhostconnectinfo       = NewObject -SanManagerConnectInfo
					$_sanmanagerhostconnectinfo.name  = "UseSsl"
					$_sanmanagerhostconnectinfo.Value = [bool]$UseSsl
					[void]$_sanmanager.connectionInfo.Add($_sanmanagerhostconnectinfo)
					
					$_sanmanagerhostconnectinfo       = NewObject -SanManagerConnectInfo
					$_sanmanagerhostconnectinfo.name  = "Port"
					$_sanmanagerhostconnectinfo.Value = $Port
					[void]$_sanmanager.connectionInfo.Add($_sanmanagerhostconnectinfo)

				}

				{ @("HP","Cisco") -contains $_ } 
				{ 

					if ($Port -eq 0) 
					{ 
						
						$Port = 161 
					
					}

					$_SanManagerProviderUri = ($_SanManagerProviders.members | ? name -eq 'HP San Plugin').deviceManagersUri

					$_sanmanagerhostconnectinfo       = NewObject -SanManagerConnectInfo
					$_sanmanagerhostconnectinfo.name  = "SnmpPort"
					$_sanmanagerhostconnectinfo.Value = [bool]$Port
					[void]$_sanmanager.connectionInfo.Add($_sanmanagerhostconnectinfo)

					$_sanmanagerhostconnectinfo       = NewObject -SanManagerConnectInfo
					$_sanmanagerhostconnectinfo.name  = "SnmpUserName"
					$_sanmanagerhostconnectinfo.Value = [bool]$SnmpUserName
					[void]$_sanmanager.connectionInfo.Add($_sanmanagerhostconnectinfo)

					$_sanmanagerhostconnectinfo       = NewObject -SanManagerConnectInfo
					$_sanmanagerhostconnectinfo.name  = "SnmpAuthLevel"
					$_sanmanagerhostconnectinfo.Value = $fcSanManagerSnmpAuthLevel[$_SnmpAuthLevel]
					[void]$_sanmanager.connectionInfo.Add($_sanmanagerhostconnectinfo)

					$_sanmanagerhostconnectinfo       = NewObject -SanManagerConnectInfo
					$_sanmanagerhostconnectinfo.name  = "SnmpAuthProtocol"
					$_sanmanagerhostconnectinfo.Value = $SnmpAuthProtocol.ToLower()
					[void]$_sanmanager.connectionInfo.Add($_sanmanagerhostconnectinfo)

					$_sanmanagerhostconnectinfo       = NewObject -SanManagerConnectInfo
					$_sanmanagerhostconnectinfo.name  = "SnmpAuthString"
					$_sanmanagerhostconnectinfo.Value = $SnmpAuthPassword
					[void]$_sanmanager.connectionInfo.Add($_sanmanagerhostconnectinfo)
					
					$_sanmanagerhostconnectinfo       = NewObject -SanManagerConnectInfo
					$_sanmanagerhostconnectinfo.name  = "SnmpPrivProtocol"
					$_sanmanagerhostconnectinfo.Value = $SnmpPrivProtocol.ToLower()
					[void]$_sanmanager.connectionInfo.Add($_sanmanagerhostconnectinfo)

					$_sanmanagerhostconnectinfo       = NewObject -SanManagerConnectInfo
					$_sanmanagerhostconnectinfo.name  = "SnmpPrivString"
					$_sanmanagerhostconnectinfo.Value = $SnmpPrivPassword
					[void]$_sanmanager.connectionInfo.Add($_sanmanagerhostconnectinfo)

				}

			}

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] SAN Manager Provider URI: $($_SanManagerProviderUri)"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] New SAN Manager Request: $($_sanmanager.connectionInfo | out-string)"

			try 
			{
			
			    $resp = Send-HPOVRequest $_SanManagerProviderUri POST $_sanmanager -Hostname $_connection.Name

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Received async task, calling Wait-HPOVTaskComplete"

			    $resp = Wait-HPOVTaskComplete $resp

			}

			catch 
			{

				if ($_.FullyQualifiedErrorId -eq 'RESOURCE_CONFLICT_ERROR')
				{

					$errorRecord = New-ErrorRecord HPOneView.SanManagerResourceException SanManagerAlreadyExists ResourceExists 'Hostname' -Message "The SAN Manager $($Hostname) already exists on appliance $($_connection.Name)." -InnerException $_.Exception

				}

				else
				{

					$errorRecord = $_.Exception

				}
				
			    $PsCmdlet.ThrowTerminatingError($errorRecord)

			}

			[void]$TaskCollection.Add($resp)

		}

    }

	End
	{

		Return $TaskCollection

	}

}

function Show-HPOVSanEndpoints
{
	<#

	Query does work!
	GET https://{appl}/rest/fc-sans/endpoints?query=wwn eq 'AA:BB:CC:DD:AA:BB:CC:DD'


	$resp.members
uri                 : /rest/fc-sans/endpoints/21:52:00:02:AC:00:15:2C
type                : FCEndpointV3
aliasName           :
category            : fc-endpoints
created             : 2016-02-23T02:33:47.591Z
deviceName          : HP-P10000-2
deviceNameUri       : /rest/storage-systems/1405420
devicePortGroupName :
devicePortName      : 1:5:2
eTag                : dff358ec-8014-48a2-91ee-4f7c1d1d87c9
isOnline            : True
modified            : 2016-02-25T03:40:47.944Z
portType            : N_Port
sanName             : POD-22, interconnect 2_FC direct-b
sanUri              : /rest/fc-sans/managed-sans/2adaa55f-9575-4c0f-9daa-b30a738eac73
wwn                 : 21:52:00:02:AC:00:15:2C
zoneName            :
ApplianceConnection : @{Name=pod22-hpov.cinetworking.lab; ConnectionId=1}

uri                 : /rest/fc-sans/endpoints/20:52:00:02:AC:00:15:2C
type                : FCEndpointV3
aliasName           :
category            : fc-endpoints
created             : 2016-02-23T02:33:47.591Z
deviceName          : HP-P10000-2
deviceNameUri       : /rest/storage-systems/1405420
devicePortGroupName :
devicePortName      : 0:5:2
eTag                : 46544b32-5ea5-45ba-8d22-c2dd1defceaf
isOnline            : True
modified            : 2016-02-25T03:40:47.905Z
portType            : N_Port
sanName             : POD-22, interconnect 1_FC direct-a
sanUri              : /rest/fc-sans/managed-sans/ed01a48a-0930-4e74-9c13-434ce21daf1b
wwn                 : 20:52:00:02:AC:00:15:2C
zoneName            :
ApplianceConnection : @{Name=pod22-hpov.cinetworking.lab; ConnectionId=1}

uri                 : /rest/fc-sans/endpoints/10:00:66:03:6C:70:00:00
type                : FCEndpointV3
aliasName           :
category            : fc-endpoints
created             : 2016-02-23T02:33:47.591Z
deviceName          : Prod ESXi Server Bay 09
deviceNameUri       : /rest/server-profiles/a311432b-6c24-471d-81bc-01c361d8eedf
devicePortGroupName :
devicePortName      : vmhba1
eTag                : 46544b32-5ea5-45ba-8d22-c2dd1defceaf
isOnline            : False
modified            : 2016-02-25T03:40:47.905Z
portType            : N_Port
sanName             : POD-22, interconnect 1_FC direct-a
sanUri              : /rest/fc-sans/managed-sans/ed01a48a-0930-4e74-9c13-434ce21daf1b
wwn                 : 10:00:66:03:6C:70:00:00
zoneName            :
ApplianceConnection : @{Name=pod22-hpov.cinetworking.lab; ConnectionId=1}

uri                 : /rest/fc-sans/endpoints/10:00:66:03:6C:70:00:02
type                : FCEndpointV3
aliasName           :
category            : fc-endpoints
created             : 2016-02-23T02:33:47.591Z
deviceName          : Prod ESXi Server Bay 09
deviceNameUri       : /rest/server-profiles/a311432b-6c24-471d-81bc-01c361d8eedf
devicePortGroupName :
devicePortName      : vmhba2
eTag                : dff358ec-8014-48a2-91ee-4f7c1d1d87c9
isOnline            : False
modified            : 2016-02-25T03:40:47.944Z
portType            : N_Port
sanName             : POD-22, interconnect 2_FC direct-b
sanUri              : /rest/fc-sans/managed-sans/2adaa55f-9575-4c0f-9daa-b30a738eac73
wwn                 : 10:00:66:03:6C:70:00:02
zoneName            :
ApplianceConnection : @{Name=pod22-hpov.cinetworking.lab; ConnectionId=1}



[PS] C:\Users\clynch> $resp.members | ft -Property devicename,isOnline,sanName,wwn,zonename

deviceName                                         isOnline sanName                       wwn                           zoneName
----------                                         -------- -------                       ---                           --------
HP-P10000-2                                            True POD-22, interconnect 2_FC ... 21:52:00:02:AC:00:15:2C
HP-P10000-2                                            True POD-22, interconnect 1_FC ... 20:52:00:02:AC:00:15:2C
Prod ESXi Server Bay 09                               False POD-22, interconnect 1_FC ... 10:00:66:03:6C:70:00:00
Prod ESXi Server Bay 09                               False POD-22, interconnect 2_FC ... 10:00:66:03:6C:70:00:02


[PS] C:\Users\clynch> $resp.members | ft -Property devicename,isOnline,sanName,wwn,zonename -auto

deviceName              isOnline sanName                            wwn                     zoneName
----------              -------- -------                            ---                     --------
HP-P10000-2                 True POD-22, interconnect 2_FC direct-b 21:52:00:02:AC:00:15:2C
HP-P10000-2                 True POD-22, interconnect 1_FC direct-a 20:52:00:02:AC:00:15:2C
Prod ESXi Server Bay 09    False POD-22, interconnect 1_FC direct-a 10:00:66:03:6C:70:00:00
Prod ESXi Server Bay 09    False POD-22, interconnect 2_FC direct-b 10:00:66:03:6C:70:00:02






	#>


}

function Set-HPOVSanManager 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding()]
    Param 
	(

        [parameter(Mandatory, ValueFromPipeline, HelpMessage = "Enter the SAN Manager Hostname or IP Address.", Position = 0, ParameterSetName = "HPCisco")]
        [parameter(Mandatory, ValueFromPipeline, HelpMessage = "Enter the SAN Manager Hostname or IP Address.", Position = 0, ParameterSetName = "BNA")]
		[Alias('name')]
        [ValidateNotNullOrEmpty()]
        [object]$Resource,

        [parameter(Mandatory = $false, HelpMessage = "Enter the SAN Manager Hostname or IP Address.", Position = 1, ParameterSetName = "HPCisco")]
        [parameter(Mandatory = $false, HelpMessage = "Enter the SAN Manager Hostname or IP Address.", Position = 1, ParameterSetName = "BNA")]
        [ValidateNotNullOrEmpty()]
        [string]$Hostname = $null,

		[parameter(Mandatory = $false, HelpMessage = "Enter the SAN Manager TCP Port (HTTPS port for BNA, SNMP Port for HP).", Position = 2, ParameterSetName = "HPCisco")]
        [parameter(Mandatory = $false, HelpMessage = "Enter the SAN Manager TCP Port (HTTPS port for BNA, SNMP Port for HP).", Position = 2, ParameterSetName = "BNA")]
        [ValidateNotNullOrEmpty()]
        [ValidateRange(1,65535)]
        [int]$Port = 0,
         
		[parameter(Mandatory = $false, HelpMessage = "Enter the administrative user name (i.e. Administrator).", Position = 3, ParameterSetName = "HPCisco")]
        [parameter(Mandatory = $false, HelpMessage = "Enter the administrative user name (i.e. Administrator).", Position = 3, ParameterSetName = "BNA")]
        [ValidateNotNullOrEmpty()]
        [string]$Username = $Null,

		[parameter(Mandatory = $false, HelpMessage = "Enter the administrative account password (i.e. password).", Position = 4, ParameterSetName = "HPCisco")]
        [parameter(Mandatory = $false, HelpMessage = "Enter the administrative account password (i.e. password).", Position = 4, ParameterSetName = "BNA")]
        [ValidateNotNullOrEmpty()]
        [string]$Password = $Null,

		[parameter(Mandatory = $false, HelpMessage = "Enter the SNMPv3 User Account.", ParameterSetName = "HPCisco")]
		[string]$SnmpUserName,

		[parameter(Mandatory = $false, HelpMessage = "Enter the SNMPv3 Authentication Level 'None', 'AuthOnly', or 'AuthAndPriv'", ParameterSetName = "HPCisco")]
		[ValidateSet("None","AuthOnly","AuthAndPriv")]
		[ValidateNotNullOrEmpty()]
		[string]$SnmpAuthLevel = "None",

		[parameter(Mandatory = $false, HelpMessage = "Enter the SNMPv3 Authentication Encryption Protocol SHA or MD5", ParameterSetName = "HPCisco")]
		[ValidateSet("sha","md5")]	
		[ValidateNotNullOrEmpty()]
		[string]$SnmpAuthProtocol,

		[parameter(Mandatory = $false, HelpMessage = "Enter the SNMPv3 Authentication account password (i.e. password).", ParameterSetName = "HPCisco")]
		[ValidateNotNullOrEmpty()]
		[string]$SnmpAuthPassword,

		[parameter(Mandatory = $false, HelpMessage = "Enter the SNMPv3 Privacy Protocol DES or AES", ParameterSetName = "HPCisco")]
		[ValidateSet("aes-128","des56","3des")]	
		[ValidateNotNullOrEmpty()]
		[string]$SnmpPrivProtocol,

		[parameter(Mandatory = $false, HelpMessage = "Enter the SNMPv3 Privacy Password", ParameterSetName = "HPCisco")]
		[ValidateNotNullOrEmpty()]
		[string]$SnmpPrivPassword,

	    [parameter(Mandatory = $false, ParameterSetName = "BNA")]
	    [switch]$EnableSsl,

		[switch]$DisableSsl,

		[parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "HPCisco")]
		[parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "BNA")]
		[ValidateNotNullorEmpty()]
		[object]$ApplianceConnection = $null

    )

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSBoundParameters['Resource']))
		{

			$PipelineInput = $True

		}

		else
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

			if (-not($ApplianceConnection -is [HPOneView.Appliance.Connection]) -and (-not($ApplianceConnection -is [System.String])))
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException InvalidApplianceConnectionDataType InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter is not type [HPOneView.Appliance.Connection] or [System.String].  Please correct this value and try again.'
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			elseif  ($ApplianceConnection.Count -gt 1)
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException MultipleApplianceConnections InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter contains multiple Appliance Connections.  This CMDLET only supports 1 Appliance Connection in the ApplianceConnect parameter value.  Please correct this and try again.'
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			else
			{

				Try 
				{
	
					$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

				}

				Catch [HPOneview.Appliance.AuthSessionException] 
				{

					$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError 'ApplianceConnection' -TargetType $ApplianceConnection.GetType().Name -Message $_.Exception.Message -InnerException $_.Exception
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				Catch 
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

			}

		}

		$_ResourceUpdateStatus = New-Object System.Collections.ArrayList

    }

    process
	{

		switch ($Resource.GetType().Name)
		{

			'PSCustomObject'
			{

				"[$($MyInvocation.InvocationName.ToString().ToUpper())] Object received: {0}" -f ($Resource | Out-String) | Write-Verbose

				#Generate error if wrong resource type
				if ($Resource.category -ne 'fc-device-managers')
				{

					$errorRecord = New-ErrorRecord HPOneView.SanManagerResourceException InvalidSanManagerResource InvalidArgument 'Resource' -TargetType 'PSObject' -Message ("The provided Resource object is not a SAN Manager resource.  Expected resource category 'fc-device-managers'.  Received reource category {0}. Please check the value and try again." -f $Resource.category)

					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				#Generate error if wrong resource type
				if (-not($Resource.ApplianceConnection))
				{

					$errorRecord = New-ErrorRecord HPOneView.SanManagerResourceException InvalidSanManagerResource InvalidArgument 'Resource' -TargetType 'PSObject' -Message "The provided Resource object is missing the required ApplianceConnection property. Please check the value and try again."

					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

			}

			'String'
			{

				"[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting SAN Manager by resource Name: {0}" -f $Resource | Write-Verbose

				Try
				{

					$Resource = Get-HPOVSanManager $Resource -ApplianceConnection $ApplianceConnection

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}
				

			}



		}

		$_UpdatedSanManager = [PSCustomObject]@{
			connectionInfo = New-Object System.Collections.ArrayList; 
			eTag           = $Resource.eTag
		}

        switch ($PSBoundParameters.keys)
		{

			'Hostname'
			{

				[void]$_UpdatedSanManager.connectionInfo.Add(@{name = "Host"; value = $Hostname})

			}

			'Port'
			{
			
				[void]$_UpdatedSanManager.connectionInfo.Add(@{name = "Port"; value = $Port})
					
			}

			'Username'
			{
			
				[void]$_UpdatedSanManager.connectionInfo.Add(@{name = "Username"; value = $Username})
			
			}

			'Password'
			{

				[void]$_UpdatedSanManager.connectionInfo.Add(@{name = "Password"; value = $Passwords})

			}

			'SnmpUserName'
			{

				[void]$_UpdatedSanManager.connectionInfo.Add(@{name = "SnmpUserName"; value = $SnmpUserName})

			}

			'SnmpAuthLevel'
			{

				[void]$_UpdatedSanManager.connectionInfo.Add(@{name = "SnmpAuthLevel"; value = $SnmpAuthLevel})

			}
			
			'SnmpAuthProtocol'
			{

				[void]$_UpdatedSanManager.connectionInfo.Add(@{name = "SnmpAuthProtocol"; value = $SnmpAuthProtocol})

			}
			
			'SnmpAuthPassword'
			{

				[void]$_UpdatedSanManager.connectionInfo.Add(@{name = "SnmpAuthPassword"; value = $SnmpAuthPassword})

			}
			
			'SnmpPrivProtocol'
			{

				[void]$_UpdatedSanManager.connectionInfo.Add(@{name = "SnmpPrivProtocol"; value = $SnmpPrivProtocol})

			}
			
			'SnmpPrivPassword'
			{

				[void]$_UpdatedSanManager.connectionInfo.Add(@{name = "SnmpPrivPassword"; value = $SnmpPrivPassword})

			}
			
			'UseSsl'
			{

				[void]$_UpdatedSanManager.connectionInfo.Add(@{name = "UseSsl"; value = $UseSsl})

			}

		}

        "[$($MyInvocation.InvocationName.ToString().ToUpper())] Updated SAN Manager: {0}" -f ($_UpdatedSanManager | out-string) | Write-Verbose 

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request"

		Try
		{

			$resp = Send-HPOVRequest $Resource.uri PUT $_UpdatedSanManager -ApplianceConnection $Resource.ApplianceConnection.Name

		}

		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}
     
		[void]$_ResourceUpdateStatus.Add($resp)
		   
	}
		
	End
	{
        return $_ResourceUpdateStatus

    }

}

function Update-HPOVSanManager 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding()]
    Param 
	(

        [parameter(Position = 0, Mandatory, ValueFromPipeline, HelpMessage = "Enter the Managed SAN Name.")]
        [ValidateNotNullOrEmpty()]
        [Alias('Name')]
        [Object]$SANManager = $Null,
		
		[parameter(Position = 1, ValueFromPipelineByPropertyName, Mandatory)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Object]$ApplianceConnection

    )

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSBoundParameters['SANManager']))
		{

			$PipelineInput = $True

		}

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if (-not($ApplianceConnection -is [HPOneView.Appliance.Connection]) -and (-not($ApplianceConnection -is [System.String])) -and (-not($PipelineInput)))
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException InvalidApplianceConnectionDataType InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter is not type [HPOneView.Appliance.Connection] or [System.String].  Please correct this value and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif (($ApplianceConnection | Measure-Object).Count -gt 1 -and (-not($PipelineInput)))
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException MultipleApplianceConnections InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter contains multiple Appliance Connections.  This CMDLET only supports 1 Appliance Connection in the ApplianceConnect parameter value.  Please correct this and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif (-not($PipelineInput))
		{

			Try 
			{
	
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError 'ApplianceConnection' -TargetType $ApplianceConnection.GetType().Name -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_.Exception)

			}

		}

		$_SanManagerRefreshCollection = New-OBject System.Collections.ArrayList
    
    }

    process 
	{

        $request = [PsCustomObject]@{refreshState = "RefreshPending"}

		#Validate input object type
        #Checking if the input is System.String and is NOT a URI
        if ($SANManager -is [string]) 
		{
            
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] SANManager Name: $($SANManager)"

            Try
			{

				$SANManager = Send-HPOVSanManager $SANManager -Hostname $ApplianceConnection

			}
			
			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

        }

        #Checking if the input is PSCustomObject, and the category type is server-profiles, which could be passed via pipeline input
        elseif (($SANManager -is [System.Management.Automation.PSCustomObject]) -and ($SANManager.category -ieq "fc-device-managers")) 
		{

            "[$($MyInvocation.InvocationName.ToString().ToUpper())] SANManager is an object: {0}" -f $SANManager.name | Write-Verbose 
        
        }

        else 
		{

            $errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'SANManager' -TargetType $SANManager.GetType().Name -Message "The parameter 'SANManager' value is invalid.  Please validate the 'SANManager' parameter value you passed and try again."
            $pscmdlet.ThrowTerminatingError($errorRecord)

        }

		if ($SANManager.isInternal)
		{

			"[$($MyInvocation.InvocationName.ToString().ToUpper())] '{0}' SAN Manager is internal.  Skipping." -f $SANManager.name | Write-Verbose 

		}

		else
		{

			"[$($MyInvocation.InvocationName.ToString().ToUpper())] Refreshing SAN Manager resource: {0}" -f $SANManager.name | Write-Verbose 
	    
			Try
			{

				$_resp = Send-HPOVRequest $SANManager.uri PUT $request -Hostname $ApplianceConnection.Name
		
			}
	    
			Catch
			{
	    
	    		$PSCmdlet.ThrowTerminatingError($_)
		
			}

			[void]$_SanManagerRefreshCollection.Add($_resp)

		}

    }

    end 
	{

        Return $_SanManagerRefreshCollection

    }

}

function Remove-HPOVSanManager 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding(SupportsShouldProcess = $True,ConfirmImpact = 'High')]
    Param 
	(

        [parameter(Mandatory, ValueFromPipeline, HelpMessage = "Enter the SAN Manager Name, or provide SAN Manager Resource.", Position = 0)]
        [ValidateNotNullOrEmpty()]
        [Alias('Name')]
        [object]$SanManager = $Null,
	
		[parameter(position = 1, Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "default")]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = $Null

    )

    Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSboundParameters['SanManager']))
		{

			$PipelineInput = $True

		}

		else
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

			$c = 0

			ForEach ($_Connection in $ApplianceConnection) 
			{

				Try 
				{
	
					$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

				}

				Catch [HPOneview.Appliance.AuthSessionException] 
				{

					$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				Catch 
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

				$c++

			}

		}

		$_TaskCollection       = New-Object System.Collections.ArrayList
		$_SanManagerCollection = New-Object System.Collections.ArrayList
   
    }


    process 
	{

		if ($PipelineInput) 
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Pipeline input"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] San Manager Object provided: $($SanManager | FL * | Out-String)"

			If ('fc-device-managers' -contains $SanManager.category)
			{

				If (-not($SanManager.ApplianceConnection))
				{

					$errorRecord = New-ErrorRecord HPOneView.SanManagerResourceException InvalidArgumentValue InvalidArgument "SanManager:$($SanManager.Name)" -TargetType PSObject -Message "The SanManager object resource provided is missing the source ApplianceConnection property.  Please check the object provided and try again."
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				[void]$_SanManagerCollection.Add($SanManager)

			}

			else
			{

				$errorRecord = New-ErrorRecord HPOneView.SanManagerResourceException InvalidArgumentValue InvalidArgument "SanManager:$($SanManager.Name)" -TargetType PSObject -Message "The SanManager object resource is not an expected category type [$(SanManager.category)].  The allowed resource category type is 'fc-device-managers'.  Please check the object provided and try again."
                $PSCmdlet.ThrowTerminatingError($errorRecord)

			}

		}

		else 
		{

			ForEach ($_Connection in $ApplianceConnection)
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Appliance $($_Connection.Name) (of $($ApplianceConnection.Count))"

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing SanManager Name $($SanManager)"

				Try
				{

					$_SanManager = Get-HPOVSanManager $SanManager -ApplianceConnection $_Connection

					$_SanManager | % {

						[void]$_SanManagerCollection.Add($_)

					}

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}				

			}

		}

    }

	End
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Begin resource removal process."

	    foreach ($_sm in $_SanManagerCollection) 
		{

            if ($PSCmdlet.ShouldProcess($_sm.name,"Remove SAN Manager from appliance '$($_sm.ApplianceConnection.Name)'"))
			{   
             
                
				Try
				{
					
					$_task = Send-HPOVRequest $_sm.uri DELETE -Hostname $_sm.ApplianceConnection.Name

					[void]$_TaskCollection.Add($_task)

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

            }

			elseif ($PSBoundParameters['WhatIf'])
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Caller passed -WhatIf parameter."

			}

			else
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Caller selected NO to confirmation prompt."

			}

        }

		Return $_TaskCollection

	}

}

function Get-HPOVManagedSan 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding()]
    Param 
	(

        [parameter(Mandatory = $false, HelpMessage = "Enter the Managed SAN Name.")]
        [ValidateNotNullOrEmpty()]
        [Alias('Fabric')]
        [string]$Name = $null,

		[parameter(Mandatory = $false, HelpMessage = "Enter the Appliance Name or Object")]
		[ValidateNotNullOrEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

    )

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$ManagedSansCollection = New-Object System.Collections.ArrayList
        
	}
	
	Process 
	{

		ForEach ($_connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_connection.Name)' Appliance (of $($Appliance.Count))"

			$uri = $fcManagedSansUri + '?sort=name:asc'

			if ($Name)
			{

				$Name = $Name -replace ("[*]","%25") -replace ("[&]","%26")

				$uri += "&query=lower(name) like '{0}'" -f $Name.ToLower()

			}
			
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting list of Managed SANs"
			
			Try
			{

				$_managedSans = Send-HPOVRequest $uri -Hostname $_connection.Name

			}
			
			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			if ($_managedSans.count -eq 0 -and $Name) 
			{

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Woops! Requested Managed SAN '$($_managedSans)' not found."
                    
                $errorRecord = New-ErrorRecord InvalidOperationException ManagedSanResourceNotFound ObjectNotFound 'Name' -Message "Request Managed SAN '$($Name)' not found on appliance $($_connection.Name).  Please check the name and try again."
                    
                #Generate Terminating Error
                $PSCmdlet.ThrowTerminatingError($errorRecord)

            }

			else
			{

				$_managedSans.members | % { 
					
					$_.PSObject.TypeNames.Insert(0,"HPOneView.Storage.ManagedSan")
				
					[void]$ManagedSansCollection.Add($_)

				}

			}

		}

	}

	End 
	{

		return $ManagedSansCollection 
    
    }

}

function Set-HPOVManagedSan 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding(DefaultParameterSetName = "Enable")]
    Param 
	(

        [parameter(Mandatory, HelpMessage = "Enter the Managed SAN Name.",ValueFromPipeline, ParameterSetName = "Enable", position=0)]
        [parameter(Mandatory, HelpMessage = "Enter the Managed SAN Name.",ValueFromPipeline, ParameterSetName = "Disable", position=0)]
        [parameter(Mandatory, HelpMessage = "Enter the Managed SAN Name.",ValueFromPipeline, ParameterSetName = "DisableAlias", position=0)]
        [ValidateNotNullOrEmpty()]
        [Alias('Fabric','Name','ManagedSan')]
        [object]$Resource,

        [parameter(Mandatory = $false, HelpMessage = "Enable Automated Zoning for the specified Managed SAN.", ParameterSetName = "Enable")]
        [parameter(Mandatory = $false, HelpMessage = "Enable Automated Zoning for the specified Managed SAN.", ParameterSetName = "DisableAlias")]
        [Alias('ZoningEnable','Enable')]
        [switch]$EnableAutomatedZoning,

        [parameter(Mandatory = $false, HelpMessage = "Disable Automated Zoning for the specified Managed SAN.", ParameterSetName = "Disable")]
        [Alias('ZoningDisable','Disable')]
        [switch]$DisableAutomatedZoning,

        [parameter(Mandatory = $false, HelpMessage = "helpmsg", ParameterSetName = "Enable")]
        [parameter(Mandatory = $false, HelpMessage = "helpmsg", ParameterSetName = "Disable")]
        [parameter(Mandatory = $false, HelpMessage = "helpmsg", ParameterSetName = "DisableAlias")]
		[ValidateSet('SingleInitiatorAllTargets','SingleInitiatorSingleStorageSystem','SingleInitiatorSingleTarget')]
		[ValidateNotNullOrEmpty()]
		[string]$ZoningPolicy = 'SingleInitiatorAllTargets',
      
        [parameter(Mandatory = $false, ParameterSetName = "Enable")]
        [switch]$EnableAliasing,

        [parameter(Mandatory = $false, ParameterSetName = "DisableAlias")]
        [switch]$DisableAliasing,

        [parameter(Mandatory = $false, HelpMessage = "helpmsg", ParameterSetName = "Enable")]
		[ValidateNotNullOrEmpty()]
		[string]$InitiatorNameFormat,

        [parameter(Mandatory = $false, HelpMessage = "helpmsg", ParameterSetName = "Enable")]
		[ValidateNotNullOrEmpty()]
		[string]$TargetGroupNameFormat,

        [parameter(Mandatory = $false, HelpMessage = "helpmsg", ParameterSetName = "Enable")]
		[ValidateNotNullOrEmpty()]
		[string]$TargetNameFormat,

        [parameter(Mandatory = $false, HelpMessage = "helpmsg", ParameterSetName = "Enable")]
		[ValidateNotNullOrEmpty()]
		[string]$ZoneNameFormat,

		[parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "Enable")]
		[parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "Disable")]
		[parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "DisableAlias")]
		[ValidateNotNullorEmpty()]
		[object]$ApplianceConnection = $null

    )

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSBoundParameters['Resource']))
		{

			$PipelineInput = $True

		}

		else
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

			if (-not($ApplianceConnection -is [HPOneView.Appliance.Connection]) -and (-not($ApplianceConnection -is [System.String])))
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException InvalidApplianceConnectionDataType InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter is not type [HPOneView.Appliance.Connection] or [System.String].  Please correct this value and try again.'
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			elseif  ($ApplianceConnection.Count -gt 1)
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException MultipleApplianceConnections InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter contains multiple Appliance Connections.  This CMDLET only supports 1 Appliance Connection in the ApplianceConnect parameter value.  Please correct this and try again.'
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			else
			{

				Try 
				{
	
					$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

				}

				Catch [HPOneview.Appliance.AuthSessionException] 
				{

					$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError 'ApplianceConnection' -TargetType $ApplianceConnection.GetType().Name -Message $_.Exception.Message -InnerException $_.Exception
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				Catch 
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

			}

		}

		$_ResourceUpdateStatus = New-Object System.Collections.ArrayList

    }

    process 
	{

       switch ($Resource.GetType().Name)
		{

			'PSCustomObject'
			{

				"[$($MyInvocation.InvocationName.ToString().ToUpper())] Object received: {0}" -f ($Resource | Out-String) | Write-Verbose

				#Generate error if wrong resource type
				if ($Resource.category -ne 'fc-sans')
				{

					$errorRecord = New-ErrorRecord HPOneView.ManagedSanResourceException InvalidManagedSanResource InvalidArgument 'Resource' -TargetType 'PSObject' -Message ("The provided Resource object is not a Managed SAN resource.  Expected resource category 'fc-sans'.  Received reource category {0}. Please check the value and try again." -f $Resource.category)

					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				#Generate error if wrong resource type
				if (-not($Resource.ApplianceConnection))
				{

					$errorRecord = New-ErrorRecord HPOneView.SanManagerResourceException InvalidSanManagerResource InvalidArgument 'Resource' -TargetType 'PSObject' -Message "The provided Resource object is missing the required ApplianceConnection property. Please check the value and try again."

					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}
				
				if ($Resource.isInternal)
				{

					$errorRecord = New-ErrorRecord HPOneView.SanManagerResourceException InvalidSanManagerResource InvalidArgument 'Resource' -TargetType 'PSObject' -Message "The provided Resource object is an Internal SAN Manager and unsupported with this Cmdlet. Please check the value and try again."

					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

			}

			'String'
			{

				"[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Managed SAN by resource Name: {0}" -f $Resource | Write-Verbose

				Try
				{

					$Resource = Get-HPOVManagedSan $Resource -ApplianceConnection $ApplianceConnection

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

			}

		}

        "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '{0}'" -f $Resource.name | Write-Verbose 

		#Disable zoning
		if ($DisableAutomatedZoning.IsPresent)
		{ 
                
            $Resource.sanPolicy.zoningPolicy = "NoZoning"

            #Need to disable Aliasing Support as well with the request
            $Resource.sanPolicy.enableAliasing = $false
                    
        }

		else
		{

			$Resource.sanPolicy.zoningPolicy = $ZoningPolicy

			if ($EnableAliasing.IsPresent) 
			{ 

				$Resource.sanPolicy.enableAliasing = $True

				if ($InitiatorNameFormat)   { $Resource.sanPolicy.initiatorNameFormat   = $InitiatorNameFormat }
				if ($TargetGroupNameFormat) { $Resource.sanPolicy.targetGroupNameFormat = $TargetGroupNameFormat }
				if ($TargetNameFormat)      { $Resource.sanPolicy.targetNameFormat      = $TargetNameFormat }
				if ($ZoneNameFormat)        { $Resource.sanPolicy.zoneNameFormat        = $ZoneNameFormat }
                    
			}
			
			elseif ($DisableAliasing.IsPresent) 
			{ 
				
				$Resource.sanPolicy.enableAliasing = $false 
			
			}

		}

        "[$($MyInvocation.InvocationName.ToString().ToUpper())] Updated Managed SAN Object: {0}" -f ($Resource | out-string) | Write-Verbose 

		Try
		{

			$_Resp = Send-HPOVRequest $Resource.uri PUT $Resource -Hostname $Resource.ApplianceConnection.Name

			$_Resp | % { $_.PSObject.TypeNames.Insert(0,'HPOneView.Storage.ManagedSan') }

			[void]$_ResourceUpdateStatus.Add($_Resp)

		}

		Catch
		{

			$_ResourceUpdateStatus

			$PSCmdlet.ThrowTerminatingError($_)

		}
       
    }

    end 
	{
        
        Return $_ResourceUpdateStatus

    }

}

#######################################################
# Unmanaged Devices: 
#

function Get-HPOVUnmanagedDevice 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding(DefaultParameterSetName='Default')]

    Param 
	(

        [Parameter(Mandatory = $false, Position = 0, ParameterSetName = 'Default', HelpMessage = "Enter the name of the unmanaged device.")]
        [String]$Name,

        [Parameter(Mandatory = $false, ParameterSetName = 'Default')]
        [Alias('report')]
        [Switch]$List,

		[parameter(Mandatory = $false)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

    )
	
	Begin 
	{

		if ($PSBoundParameters['List'])
		{

			Write-Warning "The List parameter has been deprecated.  The CMDLET will now display object data in Format-List view."

		}

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		ForEach ($_connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_UnmanagedDevicesCollection = New-Object System.Collections.ArrayList
            
    }

    Process 
	{

		ForEach ($_connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request"

			Try
			{

				$_UnmanagedDevices = Send-HPOVRequest $unmanagedDevicesUri -Hostname $_connection.Name

			}
			
			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			if ($_UnmanagedDevices.count -eq 0 -and (-not ($Name))) 
			{  
				
				Write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No unmanaged devices found." 
			
			}

			else 
			{

			    #Look for the specified name
			    If ($Name) 
				{ 
					
					$_UnmanagedDevices.members = $_UnmanagedDevices.members | ? name -like $Name

					$_UnmanagedDevices.count = ($_UnmanagedDevices.members | Measure-Object).count
			    
			        #If not found, throw error
			        if ($_UnmanagedDevices.count -eq 0) 
					{ 

						Write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $($_UnmanagedDevices | Out-String)"

			            $errorRecord = New-ErrorRecord HPOneview.UnmanagedDeviceResourceException UnmangedDeviceResouceNotFound ObjectNotFound 'Name' -Message "The '$($Name)' Unmanaged Device resource was not found on '$($_connection.Name)' Appliance. Please check the name and try again."
			            $PSCmdlet.ThrowTerminatingError($errorRecord)
			        
			        }

			    }

				if ($_UnmanagedDevices.members)
				{

					$_UnmanagedDevices.members | % {

						$_.PSObject.TypeNames.Insert(0,"HPOneView.UnmanagedResource")

						[void]$_UnmanagedDevicesCollection.Add($_)

					}

				}			

			}

		}

	}

	End 
	{

		Return $_UnmanagedDevicesCollection

    }

}

function New-HPOVUnmanagedDevice 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding(DefaultParameterSetName='Default')]

    Param 
	(

        [Parameter(Mandatory = $true, Position = 0, ParameterSetName = 'Default', HelpMessage = "Enter the name of the unmanaged device.")]
        [ValidateNotNullOrEmpty()]
        [String]$Name,

        [Parameter(Mandatory = $true, Position = 1, ParameterSetName = 'Default', HelpMessage = "Provide a device model description (e.g. HPN 5900CP).")]
        [ValidateNotNullOrEmpty()]
        [string]$Model,

        [Parameter(Mandatory = $false, Position = 2, ParameterSetName = 'Default', HelpMessage = "Enter the Rack Unit height (e.g. 1).")]
        [ValidateNotNullOrEmpty()]
        [int]$Height = 1,

        [Parameter(Mandatory = $true, Position = 3, ParameterSetName = 'Default', HelpMessage = "Enter the max power consumption in WATTS (e.g. 300).")]
        [ValidateNotNullOrEmpty()]
        [int]$MaxPower,

		[Parameter(Mandatory = $false, Position = 4, ParameterSetName = 'Default', HelpMessage = "Enter the device MAC Address(e.g. AA:BB:CC:DD:EE:FF).")]
        [ValidateNotNullOrEmpty()]
		[string]$MacAddress,

		[Parameter(Mandatory = $false, Position = 5, ParameterSetName = 'Default', HelpMessage = "Enter the device's management IPV4 Address (e.g. 10.1.1.10).")]
        [ValidateScript({if (-not([IPAddress]::TryParse($_,[ref]$null))) { Throw 'The provided IPV4Address value does not appear to be a valid IPv4 Address.' } else { $True }})]
		[string]$IPV4Address,

		[Parameter(Mandatory = $false, Position = 6, ParameterSetName = 'Default', HelpMessage = "Enter the device's management IPV6 Address (e.g. fe80::200:f8ff:fe21:67cf).")]
        [ValidateScript({if (-not([IPAddress]::TryParse($_,[ref]$null))) { Throw 'The provided IPV6Address value does not appear to be a valid IPv6 Address.' } else { $True }})]
		[string]$IPV6Address,

		[parameter(Mandatory)]
		[Alias('Appliance')]
		[Object]$ApplianceConnection = $null

    )

	Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		Try 
		{
	
			$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

		}

		Catch [HPOneview.Appliance.AuthSessionException] 
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $ApplianceConnection -Message $_.Exception.Message -InnerException $_.Exception
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		Catch 
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

		if (-not($PSBoundParameters['LogicalInterconnectGroupMapping']))
		{

			$PipelineInput = $true

		}

		$_UnmanagedDeviceCreateResults = New-Object System.Collections.ArrayList
    }

    Process 
	{
        
        $_NewDevice = NewObject -UnmanagedDevice

		[string]$_NewDevice.name        = $Name
		[string]$_NewDevice.model       = $Model
		[int]$_NewDevice.height         = $Height
		[string]$_NewDevice.mac         = $MacAddress
		[string]$_NewDevice.ipv4Address = $IPV4Address
		[string]$_NewDevice.ipv6Address = $IPV6Address
		[int]$_NewDevice.maxPwrConsumed = $MaxPower

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] New Unmanaged Device:  $($newDevice)"

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request"

		Try
		{

			$_resp = Send-HPOVRequest $unmanagedDevicesUri POST $_NewDevice -Hostname $ApplianceConnection.Name

		}

		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

		$_resp | % { $_.PSObject.TypeNames.Insert(0,"HPOneView.UnmanagedResource") }

        [void]$_UnmanagedDeviceCreateResults.Add($_resp)

    }

	End
	{

		Return $_UnmanagedDeviceCreateResults

	}

}

function Remove-HPOVUnmanagedDevice 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "default",SupportsShouldProcess = $True,ConfirmImpact = 'High')]

    Param 
	(

        [parameter(Mandatory, ValueFromPipeline, ParameterSetName = "default", HelpMessage = "Enter the the Unmanaged Device to be removed.")]
        [ValidateNotNullOrEmpty()]
        [Alias("uri","name")]
        [object]$UnmanagedDevice = $null,

	    [parameter(Mandatory = $false)]
	    [switch]$force,
	
		[parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "default", position = 1)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = $Null

    )

    Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		if (-not($PSBoundParameters['UnmanagedDevice'])) { $PipelineInput = $True }

		$_TaskCollection            = New-Object System.Collections.ArrayList
		$_UnmanagedDeviceCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{

		if ($PipelineInput) 
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Pipeline input"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User Object provided: $($Name | FL * | Out-String)"

			If ('unmanaged-devices' -contains $UnmanagedDevice.category)
			{

				If (-not($UnmanagedDevice.ApplianceConnection))
				{

					$errorRecord = New-ErrorRecord HPOneView.UnmanagedDeviceResourceException InvalidArgumentValue InvalidArgument "UnmanagedDevice:$($UnmanagedDevice.Name)" -TargetType PSObject -Message "The UnmanagedDevice object resource provided is missing the source ApplianceConnection property.  Please check the object provided and try again."
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				[void]$_UnmanagedDeviceCollection.Add($UnmanagedDevice)

			}

			else
			{

				$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument "UnmanagedDevice:$($UnmanagedDevice.Name)" -TargetType PSObject -Message "The UnmanagedDevice object resource is not an expected category type [$($UnmanagedDevice.category)].  The allowed resource category type is 'unmanaged-devices'.  Please check the object provided and try again."
                $PSCmdlet.ThrowTerminatingError($errorRecord)

			}

		}

		else 
		{

			ForEach ($_Connection in $ApplianceConnection)
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Appliance $($_Connection.Name) (of $($ApplianceConnection.Count))"

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Unmanaged Device Name $($UnmanagedDevice)"

				Try
				{

					$_UnmanagedDevice = Get-HPOVUnmanagedDevice $UnmanagedDevice -ApplianceConnection $_Connection

					$_UnmanagedDevice | % {

						[void]$_UnmanagedDeviceCollection.Add($_)

					}

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}				

			}

		}

    }

	End
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing $($_UnmanagedDeviceCollection.count) object resources to remove."

		#Process Unmanaged Device Resources
		ForEach ($_device in $_UnmanagedDeviceCollection)
		{

			if ($pscmdlet.ShouldProcess($_device.ApplianceConnection.Name,"Remove Unmanaged Device '$($_device.name)' from appliance")) 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Removing Unmanaged Device '$($_device.name)' from appliance '$($_device.ApplianceConnection.Name)'."

				Try
				{

					$_resp = Send-HPOVRequest $_device.Uri DELETE -Hostname $_device.ApplianceConnection.Name

					$_resp | Add-Member -NotePropertyName Name -NotePropertyValue $_device.name

					[void]$_TaskCollection.Add($_resp)

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

			}

			elseif ($PSBoundParameters['WhatIf'])
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] WhatIf parameter was passed."

			}

		}

		Return $_TaskCollection

    }

}

#######################################################
# Power Delivery Devices
#

function Get-HPOVPowerDevice 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding()]
	Param 
	(

		[parameter(Mandatory = $false, Position = 0)]
		[string]$Name = $null,
        
        [parameter(Mandatory = $false)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}
	
	)

    Begin 
    {

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
            {
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
            {

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
            {

				$PSCmdlet.ThrowTerminatingError($_.Exception)

			}

			$c++

		}
        
        $_Collection = New-Object System.Collections.ArrayList
    }

    Process 
	{

        ForEach ($_Connection in $ApplianceConnection) 
		{

			Try
			{

				$ipdus = Send-HPOVRequest $powerDevicesUri -appliance $_Connection #($powerDevicesUri + "?filter=`"name matches '$name'`"")

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}            

            $ipdus.members | % { $_.psobject.typenames.Insert(0,”HPOneView.PowerDeliveryDevice") }

            if ($Name) 
			{ 

                $ipdus.members | ? name -eq $Name | % { [void]$_Collection.Add($_) }

            }

            else 
			{ 

                $ipdus.members | % { [void]$_Collection.Add($_) }

            }

        }

    }

    End 
	{

        if (-not ($_Collection) -and $Name) 
		{

            $errorRecord = New-ErrorRecord HPOneView.PowerDeliveryDeviceException ResourceNotFound ObjectNotFound "Name" -Message "The specific '$name' iPDU was not found."
            $pscmdlet.WriteError($errorRecord)

        }

		Write-Verbose "Done. $($_Collection.count) Power Delivery Device(s) found."

        Return $_Collection
        
    }

}

function Add-HPOVPowerDevice 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding(SupportsShouldProcess = $true,ConfirmImpact = "High")]
    Param 
	(

        [parameter(Mandatory, HelpMessage = "Enter the host name (FQDN) or IP of the iPDU's management processor.", Position = 0)]
        [ValidateNotNullOrEmpty()]
        [string]$Hostname,
         
        [parameter(Mandatory, HelpMessage = "Enter the iPDU administrative user name.", Position = 1)]
        [ValidateNotNullOrEmpty()]
        [string]$Username = "",

        [parameter(Mandatory, HelpMessage = "Enter the iPDU administrative account password.", Position = 2)]
        [ValidateNotNullOrEmpty()]
        [string]$Password = "",

	    [parameter(Mandatory = $false)]
	    [switch]$Force,

		[parameter(Mandatory)]
		[ValidateNotNullorEmpty()]
		[object]$ApplianceConnection = $null

    )

	Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if (-not($ApplianceConnection -is [HPOneView.Appliance.Connection]) -and (-not($ApplianceConnection -is [System.String])))
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException InvalidApplianceConnectionDataType InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter is not type [HPOneView.Appliance.Connection] or [System.String].  Please correct this value and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif  ($ApplianceConnection.Count -gt 1)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException MultipleApplianceConnections InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter contains multiple Appliance Connections.  This CMDLET only supports 1 Appliance Connection in the ApplianceConnect parameter value.  Please correct this and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		else
		{

			Try 
			{
	
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError 'ApplianceConnection' -TargetType $ApplianceConnection.GetType().Name -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}

		$colStatus = New-Object System.Collections.ArrayList

    }

    Process 
	{

        #Locate the Enclosure Group specified
        write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Starting"

        $_import = NewObject -PowerDeliveryDeviceAdd
		
        $_import.hostname = $hostname
        $_import.username = $username
        $_import.password = $password
        $_import.force    = $Force.IsPresent

        write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Sending request to add iPDU."

		Try
		{

			$_resp = Send-HPOVRequest $powerDevicesDiscoveryUri POST $_import -Hostname $ApplianceConnection.Name

		}

		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}
        
        #Wait for task to get into Starting stage
        Try
		{

			$_resp = Wait-HPOVTaskStart $_resp

		}

		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}
            
        write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Task response: $($_resp | out-string)"

        #Check to see if the task errored, which should be in the Task Validation stage
        if ($_resp.taskState -ne "Running" -and $_resp.taskState -eq "Error" -and $_resp.stateReason -eq "ValidationError") 
		{

            write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Task error found $($resp.taskState) $($resp.stateReason) "

            if ($_resp.taskerrors | Where-Object { $_.errorCode -eq "PDD_IPDU_TRAPRECEIVERACCOUNT_TAKEN" }) 
			{
                        
                $_errorMessage = $_resp.taskerrors | Where-Object { $_.errorCode -eq "PDD_IPDU_TRAPRECEIVERACCOUNT_TAKEN" }

                $_externalManagerIP = $_errorMessage.data.mgmtSystemIP

				Try
				{

					$_externalManagerFQDN = [System.Net.DNS]::GetHostByAddress($_externalManagerIP)

				}

				Catch
				{

					write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Couldn't resolve $_externalManagerIP to FQDN [$($_.Exception.Message)]."

					$_externalManagerFQDN = [PSCustomObject]@{HostName = $_externalManagerIP}

				}
                

                write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - Found iPDU '$Hostname' is already being managed by $_externalManagerIP."

                write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - $_externalManagerIP resolves to $($_externalManagerFQDN.HostName | out-string)"

                write-warning "iPDU '$Hostname' is already claimed by another management system $_externalManagerIP ($($_externalManagerFQDN.HostName))."

                if ($force -and $pscmdlet.ShouldProcess($Hostname,"iPDU is already claimed by another management system $_externalManagerIP ($($_externalManagerFQDN.HostName)). Force add?")) 
				{
		        	        
                    write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - iPDU is being claimed due to user chosing YES to force add."

                    $import.force = $true

					Try
					{
						
						$_resp = Send-HPOVRequest $script:powerDevicesDiscoveryUri POST $_import -Hostnamme $ApplianceConnection.Name

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

		        }

                elseif ($pscmdlet.ShouldProcess($Hostname,"iPDU is already claimed by another management system $_externalManagerIP ($($_externalManagerFQDN.HostName)). Force add?")) 
				{
		        	        
                    write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] - iPDU is being claimed due to user chosing YES to force add."

                    $import.force = $true

                    Try
					{
						
						$_resp = Send-HPOVRequest $script:powerDevicesDiscoveryUri POST $_import -Hostnamme $ApplianceConnection.Name

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

		        }

		        else 
				{

                    if ($PSBoundParameters['whatif'].ispresent) 
					{ 
                            
                        write-warning "-WhatIf was passed, would have force added '$Hostname' iPDU to appliance."

                        $_resp = $null
                            
                    }

                    else 
					{

		        	    #If here, user chose "No", end processing

		        	    write-warning "Not importing iPDU, $Hostname."

                        $_resp = $Null

                    }

		        }

            }

            else 
			{

                $_errorMessage = $_resp.taskerrors

                if ($_errorMessage -is [Array]) 
				{ 
                        
                    #Loop to find a Message value that is not blank.
                    $displayMessage = $errorMessage | ? { $_.message }

                    $errorRecord = New-ErrorRecord InvalidOperationException $displayMessage.errorCode InvalidResult 'Add-HPOVPowerDevice' -Message $displayMessage.message 
				
				}
                        
                else 
				{ 
					
					$errorRecord = New-ErrorRecord InvalidOperationException $errorMessage.errorCode InvalidResult 'Add-HPOVPowerDevice' -Message ($errorMessage.details + " " + $errorMessage.message) 
				
				}

                $PSCmdlet.ThrowTerminatingError($errorRecord)

            }

        }
    
        [void]$colStatus.Add($_resp)
    
    }

	End
	{

		Return $colStatus

	}

}

#// TODO US51100
Function New-HPOVPowerDevice
{



}

function Remove-HPOVPowerDevice 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "default",SupportsShouldProcess = $True,ConfirmImpact = 'High')]
    Param 
	(

        [parameter(Position = 0, Mandatory, ValueFromPipeline, ParameterSetName = "default", HelpMessage = "Enter the the power-device to be removed.")]
        [ValidateNotNullOrEmpty()]
        [Alias("uri","name")]
        [object]$PowerDevice = $null,

	    [parameter(Mandatory = $false)]
	    [switch]$force,
	
		[parameter(position = 1, Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "default")]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = $Null

    )

    Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		if (-not($PSBoundParameters['PowerDevice'])) { $PipelineInput = $True }

		$_TaskCollection        = New-Object System.Collections.ArrayList
		$_PowerDeviceCollection = New-Object System.Collections.ArrayList
   
    }

    Process 
	{

		if ($PipelineInput) 
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Pipeline input"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] PowerDevice Object provided: $($PowerDevice | FL * | Out-String)"

			If ('power-devices' -contains $PowerDevice.category)
			{

				If (-not($PowerDevice.ApplianceConnection))
				{

					$errorRecord = New-ErrorRecord HPOneView.PowerDeviceResourceException InvalidArgumentValue InvalidArgument "PowerDevice:$($PowerDevice.Name)" -TargetType PSObject -Message "The PowerDevice object resource provided is missing the source ApplianceConnection property.  Please check the object provided and try again."
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				[void]$_PowerDeviceCollection.Add($PowerDevice)

			}

			else
			{

				$errorRecord = New-ErrorRecord HPOneView.PowerDeviceResourceException InvalidArgumentValue InvalidArgument "PowerDevice:$($PowerDevice.Name)" -TargetType PSObject -Message "The PowerDevice object resource is not an expected category type [$($PowerDevice.category)].  The allowed resource category type is 'power-devices'.  Please check the object provided and try again."
                $PSCmdlet.ThrowTerminatingError($errorRecord)

			}

		}

		else 
		{

			ForEach ($_Connection in $ApplianceConnection)
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Appliance $($_Connection.Name) (of $($ApplianceConnection.Count))"

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Power Device Name $($PowerDevice)"

				Try
				{

					$_PowerDevice = Get-HPOVPowerDevice $PowerDevice -ApplianceConnection $_Connection

					$_PowerDevice | % {

						[void]$_PowerDeviceCollection.Add($_)

					}

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}				

			}

		}
		
    }

	End
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Begin resource removal process."

	    foreach ($_PowerDevice in $_PowerDeviceCollection) 
		{

            if ($PSCmdlet.ShouldProcess($_PowerDevice.name,"Remove Power Device from appliance '$($_PowerDevice.ApplianceConnection.Name)'"))
			{   
             
                
				Try
				{
					
					$_task = Send-HPOVRequest $_PowerDevice.uri DELETE -Hostname $_PowerDevice.ApplianceConnection.Name

					[void]$_TaskCollection.Add($_task)

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

            }

			elseif ($PSBoundParameters['WhatIf'])
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Caller passed -WhatIf parameter."

			}

			else
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Caller selected NO to confirmation prompt."

			}

        }

		Return $_TaskCollection


	}

}

function Get-HPOVPowerPotentialDeviceConnection 
{

	# .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "default")]
    Param 
	(

        [parameter(Position = 0, Mandatory, ValueFromPipeline, ParameterSetName = "default", HelpMessage = "Specify the Power Device to retrive potential power connections of resources.")]
        [ValidateNotNullOrEmpty()]
        [Alias("uri","name")]
        [object]$PowerDevice = $null,
	
		[parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = "default")]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = $Null

    )

	Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		if (-not($PSBoundParameters['PowerDevice'])) { $PipelineInput = $True }

		$_PowerDeviceCollection = New-Object System.Collections.ArrayList

	}

	Process 
	{

		if ($PipelineInput) 
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Pipeline input"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] PowerDevice Object provided: $($PowerDevice | FL * | Out-String)"

			If ('power-devices' -contains $PowerDevice.category)
			{

				If (-not($PowerDevice.ApplianceConnection))
				{

					$errorRecord = New-ErrorRecord HPOneView.PowerDeviceResourceException InvalidArgumentValue InvalidArgument "PowerDevice:$($PowerDevice.Name)" -TargetType PSObject -Message "The PowerDevice object resource provided is missing the source ApplianceConnection property.  Please check the object provided and try again."
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				Try
				{

					$_resp = Send-HPOVRequest ($powerDevicePotentialConnections + $PowerDevice.uri)

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}				

				if ($_resp)
				{

					$_resp | % { 
						
						$_.PSObject.TypeNames.Insert(0,'HPOneView.PowerDevice.PotentialPowerConnection')
					
						[void]$_PowerDeviceCollection.Add($_)

					}

				}

			}

			else
			{

				$errorRecord = New-ErrorRecord HPOneView.PowerDeviceResourceException InvalidArgumentValue InvalidArgument "PowerDevice:$($PowerDevice.Name)" -TargetType PSObject -Message "The PowerDevice object resource is not an expected category type [$($PowerDevice.category)].  The allowed resource category type is 'power-devices'.  Please check the object provided and try again."
                $PSCmdlet.ThrowTerminatingError($errorRecord)

			}

		}

		else 
		{

			ForEach ($_Connection in $ApplianceConnection)
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Appliance $($_Connection.Name) (of $($ApplianceConnection.Count))"

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Power Device Name $($PowerDevice)"

				Try
				{

					$_PowerDevice = Get-HPOVPowerDevice $PowerDevice -ApplianceConnection $_Connection

					$_resp = $_PowerDevice | % { Send-HPOVRequest ($powerDevicePotentialConnections + $_.uri) }

					$_resp | % {

						$_.PSObject.TypeNames.Insert(0,'HPOneView.PowerDevice.PotentialPowerConnection')

						[void]$_PowerDeviceCollection.Add($_)

					}

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}				

			}

		}

	}

	End 
	{

		Return $_PowerDeviceCollection

	}

}

#// TODO US51099
Function Add-HPOVPowerDeviceConnection
{


}

#######################################################
# Networking and Connections
#

function New-HPOVNetwork 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "Ethernet")]
    Param 
	(

		[parameter(Mandatory = $true, ParameterSetName = "FC",Position=0)]
		[parameter(Mandatory = $true, ParameterSetName = "Ethernet",Position=0)]
		[parameter(Mandatory = $true, ParameterSetName = "FCOE",Position=0)]
		[parameter(Mandatory = $true, ParameterSetName = "VLANIDRange",Position=0)]
		[string]$Name, 

		[parameter(Mandatory = $true, ParameterSetName = "FC",Position=1)]
		[parameter(Mandatory = $false, ParameterSetName = "Ethernet",Position=1)]
		[parameter(Mandatory = $false, ParameterSetName = "FCOE",Position=1)]
		[parameter(Mandatory = $false, ParameterSetName = "VLANIDRange",Position=1)]
		[ValidateSet("Ethernet", "FC", "FibreChannel", "Fibre Channel", "FCoE")]
		[string]$Type = "Ethernet",
        
		[parameter(Mandatory = $false, ParameterSetName = "Ethernet",Position=2)] 
		[parameter(Mandatory = $true, ParameterSetName = "FCOE",Position=2)] 
		[int32]$VlanId,

		[parameter(Mandatory = $true, ParameterSetName = "VLANIDRange",Position=1)]
		[string]$VlanRange,

		[parameter(Mandatory = $false, ParameterSetName = "Ethernet",Position=3)] 
		[parameter(Mandatory = $false, ParameterSetName = "VLANIDRange",Position=2)]
		[ValidateSet('Untagged','Tagged','Tunnel')]
		[string]$VLANType = "Tagged", 

		[parameter(Mandatory = $false, ParameterSetName = "VLANIDRange")]
		[parameter(Mandatory = $false, ParameterSetName = "Ethernet")]
		[ValidateSet("General", "Management", "VMMigration", "FaultTolerance")]
		[string]$Purpose = "General", 

		[parameter(Mandatory = $false, ParameterSetName = "VLANIDRange")]
		[parameter(Mandatory = $false, ParameterSetName = "Ethernet")]
		[boolean]$SmartLink = $true, 

		[parameter(Mandatory = $false, ParameterSetName = "VLANIDRange")]
		[parameter(Mandatory = $false, ParameterSetName = "Ethernet")]
		[boolean]$PrivateNetwork = $false, 

		[parameter(Mandatory = $false, ParameterSetName = "VLANIDRange")]
		[parameter(Mandatory = $false, ParameterSetName = "Ethernet")]
		[parameter(Mandatory = $false, ParameterSetName = "FC")]
		[validaterange(2,20000)]
		[int32]$TypicalBandwidth = 2500, 
        
		[parameter(Mandatory = $false, ParameterSetName = "VLANIDRange")]
		[parameter(Mandatory = $false, ParameterSetName = "Ethernet")]
		[parameter(Mandatory = $false, ParameterSetName = "FC")]
		[validaterange(100,20000)]
		[int32]$MaximumBandwidth = 10000, 

		[parameter(Mandatory = $false, ParameterSetName = "FC")]
		[int32]$LinkStabilityTime = 30, 

		[parameter(Mandatory = $false, ParameterSetName = "FC")]
		[boolean]$AutoLoginRedistribution = $False,

		[parameter(Mandatory = $false, ParameterSetName = "FC")]
		[ValidateSet("FabricAttach","FA", "DirectAttach","DA")]
		[string]$FabricType = "FabricAttach",

		[parameter(Mandatory = $false, ParameterSetName = "FC", ValueFromPipeline = $True)]
		[parameter(Mandatory = $false, ParameterSetName = "FCOE", ValueFromPipeline = $True, Position = 3)] 
		[ValidateNotNullOrEmpty()]
		[object]$ManagedSan = $Null,

		[parameter(Mandatory = $false, ParameterSetName = "FC")]
		[parameter(Mandatory = $false, ParameterSetName = "Ethernet")]
		[parameter(Mandatory = $false, ParameterSetName = "FCOE")]
		[parameter(Mandatory = $false, ParameterSetName = "VLANIDRange")]
		[parameter(Mandatory = $false, ParameterSetName = "importFile")]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions},

		[parameter(Mandatory = $true, ParameterSetName = "importFile", HelpMessage = "Enter the full path and file name for the input file.")]
		[Alias("i", "import")]
		[string]$ImportFile

    )

    Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{

				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

        if ($fcUplinkBandwidth) 
		{

            Write-Warning "FcUplinkBandwidth parameter has been deprecated and is no longer used. Please specify the Uplink Bandwidth when creating the Uplink Set using New-HPOVUplinkSet -FcUplinkSpeed parameter."

        }

		$colStatus = New-Object System.Collections.ArrayList

    }
     
    Process 
	{

		#Validate Ethernet VLAN ID Setting if Type = 'Tagged'
		if ($PSBoundParameters['VLANType'] -eq 'Tagged' -and (-not($PSBoundParameters['VLANID'])))
		{

			#Generate Error
			$errorRecord = New-ErrorRecord HPOneView.NetworkResourceException InvalidNetworkTypeOperation InvalidOperation 'VLANType' -Message "The -VLANType parameter was used to specify a 'Tagged' Network, however the -VLANID parameter was not provided.  Please provide a VLANID to the Network resource you are creating."
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		#Validate Ethernet VLAN ID Setting if Network Type is FCoE
		if ($PSBoundParameters['Type'] -eq 'FCoE' -and (-not($PSBoundParameters['VLANID'])))
		{

			#Generate Error
			$errorRecord = New-ErrorRecord HPOneView.NetworkResourceException InvalidNetworkTypeOperation InvalidOperation 'Type' -Message "The -Type parameter was used to specify a 'FCoE' Network, however the -VLANID parameter was not provided.  Please provide a VLANID to the Network resource you are creating."
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		ForEach ($_appliance in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Resolved Parameter Set Name: $($PsCmdLet.ParameterSetName)"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing CMDLET for '$($_appliance.name)' appliance."

			If ($importFile) 
			{

			    try 
				{

			        $network = [string]::Join("", (gc $importfile -ErrorAction Stop)) | convertfrom-json -ErrorAction Stop

			    }

			    catch [System.Management.Automation.ItemNotFoundException] 
				{

			        $errorRecord = New-ErrorRecord System.Management.Automation.ItemNotFoundException InputFileNotFound ObjectNotFound 'New-HPOVNetwork' -Message "$importFile not found.  Please check the filename or path is valid and try again."
			            
			        #Generate Terminating Error
			        $PSCmdlet.ThrowTerminatingError($errorRecord)

			    }

			    catch [System.ArgumentException] 
				{

			        $errorRecord = New-ErrorRecord System.ArgumentException InvalidJSON ParseError 'New-HPOVNetwork' -Message "JSON incorrect or invalid within '$importFile' input file."
			            
			        #Generate Terminating Error
			        $PSCmdlet.ThrowTerminatingError($errorRecord)

			    }

			}
			
			else
			{
			
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Network Type Requested: $($type)"

				switch ($type) 
				{

					"Ethernet" 
					{

					    if (-not($PSBoundParameters['vlanRange'])) 
						{

						    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Creating '$name' Ethernet Network"

						    $network = NewObject -EthernetNetwork

							$network.vlanId              = $vlanId
							$network.ethernetNetworkType = $VLANType
							$network.purpose             = $purpose
							$network.name                = $Name
							$network.smartLink           = $smartLink
							$network.privateNetwork      = $privateNetwork

						}

					    else 
						{
                    
							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Creating bulk '$name' + '$vlanRange' Ethernet Networks"

							$network = NewObject -BulkEthernetNetworks

							$network.vlanIdRange                = $vlanRange
							$network.purpose                    = $purpose
							$network.namePrefix                 = $Name
							$network.smartLink                  = $smartLink
							$network.privateNetwork             = $privateNetwork
							$network.bandwidth.typicalBandwidth = $typicalBandwidth
							$network.bandwidth.maximumBandwidth = $maximumBandwidth
							        
						}

					}
					
					{ @("FC","FibreChannel","Fibre Channel") -contains $_ } 
					{

					    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Creating '$name' FC Network"

						$network = NewObject -FCNetwork

						$network.name                    = $Name
						$network.linkStabilityTime       = $linkStabilityTime
						$network.autoLoginRedistribution = $autoLoginRedistribution
						$network.fabricType              = $fabricType
						$network.connectionTemplateUri   = $null

						Try
						{

							$network.managedSanUri  = if ($ManagedSan) { (VerifyManagedSan $ManagedSan $_appliance) } else { $null }

						}

						Catch
						{

							$PSCmdlet.ThrowTerminatingError($_)

						}

					    #If maxbandiwdth value isn't specified, 10Gb is the default value, must change to 8Gb
					    if ( $maximumBandwidth -eq 10000 ){ $maximumBandwidth = 8000 }

					}

					"FCOE" 
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Creating '$name' FCOE Network"

					    $network = NewObject -FCoENetwork

						$network.name                  = $Name
						$network.vlanId                = $vlanId
						$network.connectionTemplateUri = $null
						
						Try
						{

							$network.managedSanUri = if ($ManagedSan) { (VerifyManagedSan $ManagedSan $_appliance) } else { $null }

						}

						Catch
						{

							$PSCmdlet.ThrowTerminatingError($_)

						}

					}

				}
			
			}

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Network Object:  $($network | fl | out-string)"
			
			foreach($net in $network) 
			{

			    if ($net.defaultTypicalBandwidth) { $typicalBandwidth = $net.defaultTypicalBandwidth }
			    if ($net.defaultMaximumBandwidth) { $maximumBandwidth = $net.defaultMaximumBandwidth }
			    if ($net.typicalBandwidth) { $typicalBandwidth = $net.typicalBandwidth }
			    if ($net.maximumBandwidth) { $maximumBandwidth = $net.maximumBandwidth }

			    switch ($net.type) 
				{

					{$_ -match "bulk-ethernet-network"}
					{
			            
			            write-host "Creating bulk '$name' + '$vlanRange' Ethernet Networks"

			            $netUri = $script:ethNetworksUri + "/bulk"

						break

			        }

			        {$_ -match "ethernet-network"}
					{

			            write-host "Creating Ethernet Network" $net.name 

			            $netUri = $script:ethNetworksUri

			            $net = $net | select name, type, vlanId, smartLink, privateNetwork, purpose, ethernetNetworkType, connectionTemplateUri

			        }

			        {$_ -match "fc-network"}
					{

			            write-host "Creating FC Network" $net.name

			            $netUri = $script:fcNetworksUri

			            $net = $net | select name, linkStabilityTime, autoLoginRedistribution, type, fabricType, managedSanUri, connectionTemplateUri 

			        }

					{$_ -match "fcoe-network"}
					{

						write-host "Creating FCoE Network" $net.name

			            $netUri = $script:fcoeNetworksUri

			            $net = $net | select name, type, vlanId, connectionTemplateUri, managedSanUri

					}

			        #Should never get here.  If so, this is an internal error we need to fix.
			        default 
					{

			            $errorRecord = New-ErrorRecord System.ArgumentException InvalidNetworkType InvalidType 'type' -Message "(INTERNAL ERROR) The Network Resource Type $($net.type) is invalid for '$($net.name)' network."
			            
			            #Generate Terminating Error
			            $PSCmdlet.ThrowTerminatingError($errorRecord)

			        }

			    }

			    $objStatus = [pscustomobject]@{ 
					
					Name      = $net.Name; 
					Status    = $Null; 
					Details   = $Null;
					Exception = $Null;
				
				}

			    #Check if Network Type is Direct Attach and if ManagedFabric parameter is being called at the same time.
			    if (($fabricType -eq "DirectAttach" -or $fabricType -eq "DA") -and $managedfabric) 
				{ 

			        $objStatus.Details = "You specified a DirectAttach Fabric Type and passed the ManagedSan parameter.  The ManagedSan parameter is to be used for FabricAttach networks only."
			       
			    }

			    else 
				{
					 
					Try
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request to create '$($net.name)' network."

						$task = Send-HPOVRequest $netUri POST $net -Hostname $_appliance 
					
					}	
					
					Catch
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Exception caught when trying to create '$($net.name)' network."

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Exception: $($_.Exception.Message.ToString())"

						$objStatus.Status    = "Failed"
						$objStatus.Details   = $_.exception.message
						$objStatus.Exception = $_

					}

				}

			    if (-not ($task.Uri)) 
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Create Network Object '$($net.name)' request was rejected."

			        $objStatus.Status = "Failed"
			        
			        #Do not want to overwrite the details value from the Fabric Type check above.
			        if ($task) { $objStatus.Details = $task }

			    }

			    else 
				{ 
			        
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Create Network Object '$($net.name)' creating. Monitor task."

			        #Wait for the network to be created
					Try
					{

						$task = Wait-HPOVTaskComplete $task #-Appliance $_appliance

					}

					Catch
					{

						$PSCMdlet.ThrowTerminatingError($_)

					}

			        $objStatus.Status  = $task.taskState
			        $objStatus.Details = $task

			    }

			    [void] $colStatus.add($objStatus) #| Out-Null

				#Update Bandwidth allocation if set to different than default values
				if (($typicalBandwidth -or $maximumBandwidth) -and (-not($objStatus.Status -eq "Failed")) -and $net.type -ne 'bulk-ethernet-network' ) 
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Setting bandwidth to network object"

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Network object to retrieve ConnectionTemplate URI"

					#Get network resource URI
					Try
					{

						$net = Send-HPOVRequest $task.associatedResource.resourceUri -Hostname $_appliance

					}
			        
					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] ConnectionTemplate URI '$($net.connectionTemplateUri)'"

			        if ($net -and $net.connectionTemplateUri) 
					{

			            $ctUri = $net.connectionTemplateUri
						
						Try
						{

							$ct = Send-HPOVRequest $ctUri -Hostname $_appliance

						}

						Catch
						{

							$PSCmdlet.ThrowTerminatingError($_)

						}        

			            if ($ct -and $ct.bandwidth) 
						{

			                if ($typicalBandwidth) { $ct.bandwidth.typicalBandwidth = $typicalBandwidth }

			                if ($maximumBandwidth) { $ct.bandwidth.maximumBandwidth = $maximumBandwidth }

			                Send-HPOVRequest $ct.uri PUT $ct -Hostname $_appliance | Out-Null

			            }

			        }

			    }

			}

		}

    }

    end 
	{

        if ($colStatus | ? { $_.Status -ne "Completed" }) 
		{ 
			
			write-error "One or more networks failed the creation attempt!" 
		
		}

        Return $colStatus
        
    }

}

function VerifyManagedSan 
{

	[CmdLetBinding()]
    Param 
	(

		[parameter (Mandatory = $false, Position = 0)]
		[ValidateNotNullorEmpty()]
		[Object]$managedSan,

		[parameter (Mandatory = $true, Position = 1)]	
		[ValidateNotNullorEmpty()]	
		[object]$Appliance
    
	)
	
	Process 
	{

        if ($managedSan -eq "" -or $managedSan -eq $Null) 
		{
           
            $managedSanUri = $Null

        }

        elseif ($managedSan -is [PSCustomObject] -and $managedSan.category -eq 'fc-sans') 
		{ 
                    
            $managedSanUri = $managedSan.uri
                        
        }

        elseif ($managedSan -is [PSCustomObject] -and -not ($managedSan.category -eq 'fc-sans')) 
		{ 
                    
            $errorRecord = New-ErrorRecord HPOneView.NetworkResourceException InvalidManagedSanUri InvalidArgument 'managedSan' -Message "The Managed SAN object category provided '$($managedSan.category)' is not the the expected value of 'fc-sans'. Please verify the parameter value and try again."
            $PSCmdlet.ThrowTerminatingError($errorRecord)   
                        
        }
                   
        elseif ($managedSan -is [String] -and $managedSan.StartsWith('/rest/')) 
		{ 
                    
            $errorRecord = New-ErrorRecord HPOneView.NetworkResourceException InvalidManagedSanUri InvalidArgument 'managedSan' -Message "The Managed SAN Uri provided '$managedSan' is incorrect.  Managed SAN URI must begin with '/rest/fc-sans/managed-sans'."
            $PSCmdlet.ThrowTerminatingError($errorRecord)                       
                    
        }
                    
        elseif ($managedSan -is [String] -and (-not($managedSan.StartsWith($script:fcManagedSansUri)))) 
		{

			#Get ManagedSan object
            Try { $managedSanUri = (Get-HPOVManagedSan $managedSan -appliance $Appliance).uri }

			#If specified ManagedSan object does not exist, generate trappable error
			catch 
			{
		
				$errorRecord = New-ErrorRecord HPOneView.NetworkResourceException InvalidManagedSanName InvalidArgument 'managedSan' -Message "The Managed SAN Name provided '$managedSan' was not found."
				$PSCmdlet.ThrowTerminatingError($errorRecord)   

			}

        }

		else 
		{

			$managedSanUri = $managedSan

		}

		Return $managedSanUri

    }

}

function Get-HPOVNetwork 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding()]
    Param 
	(

		[parameter (ValueFromPipeline, Mandatory = $false, position = 0)]
		[String]$Name = $null,
		
		[parameter (Mandatory = $false, position = 1)]
		[ValidateSet("Ethernet","FC","FibreChannel","FCOE")]
		[String]$Type = $null,
		
		[parameter (Mandatory = $false, position = 2)]
		[ValidateSet("Management","FaultTolerance","General","VMMigration", IgnoreCase = $False)]
		[String]$Purpose,
		
		[parameter(Mandatory = $false)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions},
		
		[parameter (Mandatory = $false, position = 4)]
		[alias("x", "export")]
		[ValidateScript({split-path $_ | Test-Path})]
		[String]$exportFile
    
	)

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSBoundParameters['type']))
		{
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] -Type parameter wasn't provided. Specifying all Network Resource Types."

			[Array]$type = "Ethernet","FibreChannel","FCOE"

		}

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$NetworkCollection = New-Object System.Collections.ArrayList
        
	}
	
	Process 
	{

		ForEach ($Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($Connection.Name)' Appliance (of $($ApplianceConnection.Count))"

			if ($name)
			{
				
				$name = $name -replace ("[*]","%25") -replace ("[&]","%26")

			}
			
			switch  ($type) 
			{

				{ @("FC", "FibreChannel") -contains $_ } 
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing FibreChannel Networks."

					if ($name) 
					{ 
			            
						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Looking for '$($name)' Fibre Channel Network resources."

						$FcNetsUri = $script:fcNetworksUri + "?filter=`"name matches '$name'`"&sort=name:ascending"

					}

					else 
					{
						
						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Looking for all Fibre Channel Network resources."

						$FcNetsUri = $script:fcNetworksUri + "?sort=name:ascending"
					
					}

					$FcNets = Send-HPOVRequest -uri $FcNetsUri -Hostname $Connection

					#Add to final collection arraylist
					if ($FcNets.members) 
					{ 
						
						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding results to collection"

						$FcNets.members | % { 

							$_.psobject.typenames.Insert(0,”HPOneView.Networking.FibreChannelNetwork")  

							[void]$NetworkCollection.Add($_)
						
						} 

					}

			    }

			    { @("Ethernet") -contains $_ } 
				{

			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Ethernet Network resources."

			        if ($name) 
					{ 
			            
			            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Looking for '$($name)' Ethernet Network resources."

			            $EnetsUri = $script:ethNetworksUri + "?filter=`"name matches '$name'`"&sort=name:ascending"

			        }

			        else 
					{  

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Looking for all Ethernet Network resources."

						$EnetsUri = $script:ethNetworksUri + "?sort=name:ascending" 
						
					}

					$ENets = Send-HPOVRequest -uri $EnetsUri -Hostname $Connection
					
					#Add to final collection arraylist
					if ($ENets.members) 
					{ 

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding results to collection"

						$ENets.members | % { 

							$_.psobject.typenames.Insert(0,”HPOneView.Networking.EthernetNetwork")  

							[void]$NetworkCollection.Add($_)

						} 

					}

			    }

				{ @("FCoE") -contains $_ }
				{

			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Looking for FCoE Network resources."

			        if ($name) 
					{ 
			            
			            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Looking for '$($name)' FCoE Network resources."

			            $FCoEUri = $script:FCoENetworksUri + "?filter=`"name matches '$name'`"&sort=name:desc"

			        }

			        else 
					{  

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Looking for all FCOE Network resources."

						$FCoEUri = $script:FCoENetworksUri + "?sort=name:desc" 
						
					}

					$FCoENets = Send-HPOVRequest -uri $FCoEUri -Hostname $Connection

					#Add to final collection arraylist
					if ($FCoENets.members) 
					{ 

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding results to collection"

						$FCoENets.members | % { 

							$_.psobject.typenames.Insert(0,”HPOneView.Networking.FCoENetwork")  
						
							[void]$NetworkCollection.Add($_)
						
						} 

					}

			    }

			}

		}

    }

    End 
	{

		#If network not found, report error
		if ((-not($NetworkCollection)) -and $name)
		{ 

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Network Resource Name was provided, yet no results were found.  Generate Error."

			$errorRecord = New-ErrorRecord HPOneView.NetworkResourceException NetworkResourceNotFound ObjectNotFound "Name" -Message "The specified '$name' Network resource were not found.  Please check the name and try again."
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

        if ($NetworkCollection) 
		{

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Results returned "

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Networks Found: $($NetworkCollection | fl * | out-string ) "

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Network resource Connection Template Object to add bandwidth values to network objects."

			ForEach ($NetObject in $NetworkCollection) 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($NetObject.Name)' Network resource."

				if ($NetObject.connectionTemplateUri) 
				{

					$ct = Send-HPOVRequest -uri $NetObject.connectionTemplateUri -Hostname $NetObject.ApplianceConnection.Name
            
					Add-Member -InputObject $NetObject -NotePropertyName defaultMaximumBandwidth -NotePropertyValue $ct.bandwidth.maximumBandwidth -Force 
					Add-Member -InputObject $NetObject -NotePropertyName defaultTypicalBandwidth -NotePropertyValue $ct.bandwidth.typicalBandwidth -Force

				}
        
			}

			"[$($MyInvocation.InvocationName.ToString().ToUpper())] Done. {0} network resource(s) found." -f $NetworkCollection.Count | Write-Verbose 
            
			if ($exportFile) 
			{ 
                
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Exporting JSON to $($exportFile)"
			
                $NetworkCollection | Sort type,name | convertto-json > $exportFile
			
            }
            
			else
			{

				Return $NetworkCollection | Sort type,name
			
			}
        
		}

        #No networks found
        else
		{ 
			
			write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No Network resources found." 
		
		}

    }

}

function Set-HPOVNetwork 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "Ethernet")]
    Param 
	(

        [parameter(Position = 0, Mandatory, ValueFromPipeline, HelpMessage = "Provide the Network Name, URI or Resource Object to be modified.", ParameterSetName = "Ethernet")]
        [parameter(Position = 0, Mandatory, ValueFromPipeline, HelpMessage = "Provide the Network Name, URI or Resource Object to be modified.", ParameterSetName = "FibreChannel")]
        [ValidateNotNullOrEmpty()]
        [Alias('net')]
        [Object]$Network,

        [parameter(Position = 1, Mandatory = $false, ValueFromPipeline = $false, HelpMessage = "Enter the new Name of the network object.", ParameterSetName = "Ethernet")]
        [parameter(Position = 1, Mandatory = $false, ValueFromPipeline = $false, HelpMessage = "Enter the new Name of the network object.", ParameterSetName = "FibreChannel")]
        [ValidateNotNullOrEmpty()]
        [string]$Name = $Null,

        [parameter(Mandatory = $false, ParameterSetName = "Ethernet")]
        [parameter(Mandatory = $false, ParameterSetName = "FibreChannel")]
        [ValidateNotNullOrEmpty()]
        [string]$Prefix,

        [parameter(Mandatory = $false, ParameterSetName = "Ethernet")]
        [parameter(Mandatory = $false, ParameterSetName = "FibreChannel")]
        [ValidateNotNullOrEmpty()]
        [string]$Suffix,

        [parameter(Position = 2, Mandatory = $false, ValueFromPipeline = $false, HelpMessage = "Enter the new Purpose of the network object.", ParameterSetName = "Ethernet")]
        [ValidateNotNullOrEmpty()]
        [ValidateSet("General", "Management", "VMMigration", "FaultTolerance")]
        [string]$Purpose,

        [parameter(Mandatory = $false, ParameterSetName = "Ethernet")]
        [Bool]$Smartlink, 

        [parameter(Mandatory = $false, ParameterSetName = "Ethernet")]
        [Bool]$PrivateNetwork, 

        [parameter(Position = 5, Mandatory = $false, ParameterSetName = "Ethernet")]
        [parameter(Position = 2, Mandatory = $false, ParameterSetName = "FibreChannel")]
		[parameter(Position = 2, Mandatory = $false, ParameterSetName = "FCoE")]
        [validaterange(2,20000)]
        [int32]$TypicalBandwidth, 
        
        [parameter(Position = 6, Mandatory = $false, ParameterSetName = "Ethernet")]
        [parameter(Position = 3, Mandatory = $false, ParameterSetName = "FibreChannel")]
        [validaterange(100,20000)]
        [int32]$MaximumBandwidth, 

        [parameter(Position = 4, Mandatory = $false, ParameterSetName = "FibreChannel")]
        [ValidateRange(1,1800)]
		[Alias('lst')]
        [int32]$LinkStabilityTime, 

        [parameter(Position = 5, Mandatory = $false, ParameterSetName = "FibreChannel")]
		[Alias('ald')]
        [Bool]$AutoLoginRedistribution,

        [parameter(Position = 6, Mandatory = $false, ParameterSetName = "FibreChannel")]
        [Object]$ManagedSan = $Null,

		[parameter(ValueFromPipelineByPropertyName, ValueFromPipeline = $False, Mandatory = $false, HelpMessage = "Enter the Appliance Name or Object", ParameterSetName = "Ethernet")]
		[parameter(ValueFromPipelineByPropertyName, ValueFromPipeline = $False, Mandatory = $false, HelpMessage = "Enter the Appliance Name or Object", ParameterSetName = "FibreChannel")]
		[Alias('Appliance')]
		[Object]$ApplianceConnection = ${Global:ConnectedSessions}

    )
    
    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSBoundParameters['Network'])) 
		{ 
			
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Network resource passed via pipeline."
		
			$PipelineInput = $True 
		
		}

		else
		{

			#Network Name and Appliance Connection are both required.
			if ($Network -is [String] -and (-not($ApplianceConnection)))
			{
		
				$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'Network' -Message "The -Network parameter requires an Appliance to be specified.  Please provide the Appliance Connection object or name by using the -ApplianceConnection parameter."
				$PSCmdLet.ThrowTerminatingError($errorRecord)

			}

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

			Try 
			{
	
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}


		}

		$_NetworksToUpdate = New-Object System.Collections.ArrayList
		$NetCollection     = New-Object System.Collections.ArrayList

    }

    Process 
	{

		#build collection of networks to modify
        foreach ($net in $Network) 
		{

			if ($PSBoundParameters['LinkStabilityTime'] -and $net.category -eq 'fcoe-networks')
			{

				$errorRecord = New-ErrorRecord HPOneView.NetworkResourceException InvalidArgumentValue InvalidArgument 'LinkStabilityTime' -TargetType 'Int' -Message "The -LinkStabilityTime parameter is not supported with FCoE Network resources, only FibreChannel network resources.  Please check your call and try again."
                $PSCmdLet.ThrowTerminatingError($errorRecord)

			}

			if ($PSBoundParameters['AutoLoginRedistribution'] -and $net.category -eq 'fcoe-networks')
			{

				$errorRecord = New-ErrorRecord HPOneView.NetworkResourceException InvalidArgumentValue InvalidArgument 'AutoLoginRedistribution' -TargetType 'Boolean'  -Message "The -AutoLoginRedistribution parameter is not supported with FCoE Network resources, only FibreChannel network resources.  Please check your call and try again."
                $PSCmdLet.ThrowTerminatingError($errorRecord)

			}

            #Check the name parameter value if the caller inadvertantly provided an object for name parameter
            if ($name -and ($name -match "category=ethernet-networks" -or $name -match "category=fc-networks" -or $name -match "category=fcoe-networks"))
			{ 
            
                $errorRecord = New-ErrorRecord HPOneView.NetworkResourceException InvalidArgumentValue InvalidArgument 'Name' -Message "The -name parameter value appears to have been passed the network resource object, which is converted to type [String] and is an invalid operation.  Please verify that you provided the Network Name attribute in the -name parameter value and try again."
                $PSCmdLet.ThrowTerminatingError($errorRecord)
            
            }

            elseif ($name -and $name.length -gt 255) 
			{

                $errorRecord = New-ErrorRecord HPOneView.NetworkResourceException InvalidArgumentValue InvalidArgument 'Name' -Message "The -name parameter value is greater than 255 characters.  Please check the -name parameter value and try again."
                $PSCmdLet.ThrowTerminatingError($errorRecord)

            }

            switch ($net.Gettype().Name) 
			{

                "PSCustomObject" 
				{ 
    
                    if ($net -is [PSCustomObject] -and ($net.category -eq "ethernet-networks" -or $net.category -eq "fc-networks" -or $net.category -eq "fcoe-networks")) 
					{

                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Collecting $($net.type) $($net.name) resource."

						[void]$_NetworksToUpdate.Add($net)

                    }

                    else 
					{

                        $errorRecord = New-ErrorRecord HPOneView.NetworkResourceException InvalidArgumentValue InvalidArgument 'Network' -TargetType 'PSObject' -Message "[$($net.gettype().name)] is an unspported data type.  Only [System.String] or [PSCustomObject] or an [Array] of [System.String] or [PSCustomObject] network resources are allowed.  Please check the -network parameter value and try again."
                        $PSCmdLet.ThrowTerminatingError($errorRecord)

                    }
                    
                }

                "String" 
				{ 
                
					#User provided Network 'name' and 1 or more Appliance Connections
                    if ($net -is [String] -and (-not ($net.StartsWith('/rest/'))))
					{
                    
                        ForEach ($_appliance in $ApplianceConnection)
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting '$($net)' resource from appliance."
							
							Try 
							{

								$_tempNet = Get-HPOVNetwork $net -type $PSCmdlet.ParameterSetName -ApplianceConnection $_appliance

							}
							
							Catch [HPOneView.NetworkResourceException]
							{

								if ($_.CategoryInfo.Category -eq 'ObjectNotFound')
								{

									$errorRecord = New-ErrorRecord HPOneView.NetworkResourceException NetworkResourceNotFound ObjectNotFound 'Network' -Message "'$net' Network was not found.  Please check the value and try again."
									$PSCmdLet.ThrowTerminatingError($errorRecord)

								}
								
								else
								{

									$PSCmdlet.ThrowTerminatingError($_)

								}

							}
							
							if ($_tempNet.count -gt 1)
							{

								$errorRecord = New-ErrorRecord HPOneView.NetworkResourceException NonUniqueNetworkName InvalidResult 'Network' -Message "Multiple '$_tempNet' Network resource found with the same name.  Please check the value and try again, or provide the Network Resource Object instead of the name."
							    $PSCmdLet.ThrowTerminatingError($errorRecord)

							}
                    
							[void]$_NetworksToUpdate.Add($_tempNet)

						}
						
                    }

                    elseif ($net -is [String] -and ($net.StartsWith('/rest/ethernet-networks/') -or $net.StartsWith('/rest/fc-networks/'))) {
                    
                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting '$($net)' resource from appliance."
                        [void]$NetCollection.Add((Send-HPOVRequest $net -Appliance $ApplianceConnection))
                    
                    }
                
                }

            }

		}

	}

    end 
	{

		ForEach ($_net in $_NetworksToUpdate)
		{

			#Set Specific Network Type settings
			switch ($_net.category) 
			{

                "ethernet-networks" 
				{

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Updateing $($_net.name) Ethernet Network."

                    switch ($PSBoundParameters.keys) 
					{

                        "purpose" 
						{ 
                        
                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Setting network Purpose to: $purpose"
                            $_net.purpose = $purpose
                            
                        }

                        "smartlink" 
						{

                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Setting smartlink Enabled to: $([bool]$smartlink)"
                            $_net.smartlink = [bool]$smartlink

                        }

                        "privateNetwork" 
						{ 

                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Setting privateNetwork Enabled to: $([bool]$privateNetwork)"
                            $_net.privateNetwork = [bool]$privateNetwork
                        
                        }

                    }

                }

                "fc-networks" 
				{

                    switch ($PSBoundParameters.keys) 
					{

                        "linkStabilityTime" 
						{

                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Setting linkStabilityTime to '$linkStabilityTime' seconds"

                            $_net.linkStabilityTime = [int]$linkStabilityTime

                        }

                        "autoLoginRedistribution" 
						{

                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Setting autoLoginRedistribution Enabled to: $([bool]$autoLoginRedistribution)"
                            
							$_net.autoLoginRedistribution = [bool]$autoLoginRedistribution

                        }

                        "managedSan"
						{

                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing ManagedSAN for FC Network."

							$_net.managedSanUri = (VerifyManagedSan $managedSan $_net.ApplianceConnection.Name)

                        }

                    }

                }

				"fcoe-networks"
				{
					
					switch ($PSBoundParameters.keys) 
					{

					    "managedSan"
						{

                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing ManagedSAN for FC Network."
                    
							$_net.managedSanUri = (VerifyManagedSan $managedSan $_net.ApplianceConnection.Name)
                            
                        }

					}

				}

            }

			#Shared Parameters for each Network Type
			if ($PSBoundParameters["name"]) 
			{
            
	            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Updating Network name to '$name'."
	
	            #validate name parameter is [String]
	            $_net.name = $name
	            
	        }
	
	        if ($PSBoundParameters["prefix"]) 
			{
	            
	            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Updating Network name to include '$prefix' prefix to Network Name."
	            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Updated Network Name: $($prefix + $_net.name)"
	
	            #validate name parameter is [String]
	            $_net.name = $prefix + $_net.name
	            
	        }
	
	        if ($PSBoundParameters["suffix"]) 
			{
	            
	            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Updating Network name to include '$suffix' suffix to Network Name."
	            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Updated Network Name: $($_net.name + $suffix)"
	
	            #validate name parameter is [String]
	            $_net.name += $suffix
	            
	        }
	
	        if ($PSBoundParameters["typicalBandwidth"] -or $PSBoundParameters["maximumBandwidth"]) 
			{
	
	            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Updating Network bandwidth assignment."

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Connection Template resource."

				Try
				{

					$ct = Send-HPOVRequest $_net.connectionTemplateUri -Appliance $_net.ApplianceConnection.Name

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				} 
	            
	            if ($PSBoundParameters["maximumBandwidth"]) 
				{
	            
	                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Original Maximum bandwidth assignment: $($ct.bandwidth.maximumBandwidth)"

	                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] New Maximum bandwidth assignment: $maximumBandwidth"

	                $ct.bandwidth.maximumBandwidth = $maximumBandwidth
	
	            }

	            if($PSBoundParameters["typicalBandwidth"]) 
				{
	
	                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Original Typical bandwidth assignment: $($ct.bandwidth.typicalBandwidth)"
	                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] New Typical bandwidth assignment: $typicalBandwidth"

	                $ct.bandwidth.typicalBandwidth = $typicalBandwidth
	                
	            }
	
	            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Updating Connection Template: $($ct | out-string)"

				Try
				{

					$ct = Send-HPOVRequest $ct.uri PUT $ct -Appliance $ct.ApplianceConnection.Name

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}
	            
	
	        }

			$_net = $_net | select * -ExcludeProperty defaultTypicalBandwidth, defaultMaximumBandwidth, created, modified

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Updating Network Resource object: $($_net | FL * | out-string)"
			Try
			{

				$resp = Send-HPOVRequest $_net.uri PUT $_net -Appliance $_net.ApplianceConnection.Name
			
			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			[void]$NetCollection.Add($resp)
		
		}
        
		Return $NetCollection

    }

} 

function Remove-HPOVNetwork 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "PipelineDefault",SupportsShouldProcess = $True,ConfirmImpact = 'High')]
    Param
    (

		[parameter(Mandatory, ValueFromPipeline, ParameterSetName = "PipelineDefault", HelpMessage = "Specify the network to remove.", Position = 0)]
		[parameter(Mandatory, ParameterSetName = "ApplianceRequired", position = 0)]
        [ValidateNotNullOrEmpty()]
        [Alias('uri', 'name', 'network')]
        [System.Object]$Resource = $null,
	
		[parameter(Mandatory = $False, ValueFromPipelineByPropertyName, ParameterSetName = "ApplianceRequired", position = 1)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = $Null,

		[switch]$Force

    )

    Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		if (-not($PSBoundParameters['Resource'])) { $PipelineInput = $True }

		$_TaskCollection    = New-Object System.Collections.ArrayList
		$_NetworkCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{

		if ($PipelineInput) 
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Pipeline input"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Network Object provided: $($Resource | FL * | Out-String)"

			If ('ethernet-networks','fc-networks','fcoe-networks' -contains $Resource.category)
			{

				If (-not($Resource.ApplianceConnection))
				{

					$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument "Network:$($Resource.Name)" -TargetType PSObject -Message "The Network resource provided is missing the source ApplianceConnection property.  Please check the object provided and try again."
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				[void]$_NetworkCollection.Add($Resource)

			}

			else
			{

				$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument "Network:$($Resource.Name)" -TargetType PSObject -Message "The Network resource is not an expected category type [$($Resource.category)].  Allowed resource category types are 'ethernet-networks', 'fc-networks', or 'fcoe-networks'.  Please check the object provided and try again."
                $PSCmdlet.ThrowTerminatingError($errorRecord)

			}

		}

		else 
		{

			foreach ($net in $Resource) 
			{

				#Network passed is a URI
				if (($net -is [String]) -and [System.Uri]::IsWellFormedUriString($net,'Relative')) 
				{

				    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Received URI: $($net)"

				    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Network Name"

					# // NEED APPLIANCE NAME HERE with If Condition
				    $net = Send-HPOVRequest $net -ApplianceConnection $ApplianceConnection

				}

				#Network passed is the Name
				elseif (($net -is [string]) -and (!$net.startsWith("/rest"))) 
				{

				    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Received Network Name $($net)"

				    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Network object from Get-HPOVNetwork"
				    
					# // NEED APPLIANCE NAME HERE with If Condition
				    $net = Get-HPOVNetwork $net -ApplianceConnection $ApplianceConnection

				    if ($network.count -gt 1 ) 
					{ 

				        $errorRecord = New-ErrorRecord InvalidOperationException NetworkResourceNameNotUnique InvalidResult 'Remove-HPOVNetwork' -Message "Invalid Network parameter: $net"
				        $PSCmdlet.WriteError($errorRecord)                
				    
				    }

				}

				#Network passed is the object
				elseif ($net -is [PSCustomObject] -and ($net.category -ieq 'ethernet-networks' -or $net.category -ieq 'fc-networks' -or $net.category -ieq 'fcoe-networks')) 
				{
				    
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Network Object provided: $($net | FL * | out-string)"
				
				}

				else 
				{

				    $errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'Network' -TargetType 'PSObject' -Message "Invalid Network parameter: $($net | FL * | Out-String)"
				    $PSCmdlet.WriteError($errorRecord)

				}

				[void]$_NetworkCollection.Add($Resource)

			}

		}
        
    }

	End
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing $($_NetworkCollection.count) Network resources to remove."

		#Process Network Resources
		ForEach ($_network in $_NetworkCollection)
		{

			if ($pscmdlet.ShouldProcess($_network.name,"Remove Network from appliance '$($_network.ApplianceConnection.Name)'?'")) 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Removing Network '$($_network.name)' from appliance '$($_network.ApplianceConnection.Name)'."

				Try
				{
					
					if ($PSBoundParameters['Force'])
					{

						$_network.uri += "?force=true"

					}

					$_resp = Send-HPOVRequest $_network.Uri DELETE -Hostname $_network.ApplianceConnection.Name

					[void]$_TaskCollection.Add($_resp)

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

			}

			elseif ($PSBoundParameters['WhatIf'])
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] WhatIf parameter was passed."

			}

		}

		Return $_TaskCollection

	}

}

function New-HPOVNetworkSet 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding()]
    Param 
	(

		[parameter (Position = 0,Mandatory = $True)]
		[String]$Name = $null,

		[parameter (Position = 1,Mandatory = $True)]
		[alias('networkUris')]
		[Object]$Networks = $null,

		[parameter (Position = 2,Mandatory = $False)]
		[Alias ('untagged','native','untaggedNetworkUri')]
		[Object]$UntaggedNetwork = $null,

		[parameter (Position = 3,Mandatory = $False)]
		[int32]$typicalBandwidth = 2500,

		[parameter (Position = 4,Mandatory = $False)]
		[int32]$maximumBandwidth = 10000,
	
		[parameter(Mandatory = $False, ValueFromPipelineByPropertyName, position = 5)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

    )
	
	Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_NetSetStatusCol = New-Object System.Collections.ArrayList	

	}
	
	Process 
	{

		ForEach ($_connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_connection.Name)' Appliance Connection"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Building NetworkSet '$($name) object."

			$_NewNetSet = Newobject -NetworkSet

			$_NewNetSet.name = $Name

			# Validate Networks if they are objects, and ApplianceConnection prop matches $_connection.Name value
			ForEach ($_net in $Networks)
			{

				switch ($_net.GetType().Name)
				{

					'String'
					{

						#URI provided
						if ($_net.StartsWith($ethNetworksUri))
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Network resource is [String] and URI. Getting resource object."

							try
							{

								$_net = Send-HPOVRequest $_net -Hostname $_connection.Name

							}

							Catch
							{

								$PSCmdlet.ThrowTerminatingError($_)

							}

						}

						#Name provided
						else
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Network resource is [String] and Name. Getting resource object."

							try
							{

								$_originalnet = $_net

								$_net = Get-HPOVNetwork $_net -ApplianceConnection $_connection.Name

								if ($_net.count -gt 1)
								{

									$errorRecord = New-ErrorRecord HPOneView.NetworkResourceException MultipleNetworkResourcesFound LimitsExceeded 'Networks' -Message "Network '$_originalnet' is not a unique resource name, as multiple Network resources were found.  Please correct the parameter value and try again."
									$PSCmdlet.ThrowTerminatingError($errorRecord)

								}

							}

							Catch
							{

								$PSCmdlet.ThrowTerminatingError($_)

							}

						}

					}

					'PSCustomObject'
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Object: $($_net | fl * | Out-String)"

						#Object must have the ApplianceConnection NoteProperty
						if (-not($_net.ApplianceConnection))
						{

							$errorRecord = New-ErrorRecord HPOneView.NetworkResourceException MissingApplianceConnectionNoteProperty InvalidArgument 'Networks' -TargetType 'PSObject' -Message "Network '$($_net.name)' does not contain the required 'ApplianceConnection' NoteProperty. Network objects must be retrieved from the appliance either using their unique URI or with Get-HPOVNetwork. Please correct the parameter value  and try again."
							$PSCmdlet.ThrowTerminatingError($errorRecord)

						}

						elseif ($_net.ApplianceConnection.Name -ne $_Connection.Name)
						{

							$errorRecord = New-ErrorRecord HPOneView.NetworkResourceException ApplianceConnetionDoesNotMatchObject InvalidArgument 'Networks' -TargetType 'PSObject' -Message "Network '$($_net.name)' 'ApplianceConnection' NoteProperty {$($_net.ApplianceConnection.Name)}does not match the Appliance Connection currently processing {$($_connection.Name)}. Network objects must be retrieved from the appliance either using their unique URI or with Get-HPOVNetwork. Please correct the parameter value and try again."
							$PSCmdlet.ThrowTerminatingError($errorRecord)

						}

						if ($_net.category -ne 'ethernet-networks')
						{

							$errorRecord = New-ErrorRecord HPOneView.NetworkResourceException UnsupportedResourceCategory InvalidArgument 'Networks' -TargetType 'PSObject' -Message "Network '$($_net.name)' category {$($_net.category)} is not the supported type, 'ethernet-networks'. Network objects must be retrieved from the appliance either using their unique URI or with Get-HPOVNetwork using the -Type Ethernet parameter. Please correct the parameter value and try again."
							$PSCmdlet.ThrowTerminatingError($errorRecord)

						}

					}

					default
					{

						$errorRecord = New-ErrorRecord HPOneView.NetworkResourceException UnsupportedParameterValueType InvalidType 'Networks' -TargetType $_Net.GetType().Name -Message "The provided Networks parameter value type '$($_Net.GetType().Name)' is not supported.  Only String (Name or URI) or PSCustomObject types are allowed and supported. Please correct the parameter value and try again."
						$PSCmdlet.ThrowTerminatingError($errorRecord)

					}

				}

				[void]$_NewNetSet.networkUris.Add($_net.uri)

			}

			if ($PSboundParameters['UntaggedNetwork'])
			{

				# Validate UntaggedNetwork if it is an object, and ApplianceConnection prop matches $_connection.Name value
				switch ($UntaggedNetwork.GetType().Name)
				{

					'String'
					{

						#URI provided
						if ($UntaggedNetwork.StartsWith($ethNetworksUri))
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] UntaggedNetwork resource is [String] and URI. Getting resource object."

							try
							{

								$UntaggedNetwork = Send-HPOVRequest $UntaggedNetwork -Hostname $_connection.Name

							}

							Catch
							{

								$PSCmdlet.ThrowTerminatingError($_)

							}

						}

						#Name provided
						else
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] UntaggedNetwork resource is [String] and Name. Getting resource object."

							try
							{

								$UntaggedNetwork = Get-HPOVNetwork $UntaggedNetwork -ApplianceConnection $_connection.Name

								if ($UntaggedNetwork.count -gt 1)
								{

									$errorRecord = New-ErrorRecord HPOneView.NetworkResourceException MultipleNetworkResourcesFound LimitsExceeded 'UntaggedNetwork' Message "Network '$_originalnet' is not a unique resource name, as multiple Network resources were found.  Please correct theparameter value and try again."
									$PSCmdlet.ThrowTerminatingError($errorRecord)

								}

							}

							Catch
							{

								$PSCmdlet.ThrowTerminatingError($_)

							}

						}

					}

					'PSCustomObject'
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Object: $($UntaggedNetwork | fl * | Out-String)"

						#Object must have the ApplianceConnection NoteProperty
						if (-not($UntaggedNetwork.ApplianceConnection))
						{

							$errorRecord = New-ErrorRecord HPOneView.NetworkResourceException MissingApplianceConnectionNoteProperty InvalidArgument 'UntaggedNetwork' TargetType 'PSObject' -Message "Network '$($UntaggedNetwork.name)' does not contain the required 'ApplianceConnection' NoteProperty. Networkobjects must be retrieved from the appliance either using their unique URI or with Get-HPOVNetwork. Please correct the parameter value and try again."
							$PSCmdlet.ThrowTerminatingError($errorRecord)

						}

						elseif ($UntaggedNetwork.ApplianceConnection.Name -ne $_Connection.Name)
						{

							$errorRecord = New-ErrorRecord HPOneView.NetworkResourceException ApplianceConnetionDoesNotMatchObject InvalidArgument 'UntaggedNetwork' TargetType 'PSObject' -Message "Network '$($UntaggedNetwork.name)' 'ApplianceConnection' NoteProperty {$($UntaggedNetwork.ApplianceConnection.Name)}does notmatch the Appliance Connection currently processing {$($_connection.Name)}. Network objects must be retrieved from the appliance either using their unique URI or with Get-HPOVNetwork. Please correct the parameter value and try again."
							$PSCmdlet.ThrowTerminatingError($errorRecord)

						}

						if ($UntaggedNetwork.category -ne 'ethernet-networks')
						{

							$errorRecord = New-ErrorRecord HPOneView.NetworkResourceException UnsupportedResourceCategory InvalidArgument 'UntaggedNetwork' -TargetType'PSObject' -Message "Network '$($UntaggedNetwork.name)' category {$($UntaggedNetwork.category)} is not the supported type, 'ethernet-networks'. Network objects must be retrieved from the appliance either using their unique URI or with Get-HPOVNetwork using the -Type Ethernet parameter.Please correct the parameter value and try again."
							$PSCmdlet.ThrowTerminatingError($errorRecord)

						}

					}

					default
					{

						$errorRecord = New-ErrorRecord HPOneView.NetworkResourceException UnsupportedParameterValueType InvalidType 'UntaggedNetwork' -TargetType	$UntaggedNetwork.GetType().Name -Message "The provided UntaggedNetwork parameter value type '$($UntaggedNetwork.GetType().Name)' is not	  supported.  Only String (Name or URI) or PSCustomObject types are allowed and supported. Please correct the parameter value and try again."
						$PSCmdlet.ThrowTerminatingError($errorRecord)

					}

				}

				$_NewNetSet.nativeNetworkUri = $UntaggedNetwork.uri

			}

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Network Set object: $($_NewNetSet | out-string)"

			#Caller is requesting different bandwidth settings.  Need to handle async task to create network set.
			if ($PSBoundParameters['TypicalBandwidth'] -or $PSBoundParameters['MaximumBandwidth']) 
			{

			    try 
				{

			        $_task = Send-HPOVRequest $networkSetsUri POST $_NewNetSet -Hostname $_connection.Name | Wait-HPOVTaskComplete

			        if ($_task.taskStatus -eq "Created") 
					{

			            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Network Set was successfully created"
			            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Updating Network Set bandwidth"
				        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Requested Typical bandwidth: $($typicalBandwidth)"
				        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Requested Maximum bandwidth: $($maximumBandwidth)"

			            #Get Network Set Object
			            Try
						{

							$_NetSetObj = Send-HPOVRequest $_task.associatedResource.resourceUri -Hostname $_connection.Name

						}

						Catch
						{

							$PSCmdlet.ThrowTerminatingError($_)

						}
						
						# Update the associated connection template with max & typical bandwidth settings	            
						Try
						{

							$_ct = Send-HPOVRequest $_NetSetObj.connectionTemplateUri -Hostname $_connection.Name

						}
						
						Catch
						{

							$PSCmdlet.ThrowTerminatingError($_)

						}
			            

			            if ($PSBoundParameters['typicalBandwidth']) { $_ct.bandwidth.typicalBandwidth = $typicalBandwidth }

			            if ($PSBoundParameters['maximumBandwidth']) { $_ct.bandwidth.maximumBandwidth = $maximumBandwidth }
			            
						#Update Connection Template Object
						Try
						{

							$_ct = Send-HPOVRequest $_ct.uri PUT $_ct -Hostname $_connection.Name

						}
						
						Catch
						{

							$PSCmdlet.ThrowTerminatingError($_)

						}

						#Get Network Set Object after CT has been updated
						Try
						{

							$_NetSetObj = Send-HPOVRequest $_NetSetObj.uri -Hostname $_connection.Name

						}

						Catch
						{

							$PSCmdlet.ThrowTerminatingError($_)

						}
			            
			        }

			    }

			    catch 
				{

			        $PSCmdlet.ThrowTerminatingError($_)

			    }

				[void]$_NetSetStatusCol.Add($_NetSetObj)

			}

			else 
			{

			    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request with default bandwidth."

				Try
				{

					$_task = Send-HPOVRequest $networkSetsUri POST $_NewNetSet -Hostname $_connection.Name

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

			    [void]$_NetSetStatusCol.Add($_task)

			}

		}

    }

    end 
	{

	    #Return Network Set collection status/objects
	    Return $_NetSetStatusCol

	}

}

function Get-HPOVNetworkSet 
{

	# .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdLetBinding(DefaultParameterSetName = "Default")]
	Param 
	(

		[parameter (Position = 0, ParameterSetName = "Default", Mandatory = $false)]
		[parameter (Position = 0, ParameterSetName = "Export", Mandatory = $false)]
		[String]$Name = $null,
		
		[parameter(Mandatory = $false)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions},

		[parameter (ParameterSetName = "Export", Mandatory = $false)]
		[alias("x", "export")]
		[ValidateScript({split-path $_ | Test-Path})]
		[String]$exportFile

	)

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSBoundParameters['type']))
		{
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] -Type parameter wasn't provided. Specifying all Network Resource Types."

			[Array]$type = "Ethernet","FibreChannel","FCOE"

		}

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_NetworkSetCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{

		ForEach ($Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($Connection.Name)' Appliance (of $($ApplianceConnection.Count))"

			$uri = $networkSetsUri + "?sort=name:asc"

			if ($name)
			{
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Filtering for Network Set name: $name"

				$uri = $uri + "&filter=`"name matches '$name'`"" -replace ("[*]","%25")

			}

			Try
			{

				$_NetSets = Send-HPOVRequest $uri -Hostname $_Connection

			}
			
			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			#Add to final collection arraylist
			if ($_NetSets.members) 
			{ 
						
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding results to collection"

				$_NetSets.members | % { 

					if ($_.connectionTemplateUri) 
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Network Set resource Connection Template Object to add bandwidth values to network objects."

						Try
						{

							$ct = Send-HPOVRequest -uri $_.connectionTemplateUri -Hostname $_Connection

						}
					
						Catch
						{

							$PSCmdlet.ThrowTerminatingError($_)

						}

						Add-Member -InputObject $_ -NotePropertyName maximumBandwidth -NotePropertyValue $ct.bandwidth.maximumBandwidth -Force 
						Add-Member -InputObject $_ -NotePropertyName typicalBandwidth -NotePropertyValue $ct.bandwidth.typicalBandwidth -Force

					}

					$_.PSObject.TypeNames.Insert(0,”HPOneView.Networking.NetworkSet")  

					[void]$_NetworkSetCollection.Add($_)
						
				} 

			}

        }

    }

    End 
	{

		#If network not found, report error
		if ((-not($_NetworkSetCollection)) -and $Name)
		{ 

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Network Set Resource Name was provided, yet no results were found.  Generate Error."

			$errorRecord = New-ErrorRecord HPOneView.NetworkSetResourceException NetworkSetResourceNotFound ObjectNotFound "Name" -Message "The specified '$name' Network Set resource was not found.  Please check the name and try again."
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

        if ($_NetworkSetCollection) 
		{

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Results returned "

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Network Sets Found: $($_NetworkSetCollection | fl * | out-string ) "

			"[$($MyInvocation.InvocationName.ToString().ToUpper())] Done. {0} network set resource(s) found." -f $_NetworkSetCollection.Count | Write-Verbose 
            
			if ($exportFile) 
			{ 
                
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Exporting JSON to $($exportFile)"
			
                $_NetworkSetCollection | convertto-json > $exportFile
			
            }
            
			else
			{

				Return $_NetworkSetCollection
			
			}
        
		}

        #No network sets found
        else
		{ 
			
			write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No Network set resources found." 
		
		}

    }

}

function Set-HPOVNetworkSet 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding()]
    Param 
    (

        [parameter (Mandatory = $true, ValueFromPipeline = $true, Position = 0)]
        [ValidateNotNullorEmpty()]
		[Alias('NetSet')]
        [Object]$NetworkSet,

        [parameter (Mandatory = $false, Position = 1)]
        [ValidateNotNullorEmpty()]
        [String]$Name,

        [parameter (Mandatory = $false, Position = 2)]
        [ValidateNotNullorEmpty()]
        [Object]$Networks,

        [parameter (Mandatory = $False, Position = 3)]
        [Alias ('untagged','native','untaggedNetworkUri')]
        [ValidateNotNullorEmpty()]
        [Object]$UntaggedNetwork = $null,

        [parameter(Position = 5, Mandatory = $false)]
        [validaterange(2,20000)]
        [int32]$TypicalBandwidth = $null, 
        
        [parameter(Position = 6, Mandatory = $false)]
        [validaterange(100,20000)]
        [int32]$MaximumBandwidth = $Null,

        [parameter(Mandatory = $false, ValueFromPipelinebyPropertyName)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

    )

    Begin 
    {

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"
        
		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSBoundParameters['NetworkSet']))
		{

			$PipelineInput = $True

		}

		if (-not($PipelineInput))
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
			$c = 0
		
			ForEach ($_Connection in $ApplianceConnection) 
			{

				Try 
				{
			
					$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

				}

				Catch [HPOneview.Appliance.AuthSessionException] 
				{

					$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				Catch 
				{

					$PSCmdlet.ThrowTerminatingError($_.Exception)

				}

				$c++

			}

			#Check for URI parameters with multiple appliance connections
			if($ApplianceConnection.Count -gt 1)
			{

				if ($NetworkSet -is [String] -and ($NetworkSet.StartsWith($networkSetsUri))) 
				{
                    
					$errorRecord = New-ErrorRecord HPOneView.NetworkResourceException InvalidArgumentValue InvalidArgument 'NetworkSet' -Message "The NetworkSet parameter as URI is unsupported with multiple appliance connections.  Please check the -NetworkSet parameter value and try again."
					$PSCmdLet.ThrowTerminatingError($errorRecord)
            
				}

				if (($Networks -is [string] -and $Networks.startswith($ethNetworksUri)) -or ($Networks -is [Array] -and ($Networks | % { $_.startswith($ethNetworksUri) })))
				{

					$errorRecord = New-ErrorRecord HPOneView.NetworkResourceException InvalidArgumentValue InvalidArgument 'Networks' -TargetType $Networks.GetType().Name -Message "Networks parameter contains 1 or more URIs that are unsupported with multiple appliance connections.  Please check the -networks parameter value and try again."
					$PSCmdLet.ThrowTerminatingError($errorRecord)

				}

				if ($UntaggedNetwork -is [string] -and $UntaggedNetwork.startswith($ethNetworksUri)) 
				{

					$errorRecord = New-ErrorRecord HPOneView.NetworkResourceException InvalidArgumentValue InvalidArgument 'Set-HPOVNetworkSet' -Message "Untaggednetwork parameter as URI is unsupported with multiple appliance connections.  Please check the -untaggednetwork parameter value and try again."
					$PSCmdLet.ThrowTerminatingError($errorRecord)

				}

			}

		}
        
        $_TaskCollection = New-Object System.Collections.ArrayList

	}

    Process 
	{
        
        ForEach ($_Connection in $ApplianceConnection)
		{

			#Process Network Set input object is the correct resource and data type.
            switch ($NetworkSet.Gettype().Name) 
			{

                "PSCustomObject" 
				{ 
    
                    if ($NetworkSet.category -eq "network-sets")
					{

                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing $($NetworkSet.type) $($NetworkSet.name) resource."

                    }

                    else 
					{

                        $errorRecord = New-ErrorRecord HPOneView.NetworkResourceException InvalidArgumentValue InvalidArgument 'NetworkSet' -TargetType 'PSObject' -Message "The provided NetworkSet resource contains an unsupported category type, '$($NetworkSet.category)'.  Only 'network-sets' resources are allowed.  Please check the -NetworkSet parameter value and try again."
                        $PSCmdLet.ThrowTerminatingError($errorRecord)

                    }
                
                }

                "String" 
				{ 
                
                    if (-not ($NetworkSet.StartsWith($networkSetsUri)))
					{
                    
                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting '$($NetworkSet)' resource from appliance."

						Try
						{

							$NetworkSet = Get-HPOVNetworkSet $NetworkSet -appliance $_Connection

						}

						Catch
						{

							$PSCmdlet.ThrowTerminatingError($_)

						}
                        
                        
                        #if (-not $NetworkSet) {
						#
                        #    $errorRecord = New-ErrorRecord HPOneView.NetworkResourceException NetworkSetResourceNotFound ObjectNotFound 'Set-HPOVNetwork' -Message #"'$netSet' Network Set was not found.  Please check the value and try again."
                        #    $PSCmdLet.ThrowTerminatingError($errorRecord)
						#
                        #}
                    
                    }

                    elseif ($netSet.StartsWith($networkSetsUri))
					{
                    
                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting '$($netSet)' resource from appliance."

						Try
						{

							$NetworkSet = Send-HPOVRequest $NetworkSet -appliance $_Connection

						}

						Catch
						{

							$PSCmdlet.ThrowTerminatingError($_)

						}
                    
                    }
                
                }

                default
				{
                    
                    #if($netSet -is [Object[]] -and ($netSet.category -eq "network-sets")){
                    #    $updatedNetworkSet = $netSet | ? {$_.ApplianceConnection.name -eq $ApplianceConnection.name}
                    #}
                    #else {

                        $errorRecord = New-ErrorRecord HPOneView.NetworkSetResourceException InvalidArgumentValue InvalidArgument 'NetworkSet' -TargetType $NetworkSet.GetType().Name -Message "[$($netSet.gettype().name)] is an unsupported data type.  Only [System.String] or [PSCustomObject] Network Set resources are allowed.  Please check the -NetworkSet parameter value and try again."
                        $PSCmdLet.ThrowTerminatingError($errorRecord)

                    #}

                }

            }

			$_UpdatedNetSet = $NetworkSet.PSObject.Copy()

            #Process Network Set Name change
            if ($PSBoundParameters["Name"]) 
			{
            
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Updating Network Set name to '$name'."

                $_UpdatedNetSet.name = $name
            
            }

            if ($PSBoundParameters["Networks"]) 
			{

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing $($Networks.count) network resources"

                [array]::sort($Networks)

                $i = 1

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Clearing out existing networkUris."

				$_UpdatedNetSet.networkUris = New-Object System.Collections.ArrayList

                foreach ($_net in $Networks) 
				{

					switch ($_net.GetType().Name)
					{

						'String'
						{

							if ($_net.startswith($ethNetworksUri)) 
							{

								Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Network [$i] is a URI: $_net"

								[void]$_UpdatedNetSet.networkUris.Add($net)

							}

							elseif ($net -is [string]) 
							{

								Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Network [$i] is a Name: $net"

								Try
								{

									$_networkObject = Get-HPOVNnetwork $_net -type Ethernet -appliance $_Connection

									[void]$_UpdatedNetSet.networkUris.Add($_networkObject.uri)

								}

								Catch
								{

									$PSCmdlet.ThrowTerminatingError($_)

								}
								
							}

						}

						'PSCustomObject'
						{

							if ($_net.category -eq "ethernet-networks") 
							{

								Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Network [$i] is a type [PsCustomObject]"
								Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Network [$i] Name: $($_net.name)"
								Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Network [$i] uri: $($_net.uri)"

							}

							else 
							{

								$errorRecord = New-ErrorRecord HPOneView.NetworkResourceException InvalidArgumentValue InvalidArgument 'Networks' -TargetType $_Net.GetType().Name -Message "Network '$($_net.name)' is not a supported type '$($_net.gettype().fullname)'.  Network resource must be either [System.String] or [PsCustomObject].  Please correct the parameter value and try again."
								$PSCmdlet.ThrowTerminatingError($errorRecord)

							}

							[void]$_UpdatedNetSet.networkUris.Add($_net.uri)

						}

						default
						{

							$errorRecord = New-ErrorRecord HPOneView.NetworkResourceException InvalidArgumentValue InvalidArgument 'Networks' -TargetType $_Net.GetType().Name -Message "The provided Network is not a supported type '$($_net.gettype().fullname)'.  Network resource must be either [System.String] or [PsCustomObject].  Please correct the parameter value and try again."
							$PSCmdlet.ThrowTerminatingError($errorRecord)

						}

					}

                    $i++
                    
                }

            }

    	    if ($PSBoundParameters["UntaggedNetwork"])
			{



				switch ($UntaggedNetwork.GetType().Name)
				{

					'String'
					{

						if ($UntaggedNetwork.startswith($ethNetworksUri)) 
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Untagged Network is a URI: $UntaggedNetwork"

							$_UpdatedNetSet.nativeNetworkUri = $UntaggedNetwork

						}

						elseif ($net -is [string]) 
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Untagged Network is a Name: $UntaggedNetwork"

							Try
							{

								$_networkObject = Get-HPOVNnetwork $UntaggedNetwork -type Ethernet -appliance $_Connection

								$_UpdatedNetSet.nativeNetworkUri = $_networkObject.uri

							}

							Catch
							{

								$PSCmdlet.ThrowTerminatingError($_)

							}
								
						}

					}

					'PSCustomObject'
					{

						if ($UntaggedNetwork.category -eq "ethernet-networks") 
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Native Network is a type [PsCustomObject]"
							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Native Network Name: $($UntaggedNetwork.name)"
							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Native Network uri: $($UntaggedNetwork.uri)"

						}

						else 
						{

							$errorRecord = New-ErrorRecord HPOneView.NetworkResourceException InvalidArgumentValue InvalidArgument 'UntaggedNetwork' -TargetType $UntaggedNetwork.GetType().Name -Message "The UntaggedNetwork '$($UntaggedNetwork.name)' is not a supported type '$($UntaggedNetwork.gettype().fullname)'.  Network resource must be either [System.String] or [PsCustomObject].  Please correct the parameter value and try again."
							$PSCmdlet.ThrowTerminatingError($errorRecord)

						}

						$_UpdatedNetSet.nativeNetworkUri = $UntaggedNetwork.uri

					}

					default
					{

						$errorRecord = New-ErrorRecord HPOneView.NetworkResourceException InvalidArgumentValue InvalidArgument 'UntaggedNetwork' -TargetType $UntaggedNetwork.GetType().Name -Message "The provided UntaggedNetwork is not a supported type '$($UntaggedNetwork.gettype().fullname)'.  Network resource must be either [System.String] or [PsCustomObject].  Please correct the parameter value and try again."
						$PSCmdlet.ThrowTerminatingError($errorRecord)

					}

				}

		    }

            #Process Network Set Bandwidth assignment change
            if ($PSBoundParameters["TypicalBandwidth"] -or $PSBoundParameters["MaximumBandwidth"]) 
			{

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Updating Network bandwidth assignment."

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Network Set Connection Template."
				
				Try
				{

					$_ct = Send-HPOVRequest $_UpdatedNetSet.connectionTemplateUri -appliance $_Connection

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}
                
                if ($PSBoundParameters["MaximumBandwidth"]) 
				{
                
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Original Maximum bandwidth assignment: $($_ct.bandwidth.maximumBandwidth)"

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] New Maximum bandwidth assignment: $MaximumBandwidth"

                    $_ct.bandwidth.maximumBandwidth = $MaximumBandwidth

                }

                if($PSBoundParameters["TypicalBandwidth"]) 
				{

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Original Typical bandwidth assignment: $($_ct.bandwidth.typicalBandwidth)"

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] New Typical bandwidth assignment: $TypicalBandwidth"

                    $_ct.bandwidth.typicalBandwidth = $TypicalBandwidth
                    
                }

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Updating Connection Template: $($_ct | out-string)"

                Try
				{

					$_ct = Send-HPOVRequest $_UpdatedNetSet.connectionTemplateUri PUT $_ct -appliance $_Connection

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

            }

            $_UpdatedNetSet = $_UpdatedNetSet | select * -ExcludeProperty typicalBandwidth, maximumBandwidth, created, modified, state, status
            
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Updating Network Resource object: $($_UpdatedNetSet | out-string)"

			Try
			{

				$_results = Send-HPOVRequest $_UpdatedNetSet.Uri PUT $_UpdatedNetSet -appliance $_Connection.Name

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

            [void]$_TaskCollection.Add($_results)

        }

    }

    End 
	{

		Return $_TaskCollection

    }

}

function Remove-HPOVNetworkSet 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "default",SupportsShouldProcess = $True,ConfirmImpact = 'High')]
    Param 
	(
        
        [parameter (Mandatory, ValueFromPipeline, ParameterSetName = "default", HelpMessage = "Specify the Network Set(s) to remove.", Position = 0)]
        [ValidateNotNullOrEmpty()]
        [Alias("uri","name")]
        [Object]$NetworkSet = $null,

        [parameter(Mandatory = $false, ValueFromPipelinebyPropertyName)]
		[ValidateNotNullOrEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

    )

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"
        
		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSBoundParameters['NetworkSet']))
		{

			$PipelineInput = $True

		}

		if (-not($PipelineInput))
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
			$c = 0
		
			ForEach ($_Connection in $ApplianceConnection) 
			{

				Try 
				{
			
					$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

				}

				Catch [HPOneview.Appliance.AuthSessionException] 
				{

					$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				Catch 
				{

					$PSCmdlet.ThrowTerminatingError($_.Exception)

				}

				$c++

			}

			#Check for URI parameters with multiple appliance connections
			if($ApplianceConnection.Count -gt 1)
			{

				if (($NetworkSet -is [String] -and ($NetworkSet.StartsWith($networkSetsUri))) -or ($NetworkSet -is [Array] -and ($NetworkSet | % { $_.startswith($networkSetsUri) }))) 
				{
                    
					$errorRecord = New-ErrorRecord HPOneView.NetworkResourceException InvalidArgumentValue InvalidArgument 'NetworkSet' -Message "The NetworkSet parameter as URI is unsupported with multiple appliance connections.  Please check the -NetworkSet parameter value and try again."
					$PSCmdLet.ThrowTerminatingError($errorRecord)
            
				}

			}

		}
        
		$_NetSetsToRemoveCol = New-Object System.Collections.ArrayList

        $_TaskCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{

		if ($PipelineInput)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing pipeline input objects."

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Received object: $($NetworkSet | fl * | Out-String)"

			if ($NetworkSet.category -ne 'network-sets')
			{

				$errorRecord = New-ErrorRecord HPOneView.NetworkSetException InvalidArgumentValue InvalidArgument 'NetworkSet' -TargetType 'PSObject' -Message "The provided Network Set {$($NetworkSet.Name)} is an unsupported object category, '$($NetworkSet.category)'.  Only 'network-sets' category objects are supported. please chceck the parameter value and try again."
                $PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			[void]$_NetSetsToRemoveCol.Add($NetworkSet)

		}

		Else
		{

			ForEach ($_connection in $ApplianceConnection)
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing $($_connection.Name) appliance connection (of $($ApplianceConnection.Count))."

				Try
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Network Set object from Get-HPOVNetworkSet."

					$NetworkSet = Get-HPOVNetworkSet $NetworkSet -ApplianceConnection $_connection

					[void]$_NetSetsToRemoveCol.Add($NetworkSet)

				}

				Catch
				{


					$PSCmdlet.ThrowTerminatingError($_)
				}

			}

		}

	}

	End
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Begin resource removal process."

	    foreach ($_NetSet in $_NetSetsToRemoveCol) 
		{

            if ($pscmdlet.ShouldProcess($_NetSet.name,"Remove Network Set from appliance '$($_NetSet.ApplianceConnection.Name)'"))
			{   
             
                
				Try
				{
					
					$_task = Send-HPOVRequest $_NetSet.uri DELETE -Hostname $_NetSet.ApplianceConnection.Name

					[void]$_TaskCollection.Add($_task)

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

            }

			elseif ($PSBoundParameters['WhatIf'])
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Caller passed -WhatIf parameter."

			}

			else
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Caller selected NO to confirmation prompt."

			}

        }

		Return $_TaskCollection

    }

}

function Get-HPOVAddressPool 
{  

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "Default")]
    Param 
	(
        
        [parameter (Position = 0, Mandatory = $false, ParameterSetName = "Default")]
		[ValidateSet('vmac', 'vwwn', 'vsn', 'all')]
        [Array]$Type = "all",

        [parameter (Mandatory = $false, ParameterSetName = "Default")]
        [Switch]$Ranges,

        [parameter (Mandatory = $false, ParameterSetName = "Default")]
        [Switch]$Report,
		
		[parameter(Mandatory = $false)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}
    
	)

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		if ($PSBoundParameters['Report']) { Write-Warning "The -Report swtich is deprecated." }

		if ($PSBoundParameters['Ranges']) { Write-Warning "The -Ranges swtich is deprecated." }

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Requested Address Pool type: $($Type) "

        if ($Type -ieq "all") { $Type = @("VMAC", "VWWN", "VSN") }

		$_AddressPoolCollection = New-Object System.Collections.ArrayList
        
	}
	
	Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_Connection.Name)' Appliance (of $($ApplianceConnection.Count))"

	        switch ($Type) 
			{

	            "vmac" 
				{ 

	                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Retrieve VMAC Address Pool details."
	            
	                #Get the VMAC Pool object
					Try
					{

						$_VMACPool = Send-HPOVRequest $ApplianceVmacPoolsUri -Hostname $_Connection.Name

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

					$_VMACPool | % { $_.PSObject.TypeNames.Insert(0,”HPOneView.Appliance.AddressPool") } 
					
					[void]$_AddressPoolCollection.Add($_VMACPool)

	            }

	            "vwwn" 
				{ 

	                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Retrieve VWWN Address Pool details."	
            
	                #Get the VWWN Pool object
					Try
					{

						$_VWWNPool = Send-HPOVRequest $ApplianceVwwnPoolsUri -Hostname $_Connection.Name

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

					$_VWWNPool | % { $_.PSObject.TypeNames.Insert(0,”HPOneView.Appliance.AddressPool") } 
					
					[void]$_AddressPoolCollection.Add($_VWWNPool)

	            }
	            
	            "vsn" 
				{

	                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Retrieve VSN Address Pool details."

	                $pool = Send-HPOVRequest $script:ApplianceVsnPoolsUri 

	                #Get the VSN Pool object
					Try
					{

						$_VWWNPool = Send-HPOVRequest $ApplianceVsnPoolsUri -Hostname $_Connection.Name

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

					$_VWWNPool | % { $_.PSObject.TypeNames.Insert(0,”HPOneView.Appliance.AddressPool") } 
					
					[void]$_AddressPoolCollection.Add($_VWWNPool)

	            }

	        }

		}

	}

	End 
	{

		return $_AddressPoolCollection 

    }

}

function Get-HPOVAddressPoolRange 
{  

	# .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "Default")]
    Param 
	(

        [parameter (Position = 0, Mandatory, ValueFromPipeline, ParameterSetName = "Default")]
		[ValidateNotNullorEmpty()]
		[ValidateSet('vmac', 'vwwn', 'vsn', 'all')]
        [Object]$Pool = 'all',
		
		[parameter(Mandatory = $false, ValueFromPipelineByPropertyName, ParameterSetName = "Default")]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}
    
	)

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		if (-not($PSBoundParameters['Pool'])) { $PipelineInput = $True }

		$_RangeList = New-Object System.Collections.ArrayList
                    
    }

    Process 
	{

		Switch ($Pool.GetType().Name) 
		{

			"String" 
			{ 

				ForEach ($_Connection in $ApplianceConnection)
				{

					Try
					{

						$_AddressPoolCol = Get-HPOVAddressPool $pool -ApplianceConnection $_Connection.Name

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

					foreach ($_AddressPool in $_AddressPoolCol) 
					{

						ForEach ($_RangUri in $_AddressPool.rangeUris)
						{

							Try
							{

								$_rangeObject = Send-HPOVRequest $_RangUri -Hostname $_AddressPool.ApplianceConnection.Name

							}

							Catch
							{

								$PSCmdlet.ThrowTerminatingError($_)

							}

							$_rangeObject | % { $_.PSObject.TypeNames.Insert(0,”HPOneView.Appliance.AddressPoolRange") } 

							[void]$_RangeList.Add($_rangeObject)

						}

					}

				}

			}

			"PSCustomObject" 
			{

				if ($Pool.category -match "id-pool-" -and $Pool.ApplianceConnection) 
				{

					foreach ($_RangeUri in $Pool.rangeUris) 
					{

						Try
						{

							$_rangeObject = Send-HPOVRequest $_RangeUri -Hostname $Pool.ApplianceConnection.Name

						}
						
						Catch
						{

							$PSCmdlet.ThrowTerminatingError($_)

						}

						$_rangeObject | % { $_.PSObject.TypeNames.Insert(0,”HPOneView.Appliance.AddressPoolRange") } 
                        
						[void]$_RangeList.Add($_rangeObject)

					}

                }

				elseif ($Pool.category -match "id-pool-" -and -not($Pool.ApplianceConnection))
				{

					$errorRecord = New-ErrorRecord InvalidOperationException MissingApplianceConnectionProperty InvalidArgument 'Pool' 'PSObject' -Message "The Pool parameter value does not contain an ApplianceConnection property.  Did this object come from Get-HPOVAddressPool or Send-HPOVRequest?  Please correct the parameter value and try again."
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				else 
				{
				
					$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'Pool' -TargetType 'PSObject' -Message "The Pool parameter value is not a valid Poll ID object.  Object Category '$($Pool.category)', expected 'id-pool-vmac', 'id-pool-vwwn', or 'id-pool.vsn'.  Please correct the parameter value and try again."
					$PSCmdlet.ThrowTerminatingError($errorRecord)
                
				}
				
			}

        }

    }

	End 
	{

		Return $_RangeList

    }

}

function New-HPOVAddressRange 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding()]
    Param 
	(
    
        [parameter (Mandatory = $true, ParameterSetName = "Default", position = 0)]
        [parameter (Mandatory = $true, ParameterSetName = "Custom", position = 0)]
        [ValidateSet("vmac", "vwwn", "vsn")]
        [String]$PoolType = $Null,

        [parameter (Mandatory = $true, ParameterSetName = "Default", position = 1)]
        [parameter (Mandatory = $true, ParameterSetName = "Custom", position = 1)]
        [ValidateSet("Generated", "Custom")]
        [String]$RangeType = "Generated",

        [parameter (Mandatory = $true, ParameterSetName = "Custom", position = 2)]
        [String]$Start,

        [parameter (Mandatory = $true, ParameterSetName = "Custom", position = 3)]
        [String]$End,
	
		[parameter(Mandatory = $False)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}
    
    )

    Begin 
	{ 

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{
		
			Try 
			{
		
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection
		
			}
		
			Catch [HPOneview.Appliance.AuthSessionException] 
			{
		
				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)
		
			}
		
			Catch 
			{
		
				$PSCmdlet.ThrowTerminatingError($_)
		
			}
		
			$c++
		
		}

		$_Collection = New-Object System.Collections.ArrayList

		#Validate parameter options here
		if ($PSCmdlet.ParameterSetName -eq 'Custom' -and $RangeType -ne 'Custom')
		{

			$errorRecord = New-ErrorRecord InvalidOperationException LogicalInterconnectUriNoApplianceConnection InvalidArgument 'RangeType' -Message "Custom Address Range was provided, but the RangeType parameter value was not set to 'Custom'. Please check to make sure your call is correct, and try again.."
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		#Generate error when defining custom range and not a specific appliance
		if ($PSCmdlet.ParameterSetName -eq 'Custom' -and $ApplianceConnection.count -gt 1)
		{

			$errorRecord = New-ErrorRecord InvalidOperationException LogicalInterconnectUriNoApplianceConnection InvalidArgument 'ApplianceConnection' -Message "A Custom Address Range was provided with no Appliance Connection specified.  Custom Address Pool Ranges should be unique per appliance connection.  Please specify an Appliance Connection and try your call again."
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}
    
    }

    Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_Connection.Name)' appliance (of $($ApplianceConnection.Count))"

			#Get the correct URI to request a new Generated Address Range
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Creating new $($PoolType) type address range"

			switch ($PoolType) 
			{

				"vmac" 
				{ 
            
						$_newGenRangeUri  = $script:ApplianceVmacGenerateUri
						$_newPoolRangeUri = $script:ApplianceVmacPoolRangesUri

				}

				"vwwn" 
				{ 
            
						$_newGenRangeUri  = $script:ApplianceVwwnGenerateUri
						$_newPoolRangeUri = $script:ApplianceVwwnPoolRangesUri
                
					}

					"vsn" 
					{ 
            
						$_newGenRangeUri  = $script:ApplianceVsnPoolGenerateUri
						$_newPoolRangeUri = $script:ApplianceVsnPoolRangesUri
            
				}

			}

			switch ($RangeType) 
			{

			    "Generated" 
				{
			        
			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Generating new address range"
			    
			        #send the request, and remove the fragmentType property as it's not a valid JSON pfield for the request.
			        $_newRange = (Send-HPOVRequest $_newGenRangeUri -Hostname $_Connection.Name) | Select-Object -Property * -excludeproperty fragmentType

			        $_newRange | add-member -NotePropertyName type -NotePropertyValue "Range"
			        $_newRange | add-member -NotePropertyName rangeCategory -NotePropertyValue "GENERATED"

			    }
			    
			    "Custom" 
				{

			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Creating custom new address range"
			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Starting Address: $($Start)"
			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] End Address: $($End)"

			        switch ($PoolType) 
					{
			            
			            "vmac" 
						{
			                
			                if (-not($Start -match ($macAddressPattern ))) 
							{ 
								
								Write-Error "The Start MAC Address $($Start) is invalid." -Category SyntaxError -CategoryTargetName New-HPOVAddressRange

							}

			                if (-not($End -match ($macAddressPattern ))) 
							{ 
								
								Write-Error "The End MAC Address $($End) is invalid." -Category SyntaxError -CategoryTargetName New-HPOVAddressRange
							
							}

			             }
			            
			            "vwwn" 
						{
			            
			                if (-not($Start -match ($wwnAddressPattern ))) 
							{ 
								
								Write-Error "The Start WWN Address $($Start) is invalid." -Category SyntaxError -CategoryTargetName New-HPOVAddressRange
							
							}

			                if (-not($End -match ($wwnAddressPattern ))) 
							{ 
								
								Write-Error "The End WWN Address $($End) is invalid." -Category SyntaxError -CategoryTargetName New-HPOVAddressRange
							
							}
			            
			            }

						"vsn" 
						{
			            
			                if (-not($Start.StartWith('VCU'))) 
							{ 
								
								Write-Error "The Start SN Address $($Start) is invalid." -Category SyntaxError -CategoryTargetName New-HPOVAddressRange
							
							}

			                if (-not($End.StartWith('VCU'))) 
							{ 
								
								Write-Error "The End SN Address $($End) is invalid." -Category SyntaxError -CategoryTargetName New-HPOVAddressRange
							
							}
			            
			            }

			        }
			        
			        $_newRange = NewOPbject -IDPoolRange

					$_newRange.startAddress = $Start
					$_newRange.endAddress   = $End
			    
			    }

			}

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] New Range Object: $($_newRange | FL * | out-string)"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request"

			Try
			{

				$_resp = Send-HPOVRequest $newPoolRangeUri POST $newRange -Hostname $_Connection.Name

				$_resp.PSObject.TypeNames.Insert(0,'HPOneView.Appliance.AddressPoolRange')

			}

			Catch
			{

				$PScmdlet.ThrowTerminatingError($_)

			}

			[void]$_Collection.Add($_resp)

        }

	}

	End
	{

        return $_Collection

    }

 }

#######################################################
# Interconnects and Uplinks
#

function Get-HPOVInterconnectType 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = 'Name')]
    Param
	(
        
        [parameter (Position = 0, Mandatory = $false, ParameterSetName = 'Name')]
		[ValidateNotNullorEmpty()]
        [string]$Name = $null,

        [parameter (Position = 0, Mandatory = $true, ParameterSetName = 'PartNumber')]
		[ValidateNotNullorEmpty()]
        [string]$PartNumber = $null,

		[parameter(Mandatory = $false)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions},

        [switch]$list

    )

    Begin 
	{ 

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] {

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$Collection = New-Object System.Collections.ArrayList
		$NotFound   = New-Object System.Collections.ArrayList

		if ($PSBoundParameters['List'])
		{

			Write-Warning 'The -list parameter has been deprecated.  Please update your scripts.'

		}
    
    }
    
    Process 
	{

		ForEach ($_appliance in $ApplianceConnection)
		{

			$uri = $interconnectTypesUri + "?sort=name:descending"

			if ($PSboundParameters['Name']) 
			{ 
				
				$uri += "&filter=name='$name'" 
			
			}
			
			elseif ($PSboundParameters['PartNumber']) 
			{
				
				$uri += "&filter=partNumber='$partNumber'" 
			
			}

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request"

			$resp = Send-HPOVRequest $uri -Appliance $_appliance

			if ($resp.count -gt 0)
			{

				$resp.members | Sort-Object name | % {

					$_interconnectType = $_

					$_interconnectType | % { $_.PSObject.TypeNames.Insert(0,'HPOneView.Networking.InterconnectType')}

					[void]$Collection.Add($_interconnectType)

				}

			}

			else 
			{

				[Void]$NotFound.Add($_appliance.Name)

			}

		}

    }

    end 
	{

        if ((-not($Collection) -or ($NotFound.count -gt 1)) -and $Name) 
		{

			$Collection

            $errorRecord = New-ErrorRecord HPOneView.InterconnectResourceException InterconnectTypeNameResourceNotFound ObjectNotFound 'Name' -Message "No Interconnect Types with '$Name' name were found on appliance $($NotFound -join ", ")."
            $PSCmdlet.ThrowTerminatingError($errorRecord)

        }

        elseif ((-not($Collection) -or ($NotFound.count -gt 0)) -and $PartNumber) 
		{

			$Collection

			$errorRecord = New-ErrorRecord HPOneView.InterconnectTypeResourceException InterconnectTypePartnumberResourceNotFound ObjectNotFound 'PartNumber' -Message "No Interconnect Types with '$PartNumber' partnumber were found on appliance $($NotFound -join ", ")."
            $PSCmdlet.ThrowTerminatingError($errorRecord)

        }

        else 
		{ 
		
			return $Collection

        }

    }

}

function Get-HPOVInterconnect 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding()]
    Param 
	(

		[parameter(Position = 0, Mandatory = $false)]
		[ValidateNotNullorEmpty()]
		[String]$Name = $null,

		[parameter(Position = 1, Mandatory = $false)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions},

		[parameter (Mandatory = $false)]
		[alias("x", "exportFile")]
		[ValidateScript({split-path $_ | Test-Path})]
		[String]$Export

    )

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$InterconnectCollection = New-Object System.Collections.ArrayList
		$NotFound               = New-Object System.Collections.ArrayList
        
	}
	
	Process 
	{

		if ($PSBoundParameters['Name'])
		{

			$Name = $Name -replace ("[*]","%25") -replace ("[&]","%26")

		}	

		ForEach ($_appliance in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_appliance.Name)' Appliance (of $($ApplianceConnection.Count))"		

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request to retrieve Interconnects."

			$_uri = $script:interconnectsUri + "?sort=name:asc"

			$_interconnects = Send-HPOVRequest $_uri -hostname $_appliance.Name

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $($_interconnects.count) Interconnects found."

			if ($Name) 
			{ 

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Filtering for '$Name'."

				$_interconnects.members = $_interconnects.members | ? name -match $name

				$_interconnects.count = $_interconnects.members.count
			
				if($_interconnects.count -eq 0) 
				{ 
			       
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Interconnect '$name' was not found. Adding appliance to notfound collection."       
					
					[Void]$NotFound.Add($_appliance.Name)
			        
				}

			}
			
			if ($_interconnects.members) 
			{

				$_interconnects.members | % { 
					
					$_.PSObject.TypeNames.Insert(0,”HPOneView.Networking.Interconnect") 
				
				} 

				$_interconnects.members.ports | ? { $_.portType -eq "Uplink" -or $_.portType -eq "Stacking" } | % { 
					
					$_.PSObject.TypeNames.Insert(0,”HPOneView.Networking.Interconnect.UplinkPort") 

					$_ | Add-Member -NotePropertyName ApplianceConnection -NotePropertyValue (@{Name = $_appliance.Name; ConnectionID = $_appliance.ConnectionID})
				
				} 
				
				$_interconnects.members.ports | ? { $_.portType -eq "Downlink" } | % { 
					
					$_.PSObject.TypeNames.Insert(0,”HPOneView.Networking.Interconnect.DownlinkPort") 

					$_ | Add-Member -NotePropertyName ApplianceConnection -NotePropertyValue (@{Name = $_appliance.Name; ConnectionID = $_appliance.ConnectionID})
				
				}

				$_interconnects.members | % { [void]$InterconnectCollection.Add($_) }
			    
			}

		}

    }

    end 
	{

		Write-Verbose "Done. $($InterconnectCollection.count) logical interconnect(s) found."

		if($Export)
		{ 
		        
		    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Exporting to: $($Export)"

		    $InterconnectCollection  | convertto-json -Depth 99 | Set-Content -Path $Export -force -encoding UTF8
		        
		}

		else
		{

			$InterconnectCollection

		}

		#Generate final error if name wasn't found on appliance(s)
        if ($NotFound.count -gt 0 -and $Name) 
		{

            $errorRecord = New-ErrorRecord HPOneView.InterconnectResourceException InterconnectNameResourceNotFound ObjectNotFound 'Name' -Message "No Interconnect resources with '$Name' name were found on appliance $($NotFound -join ", ")."
            $PSCmdlet.ThrowTerminatingError($errorRecord)

        }

    }
    
}

function Get-HPOVLogicalInterconnect 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "default")]
    Param 
	(

		[parameter (Position = 0, Mandatory = $false, ParameterSetName = "default")]
		[ValidateNotNullorEmpty()]
		[String]$Name = $null,
		
		[parameter(Position = 1, Mandatory = $false)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions},

		[parameter (Position = 1, Mandatory = $false, ParameterSetName = "default")]
		[alias("x", "ExportFile")]
		[ValidateScript({split-path $_ | Test-Path})]
		[String]$Export

    )

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$LiCollection = New-Object System.Collections.ArrayList
		$NotFound     = New-Object System.Collections.ArrayList
        
	}
	
	Process 
	{
		
		if ($Name)
		{

			$Name = $Name -replace ("[*]","%25") -replace ("[&]","%26")

		}
		

		ForEach ($_appliance in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_appliance.Name)' Appliance (of $($ApplianceConnection.Count))"		

			if ($Name) 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Logical Interconnect name provided: '$Name'"

				#Search Index to workaround a CRM LI filter bug
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Searching index for Logical Interconnect resource."

				# // Uncomment when CRM LI filter bug is fixed.
				#$uri = $logicalInterconnectsUri + "?filter=name='$name'"

				$uri = $script:indexUri + "?userQuery='$Name'&category=logical-interconnects&sort=name:asc"

			}

			else 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No Logical Interconnect name provided. Looking for all Logical Interconnect resources."
				
				$uri = $logicalInterconnectsUri

			}

			Try
			{

				$resp = Send-HPOVRequest $uri -Hostname $_appliance.Name

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}
				
			if ($resp.count -eq 0 -and $name) 
			{ 

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Logical Interconnect '$name' resource not found on '$($_appliance.Name)'. Adding to notfound collection."

				$errorRecord = New-ErrorRecord InvalidOperationException LogicalInterconnectGroupNotFound ObjectNotFound 'Name' -Message "Specified Logical Interconnect '$name' was not found.  Please check the name and try again."
				$pscmdlet.ThrowTerminatingError($errorRecord)  
            
				[Void]$NotFound.Add($_appliance.Name)

			}

			elseif ($resp.count -eq 0) 
			{ 

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No Logical Interconnect resources found on '$($_appliance.name)'."

			}

			else 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Found $($resp.count) Logical Interconnect resource(s)."

				ForEach ($_ligindexitem in $resp.members)
				{

					 "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting LI resource object for {0}." -f $_ligindexitem.name | Write-Verbose

					Try
					{

						$_liobject = Send-HPOVRequest $_ligindexitem.uri -Hostname $_appliance.Name

						$_liobject.PSobject.TypeNames.Insert(0,"HPOneView.Networking.LogicalInterconnect")  #FORMAT DONE
						$_liobject.snmpConfiguration | % { $_.PSObject.TypeNames.Insert(0,'HPOneView.Networking.LogicalInterconnect.SnmpConfiguration') } #FORMAT DONE
						$_liobject.snmpConfiguration.trapDestinations | % { $_.PSObject.TypeNames.Insert(0,'HPOneView.Networking.LogicalInterconnect.SnmpConfiguration.Destinations') } #FORMAT DONE
						$_liobject.ethernetSettings | % { $_.PSObject.TypeNames.Insert(0,'HPOneView.Networking.LogicalInterconnect.InterconnectSettings') }
						$_liobject.telemetryConfiguration | % { $_.PSObject.TypeNames.Insert(0,'HPOneView.Networking.LogicalInterconnect.UtilizationSampleSettings') }
						$_liobject.portMonitor | % { $_.PSObject.TypeNames.Insert(0,'HPOneView.Networking.LogicalInterconnect.PortMonitorSettings') }
					
						[void]$LiCollection.Add($_liobject) 

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

				}
 
			}

		}
   
    }

    End 
	{
		
		Write-Verbose "Done. $($lsws.count) logical interconnect group(s) found." 

		if ($Export)
		{
			
			$LiCollection | convertto-json -Depth 99 | Set-Content -Path $exportFile -force -encoding UTF8 
		
		}
        
        else 
		{

			 $LiCollection 
		
		}    
		
		#Generate final error if name wasn't found on appliance(s)
        if ($NotFound.count -gt 0 -and $Name) 
		{

            $errorRecord = New-ErrorRecord HPOneView.LogicalInterconnectResourceException LogicalInterconnectNameResourceNotFound ObjectNotFound 'Name' -Message "No Logical Interconnect with '$Name' name were found on appliance $($NotFound -join ", ")."
            $PSCmdlet.ThrowTerminatingError($errorRecord)

        }   

    }

}

function Update-HPOVLogicalInterconnect 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "default", SupportsShouldProcess = $True, ConfirmImpact = 'High')]
    Param 
	(

		[parameter(Position = 0, Mandatory = $false, ValueFromPipeline = $true, ParameterSetName = "default", HelpMessage = "Specify the Logical Interconnect to Update.")]
		[parameter(Position = 0, Mandatory = $false, ValueFromPipeline = $true, ParameterSetName = "Reapply", HelpMessage = "Specify the Logical Interconnect to Update.")]
		[ValidateNotNullorEmpty()]
		[Alias('uri', 'li','name')]
		[object]$Resource = $null,
		
		[parameter(Position = 1, Mandatory = $false)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions},

		[parameter(Mandatory = $true, ValueFromPipeline = $false, ParameterSetName = "Reapply", HelpMessage = "Reapply the Logical Interconnect configuration. Does not update from parent Logical Interconnect Group.")]
		[switch]$Reapply

    )

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

        $_returntasks = New-Object System.Collections.ArrayList
		$_liobjects   = New-Object System.Collections.ArrayList

    }

    Process 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing $($Resource.count) LI objects."

        foreach ($_li in $Resource) 
		{
            
            #Name provided
            if (($_li -is [String]) -and (-not($_li.StartsWith($script:logicalInterconnectsUri))))
			{

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] LI Name was provided '$($_li)'"

				#Loop through appliance connections to add LI objects to collection
				ForEach ($_appliance in $ApplianceConnection)
				{

					Try 
					{

						Get-HPOVLogicalInterconnect $_li -ApplianceConnection $_appliance.Name | % { [void]$_liobjects.Add($_) }

					}
						
					Catch
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $_.FullyQualifiedErrorId Error Caught:  $($_.Exception.Message)"

						$PSCmdlet.ThrowTerminatingError($_)

					}

				}

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Retrieved $($_liobjects.count) LI Objects"

            }

            elseif (($_li -is [String]) -and ($_li.StartsWith($script:logicalInterconnectsUri))) 
			{

				#User didn't provide an appliance connection during call
				if (-not($PSBoundParameters['ApplianceConnection']) -and $ApplianceConnection.Count -gt 1)
				{

					$errorRecord = New-ErrorRecord InvalidOperationException LogicalInterconnectUriNoApplianceConnection InvalidArgument 'ApplianceConnection' -Message "A Logical Interconnect URI was provided in the -Resource parameter, but no Appliance Connection specified.  URI's are unique per appliance connection.  Please specify an Appliance Connection and try your call again."
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}
				
				#User provided more than 1 appliance connection, and LI URI, generate error
				elseif ($ApplianceConnection.Count -gt 1)
				{

					$errorRecord = New-ErrorRecord InvalidOperationException LogicalInterconnectUriMultipleApplianceConnections InvalidArgument 'ApplianceConnection' -Message "A Logical Interconnect URI was provided in the -Resource parameter, with multiple Appliance Connections specified.  URI's are unique per appliance connection.  Please specify an Appliance Connection and try your call again."
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] LI URI was provided $($_li)"

				Try 
				{

					Send-HPOVRequest $_li -HostName $ApplianceConnection.Name | % { [void]$_liobjects.Add($_) }

				}
						
				Catch
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $_.FullyQualifiedErrorId Error Caught:  $($_.Exception.Message)"

					$PSCmdlet.ThrowTerminatingError($_)

				}

            }

            elseif (($_li -is [PSCustomObject]) -and ($_li.category -ieq 'logical-interconnects')) 
			{

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] LI Object was provided $($_li | out-string)"

				[void]$_liobjects.Add($_li)

            }

            else 
			{

                $errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'Resource' -TargetType $_li.GetType().Name -Message "An invalid Resource object was provided. $($_li.GetType()) $($_li.category) was provided.  Only type String or PSCustomObject, and 'logical-interconnects' object category are permitted."
				$PSCmdlet.ThrowTerminatingError($errorRecord)

            }

        }

    }

    End 
	{

		#Loop through liobject collection to perform action
		ForEach ($_liobject in $_liobjects)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Logical Interconnect: $($_liobject.name)"

			if ($PSboundParameters['Reapply'])
			{ 

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Reapply LI configuration requested."
                    
                if ($pscmdlet.ShouldProcess($_liobject.name,"Reapply Logical Interconnect configuration. WARNING: Depending on this action, there might be a brief outage."))
				{ 

                    Try
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request to reapply configuration"
                    
						$uri = $_liobject.uri + "/configuration"

						$task = Send-HPOVRequest $uri PUT -Hostname $_liobject.ApplianceConnection.Name

						[void]$_returntasks.Add($task)

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}
                        
                }

                elseif ($PSBoundParamters['WhatIf'])
				{
					
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User included -WhatIf."
				
				}

				else
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User cancelled."

				}
                
            }

            else 
			{
                
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Update '$($liDisplayName)' Logical Interconnect from parent $($parentLig.name)."

				Try
				{

					$_ligname = (Send-HPOVRequest $_liobject.logicalInterconnectGroupUri -HostName $_liobject.ApplianceConnection.Name).Name
				}
                
				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}
				    
                if ($pscmdlet.ShouldProcess($_liobject.name,"Update Logical Interconnect from Group '$_ligname'. WARNING: Depending on the Update, there might be a brief outage."))
				{    
                    
					Try
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request"

						$uri = $_liobject.uri + "/compliance"

						$task = Send-HPOVRequest $uri PUT -Hostname $_liobject.ApplianceConnection.Name

						[void]$_returntasks.Add($task)

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

                }

                elseif ($PSBoundParamters['WhatIf'])
				{
					
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User included -WhatIf."

					Write-Host "WhatIf: Update Logical Interconnect '$($_liobject.name)' from Parent Group '$_ligname'." -ForegroundColor Yellow
				
				}

				else
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User cancelled."

				}

            }

		}

        return $_returntasks

    }

}

function Show-HPOVLogicalInterconnectMacTable 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "default")]
    Param 
	(

        [parameter (Position = 0, Mandatory = $false, ValueFromPipeline = $false, ParameterSetName = "default")]
        [parameter (Position = 0, Mandatory = $false, ValueFromPipeline = $false, ParameterSetName = "MACAddress")]
		[parameter (Mandatory, ValueFromPipeline, ParameterSetName = "Pipeline")]
		[ValidateNotNullorEmpty()]
        [alias("name","li")]
        [object]$LogicalInterconnect = $null,

        [parameter (Position = 1, Mandatory = $false, ValueFromPipeline = $false, ParameterSetName = "default")]
		[parameter (Mandatory = $false, ValueFromPipeline = $false, ParameterSetName = "Pipeline")]
		[ValidateNotNullorEmpty()]
        [string]$network = $null,

        [parameter (Position = 1, Mandatory = $false, ValueFromPipeline = $false, ParameterSetName = "MACAddress")]
        [validatescript({if ($_ -match $script:macAddressPattern) {$true} else { throw "The input value '$_' does not match 'aa:bb:cc:dd:ee:ff'. Please correct the value and try again."}})]
        [alias("mac")]
        [string]$MacAddress = $null,

        [parameter (Position = 2, Mandatory = $false, ParameterSetName = "default")]
        [parameter (Position = 2, Mandatory = $false, ParameterSetName = "MACAddress")]
		[parameter (Mandatory = $false, ParameterSetName = "Pipeline")]
        [alias("x", "ExportFile")]
        [ValidateScript({split-path $_ | Test-Path})]
        [String]$Export,
		
		[parameter(Mandatory = $false)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

    )

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		if ($PSCmdlet.ParameterSetName -ne 'Pipeline')
		{

			if ($ApplianceConnection.Count -eq 0)
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoAuthSession ObjectNotFound 'Hostname' -Message "No appliance Hostname parameter provided and no valid appliance session(s) found.  Please use Connect-HPOVMgmt to establish an appliance connection."
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			ForEach ($_Connection in $ApplianceConnection) 
			{

				Try 
				{
				
					$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

				}

				Catch [HPOneview.Appliance.AuthSessionException] 
				{

					$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				Catch 
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

				$c++

			}

		}

        $MacTables = New-Object System.Collections.ArrayList

    }

    Process 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Logical Interconnect via PipeLine: $PipelineInput"

        if (-not($LogicalInterconnect))
		{

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No Logical Interconnects provided via parameter. Getting all LI resources."

			Try
			{

				$LogicalInterconnect = Get-HPOVLogicalInterconnect

			}
            
			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

        }

        ForEach ($li in $LogicalInterconnect) 
		{

            if ($li -is [PSCustomObject] -and $li.category -eq "logical-interconnects") 
			{

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Logical Interconnect object provided: $($li.name)"

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Logical Interconnect object URI: $($li.uri)"

                $uri = $li.uri +"/forwarding-information-base"

            }

            else 
			{

                #Unsupported type
                $errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'LogicalInterconnect' -TargetType $li.GetType().Name -Message "The parameter -LogicalInterconnect contains an invalid parameter value type, '$($li.gettype().fullname)' is not supported.  Only [PSCustomObject] type is allowed."
                $PSCmdlet.WriteError($errorRecord)

            }

            #Filter the request for a specific Network
            if ($Network) 
			{
                
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Filtering for '$Network' Network Resource"
                
                $_Network = Get-HPOVNetwork $network -ApplianceConnection $li.ApplianceConnection.Name

				$_internalVlanId = $_Nework.internalVlanId

                $uri += "?filter=internalVlan=$_internalVlanId"

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing $uri"

				Try
				{

					$resp = (Send-HPOVRequest $uri -Hostname $li.ApplianceConnection.Name).members

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}
                

            }

            elseif ($MacAddress) 
			{

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Filtering for MAC Address '$MacAddress'"

                $uri += "?filter=macAddress='$MacAddress'"

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing $uri"

                Try
				{

					$resp = (Send-HPOVRequest $uri -Hostname $li.ApplianceConnection.Name).members

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}
                

            }

            else 
			{

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Generating '$uri' mactable file."

                Try
				{

					$macTableFile = (Send-HPOVRequest $uri -Hostname $li.ApplianceConnection.Name).members

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}
                

                if ("Success","Completed" -match $macTableFile.state) 
				{

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($macTableFile.uri)' mactable file."

                    $resp = Download-MacTable $macTableFile.uri
                
					#Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] MAC Table entries: $($resp | Out-String)"

                }

                else 
				{

                    $errorRecord = New-ErrorRecord HPOneView.NetworkResourceException InvalidInterconnectFibDataInfo InvalidResult 'Show-HPOVLogicalInterconnectMacTable' -Message ($macTableFile.state + ": " + $macTableFile.status)
                    $PSCmdlet.ThrowTerminatingError($errorRecord)

                }


            }

			$resp | % {

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding $($_.address) to collection"

				[void]$MacTables.Add($_)

			} 

        }

    }

    End 
	{

        if ($list) 
		{
            
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Displaying formatted table."

            if ($name -or $MacAddress) 
			{

                $m = @{Expression={($_.interconnectName -split ",")[0]};Label="Enclosure"},
                     @{Expression={($_.interconnectName -split ",")[1]};Label="Interconnect"},		         
                     @{Expression={$_.networkInterface};Label="Interface"},
                     @{Expression={$_.macAddress};Label="Address"},
                     @{Expression={$_.entryType};Label="Type"},
                     @{Expression={$_.networkName};Label="Network"},
                     @{Expression={$_.externalVlan};Label="VLAN"}

            }

            else 
			{

                $m = @{Expression={$_.Enclosure};Label="Enclosure"},
                     @{Expression={$_.Interconnect};Label="Interconnect"},
                     @{Expression={$_.Interface};Label="Interface"},
                     @{Expression={$_.address};Label="Address"},
                     @{Expression={$_.type};Label="Type"},
                     @{Expression={$_.network};Label="Network"},
                     @{Expression={$_.extVlan};Label="VLAN"},
                     @{Expression={$_.LAGPorts};Label="LAG Ports"}

            }

            $MacTables | sort "Enclosure","Interconnect",macAddress | format-table $m -autosize

        }

        elseif ($PSBoundParameters['Export']) 
		{

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Exporting to CSV file: $Export"

            $MacTables | sort Enclosure,Interconnect,macAddress | Export-CSV $Export -NoTypeInformation

        }
        else 
		{

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Displaying results."

            $MacTables | sort Enclosure,Interconnect,macAddress

        }
        
        "[$($MyInvocation.InvocationName.ToString().ToUpper())] Done. {0} mac table entry(ies) found." -f $MacTables.Count | write-verbose

    }

}

function Download-MacTable 
{
    
<#
    .SYNOPSIS
    Download Logical Interconnect MAC Table CSV.

    .DESCRIPTION
    This internal helper function will download the MAC Table CSV from a provided Logical Interconnect, parse it and return an array of MAC Table entries.

    .PARAMETER Uri
    [System.String] URI of Logical Interconnect.

	.PARAMETER Hostname
	[System.String] Hostname of Appliance

    .INPUTS
    None.

    .OUTPUTS
    System.Array
    Array of MAC Table entries.

    .LINK
    Get-HPOVLogicalInterconnect

    .EXAMPLE
    PS C:\> $encl1li = Get-HPOVLogicalInterconnect Encl1-LI
    PS C:\> Download-MACTable $encl1li.uri

    Get the Logical Interconnect 'Encl1-LI' and 
            
#>

    [CmdLetBinding()]
    Param 
	(

        [parameter(Position = 0, Mandatory, HelpMessage = "Specify the URI of the object to download.")]
        [ValidateNotNullOrEmpty()]
        [ValidateScript({if ($_.startswith('/rest/logical-interconnects/')) { $true } else {throw "-URI must being with a '/rest/logical-interconnects/' in its value. Please correct the value and try again."}})]
        [string]$uri,
        
		[parameter(Position = 1, Mandatory, HelpMessage = "Appliance Hostname")]
        [ValidateNotNullOrEmpty()]
		[string]$Hostname

    ) 

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

        $enc = [System.Text.Encoding]::UTF8

    }
 
    Process
	{	

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Download URI: $($uri)"

	    [System.Net.httpWebRequest]$fileDownload = RestClient GET $uri $Hostname

	    $fileDownload.accept = "application/zip,application/octet-stream,*/*"

        $i = 0
        foreach ($h in $fileDownload.Headers) 
		{ 
			
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Request Header $($i): $($h) = $($fileDownload.Headers[$i])"
			
			$i++
		
		}
		    
        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Request: GET $($fileDownload.RequestUri.AbsolutePath | out-string)"
        
        #Get response
        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting response"
        [Net.httpWebResponse]$rs = $fileDownload.GetResponse()

        #Display the response status if verbose output is requested
        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Response Status: $([int]$rs.StatusCode) $($rs.StatusDescription)"

        $i = 0
        foreach ($h in $rs.Headers) 
		{ 
			
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Response Header $($i): $($h) = $($rs.Headers[$i])"
			
			$i++ 
		
		}

        #Request is a redirect to download file contained in the response headers
        $fileName = ($rs.headers["Content-Disposition"].Substring(21)) -replace "`"",""

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Filename: $($fileName)"

	    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Filesize:  $($rs.ContentLength)"

        $responseStream = $rs.GetResponseStream()

        #Define buffer and buffer size
		[int] $bufferSize = ($rs.ContentLength*1024)
	    [byte[]]$Buffer   = New-Object byte[] ($rs.ContentLength*1024)
        [int] $bytesRead  = 0

		#This is used to keep track of the file upload progress.
	    $totalBytesToRead = $rs.ContentLength
	    $numBytesRead     = 0
		$numBytesWrote    = 0

		#Read from stream
        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Reading HttpWebRequest file stream."
        $responseStream.Read($Buffer, 0, $bufferSize) | out-Null
        
        #Write to output stream
        $outStream = new-object System.IO.MemoryStream (,$Buffer)

	    #Clean up our work
	    $responseStream.Close()
	    $rs.Close()
	    
        $source = $outStream.ToArray()
        
        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Decompressing HttpWebRequest file."
        $sr = New-Object System.IO.Compression.GZipStream($outStream,[System.IO.Compression.CompressionMode]::Decompress)
        
        #Reset variable to collect uncompressed result
        $byteArray = New-Object byte[]($source.Length+1024)
        
        #Decompress
        [int]$rByte = $sr.Read($byteArray, 0, $source.Length)

		#Transform byte[] unzip data to string
        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Converting Byte array to String Characters."
        $sB = New-Object System.Text.StringBuilder($rByte)
        
        #Read the number of bytes GZipStream read and do not a for each bytes in resultByteArray
        for ([int] $i = 0; $i -lt $rByte; $i++) 
		{

            $sB.Append([char]$byteArray[$i]) | Out-Null

        }
        
        $sr.Close()
        $sr.Dispose()

    }

    end 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Building string array in CSV format"

        $macTableArray = $sb.ToString() -split "`n"
        $header        = "enclosure","interconnect","interface","address","type","network","extVLAN","intVLAN","serverProfile","uplinkSet","LAGPort1","LAGPort2","LAGPort3","LAGPort4","LAG Port5","LAG Port6","LAG Port7","LAG Port8"
        $macTableArray = $macTableArray[1..($macTableArray.count)]

        $e = @{Expression={
             
                 $lagport = $_
                 1..8 | % { if ($lagport."LAGPort$($_)") { $lagport."LAGPort$($_)" } } 
                           
             };name="LAGPorts"}

        $macTable = $macTableArray | ConvertFrom-Csv -Header $header | select "enclosure","interconnect","interface","address","type","network","extVLAN","intVLAN","serverProfile","uplinkSet",$e

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Returning results."

        Return $macTable

    }

}

function Install-HPOVLogicalInterconnectFirmware 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "default",SupportsShouldProcess = $True,ConfirmImpact = 'High')]
    Param 
	(
        
        [parameter(Position = 0, Mandatory, ValueFromPipeline, ParameterSetName = "default", HelpMessage = "Specify the Logical Interconnect to Update.")]
        [Alias('name','uri', 'li')]
		[ValidateNotNullorEmpty()]
        [object]$LogicalInterconnect,

        [parameter(Position = 1, Mandatory = $false, ValueFromPipeline = $false, ParameterSetName = "default", HelpMessage = "Specify the Logical Interconnect udpate method: Update, Activate, Stage.")]
        [ValidateSet('Update','Activate','Stage')]
        [string]$Method = "Update",

        [parameter(Position = 2, Mandatory = $false, ValueFromPipeline = $false, ParameterSetName = "default", HelpMessage = "Specify the Logical Interconnect to Update.")]
        [ValidateSet('OddEven','Parallel','Serial')]
        [Alias('Order','ActivateOrder')]
        [string]$EthernetActivateOrder = 'OddEven',

		[parameter(Position = 3, Mandatory = $false, ValueFromPipeline = $false, ParameterSetName = "default", HelpMessage = "Delay in minutes")]
        [ValidateNotNullorEmpty()]
        [int]$EthernetActivateDelay = 5,

		[parameter(Position = 4, Mandatory = $false, ValueFromPipeline = $false, ParameterSetName = "default", HelpMessage = "Specify the Logical Interconnect to Update.")]
        [ValidateSet('OddEven','Parallel','Serial')]
        [String]$FCActivateOrder = 'Serial',

		[parameter(Position = 5, Mandatory = $false, ValueFromPipeline = $false, ParameterSetName = "default", HelpMessage = "Delay in minutes")]
        [ValidateNotNullorEmpty()]
        [int]$FCActivateDelay = 5,

        [parameter(Mandatory, ValueFromPipeline = $false, ParameterSetName = "default", HelpMessage = "Specify the SPP Baseline Object or Name.")]
        [Alias('spp')]
        [object]$Baseline,

		[parameter(Mandatory = $false)]
		[switch]$Async,

        [parameter(Mandatory = $false, ValueFromPipeline = $false, ParameterSetName = "default", HelpMessage = "Force install firmware version from SPP Baseline; will downgrade or re-install.")]
        [switch]$Force,

		[parameter(Mandatory = $false, ValueFromPipelineByPropertyName, HelpMessage = "Enter the Appliance Name or Object")]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Object]$ApplianceConnection

    )

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$TaskCollection = New-Object System.Collections.ArrayList

        if (-not($LogicalInterconnect))
		{

			$PipelineInput = $True

		}
        
    }

    Process 
	{

		if ($PipelineInput -or $LogicalInterconnect -is [PSCustomObject])
		{

			#Validate Logical Interconnect Object Type
			if (-not($LogicalInterconnect -is [PSCustomObject]) -and $LogicalInterconnect.category -ne 'local-interconnects') 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] invalid LogicalInterconnect passed:  $($LogicalInterconnect)"

				$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'INSTALL-HPOVLOGICALINTERCONNECTFIRMWARE' -Message "The 'LogicalInterconnect' parameter value '$($LogicalInterconnect)' is invalid.  Please check the parameter value and try again."
				$PSCmdlet.ThrowTerminatingError($errorRecord)
        
			}

		}

		else
		{

			if ($ApplianceConnection -eq $null)
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message 'No Appliance Connection was provided.  Please provide a valid ApplianceConnection Object.'
				$PSCmdlet.ThrowTerminatingError($errorRecord)
			
			}

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Looking for Logical Interconnect '$LogicalInterconnect' from Get-HPOVLogicalInterconnect."

			Try
			{
				
				$LogicalInterconnect = Get-HPOVLogicalInterconnect $LogicalInterconnect -ApplianceConnection $ApplianceConnection

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Validating Baseline input value."

		switch ($Baseline.GetType().Name)
		{

			'String'
			{

				Try
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Firmware Baseline name passed:  $($Baseline)"
						
					$Baseline = Get-HPOVSppFile -Name $Baseline -ApplianceConnection $LogicalInterconnect.ApplianceConnection.Name

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

			}

			'PSCustomObject'
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Firmware Baseline object passed:  $($Baseline | FL * | Out-String)"

				if ($Baseline.category -ne 'firmware-drivers')
				{
					
					$errorRecord = New-ErrorRecord HPOneView.BaselineResourceException InvalidBaselineObject InvalidArgument 'Baseline' -TargetType 'PSObject' -Message "The Baseline provided in an invalid object.  Baseline category value '$($Basline.caetegory)', expected 'firmware-drivers'.  Please check the parameter value and try again."
			        $PSCmdlet.ThrowTerminatingError($errorRecord)
					
				}

			}

		}

        $Staging    = $False
        $Activating = $False

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($LogicalInterconnect.name)' Logical Interconnect."

		$_Request = NewObject -LogicalInterconnectBaseline

		$_Request.command                 = $Method
		$_Request.ethernetActivationType  = [String]$EthernetActivateOrder
		$_Request.ethernetActivationDelay = [int]$EthernetActivateDelay
		$_Request.fcActivationType        = [String]$FCActivateOrder
		$_Request.fcActivationDelay       = [int]$FCActivateDelay
		$_Request.sppUri                  = $Baseline.uri
		$_Request.force                   = [bool]$PSBoundParameters['Force']

        switch ($Method) 
		{

            {'Update', 'Stage' -match $_}
			{ 

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] '$Method' Method called."        
                
				$_Request.command = $Method
				
                
            }

            "Activate" 
			{

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] 'Activate' Method called."
                
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verifying '$(LogicalInterconnect.name)' LI is in a Staged state."
                
				Try
				{

					$_FirmwareStatus = Send-HPOVRequest ($LogicalInterconnect.uri + "/firmware") -Hostname $LogicalInterconnect.ApplianceConnection.Name

				}

				Catch
				{

					$PScmdlet.ThrowTerminatingError($_)

				}

                #Validate interconnect firmware update state
                switch ($_FirmwareStatus.state) 
				{
                     
                    'STAGED' 
					{ 
                        
                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] '$($LogicalInterconnect.name)' LI is in the proper '$($_FirmwareStatus.state)' state."

                        #$baselineObj = [pscustomobject] @{ uri = $_FirmwareStatus.sppUri }

						$_Request.command = 'ACTIVATE'
						$_Request.sppUri  = $_FirmwareStatus.sppUri

                    }
                        
                    'STAGING'
					 { 
                        
                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] '$($LogicalInterconnect.name)' is currently being staged with firmware. Please wait until the task completes."
                            
                        #Locate and return running task.
                        $_task = Get-HPOVTask -State Running -resource $LogicalInterconnect.name -ApplianceConnection $LogicalInterconnect.ApplianceConnection.Name

						$_task | ? { $_.taskStatus.StartsWith('Staging') } | % {

							[void]$TaskCollection.Add($_)

						}

                        # Flag to skip the command processing IF block below
                        $Staging = $true
                            
                    }

                    'STAGING_FAILED' 
					{ 
                        
                        $errorRecord = New-ErrorRecord InvalidOperationException InvalidLogicalInterconnectState InvalidResult 'LogicalInterconnect' -Message "The $($LogicalInterconnect.name) Logical Interconnect is in an invalid state ($($_FirmwareStatus.state))in order to issue the Activate command."
                        $PSCmdlet.ThrowTerminatingError($errorRecord)
                        
                    }

                    'ACTIVATED' 
					{ 
						
						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] '$($LogicalInterconnect.name)' is already activated."
						
						Write-Warning "'$($LogicalInterconnect.name)' is already activated."
						
						Return 
					
					}

                    'ACTIVATING' 
					{
                            
                        #Logical Interconnect is already processing the Activate command.
                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] '$($LogicalInterconnect.name)' is already activating. Returning task resource."

                        # Flag to skip the command processing IF block below
                        $activating = $True
                            
                        #Locate and return running task.
                        $_task = Get-HPOVTask -State Running -resource $LogicalInterconnect.name -ApplianceConnection $LogicalInterconnect.ApplianceConnection.Name

						$_task | ? { $_.taskStatus.StartsWith('Activating') } | % {

							[void]$TaskCollection.Add($_)

						}

                    }

                    'ACTIVATION_FAILED' 
					{ 
                        
                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] '$($LogicalInterconnect.name)' failed a prior activation request.  LI is in a valid state to attempt Activation command."

                        #$baselineObj = [pscustomobject] @{ uri = $_FirmwareStatus.sppUri }

						$_Request.command = 'ACTIVATE'
						$_Request.sppUri  = $_FirmwareStatus.sppUri
                            
                    }

                    'PARTIALLY_ACTIVATED' 
					{ 
                        
                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] '$($LogicalInterconnect.name)' is Partially Activated.  LI is in a valid state to attempt Activation command."
                        $baselineObj = [pscustomobject] @{ uri = $_FirmwareStatus.sppUri }
                        
                    }

                    'PARTIALLY_STAGED' 
					{
                        
                        $errorRecord = New-ErrorRecord InvalidOperationException InvalidLogicalInterconnectState InvalidResult 'LogicalInterconnect' -Message "The $($LogicalInterconnect.name) Logical Interconnect is in an invalid state ($($_FirmwareStatus.state)) in order to issue the Activate command."
                        $PSCmdlet.ThrowTerminatingError($errorRecord)
                        
                    }

                    'UNINITIALIZED' 
					{ 
                        
                        <# Generate Error that firmware has not been staged #> 
                        $errorRecord = New-ErrorRecord InvalidOperationException NoStagedFirmwareFound ObjectNotFound 'LogicalInterconnect' -Message "No staged firmware found for '$($LogicalInterconnect.name)' Logical Interconnect.  Use Install-HPOVLogicalInterconnectFirmware -method Stage to first stage the firmware before attempting to Activate."
                        $PSCmdlet.ThrowTerminatingError($errorRecord)
                            
                    }

                }
                
            }

        }

        #Need to prompt user to update or activate firmware, which could cause an outage.
        if (('Update', 'Stage' -match $Method) -and (-not($Activating)) -and (-not($Staging)))
		{

			Write-Warning 'Module activation may cause a network outage if Activation Order is Parallel.'

            if ($pscmdlet.ShouldProcess($LogicalInterconnect.name,'update and activate Interconnect modules')) 
			{

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User was prompted warning and accepted. Sending request."

                Try
				{

					$_taskResults = Send-HPOVRequest -method PUT -uri ($LogicalInterconnect.uri + "/firmware") -body $_Request -Hostname $LogicalInterconnect.ApplianceConnection.Name

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}
					
            }

            else 
			{ 
				
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User was prompted and selected No, cancelling the update for $($LogicalInterconnect.name)" 
			
			}

        }

        #User is staging firmware, no need to prompt.
        elseif (-not($Activating) -and (-not($Staging)))
		{

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Beginning to stage firmware to '$($LogicalInterconnect.name)'."
                
            $_taskResults = Send-HPOVRequest -method PUT -uri ($li.uri + "/firmware") -body $_Request -Hostname $LogicalInterconnect.ApplianceConnection.Name

        }


		if (-not($PSBoundParameters['Async']))
		{

			Try
			{

				$_taskResults = Wait-HPOVTaskComplete $_taskResults -ApplianceConnection $_taskResults.ApplianceConnection.Name

			}

			Catch
			{

				$PScmdlet.ThrowTerminatingError($_)

			}

		}

		[void]$TaskCollection.Add($_taskResults)

    }

    end 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Finished, returning results."

        return $TaskCollection

    }


}

function Show-HPOVPortStatistics 
{

    [CmdLetBinding(DefaultParameterSetName = "InterconnectPort")]
    Param 
	(

		[Parameter(Position = 0, Mandatory = $true, ValueFromPipeline = $true, ParameterSetName = "Pipeline")]
		[Parameter(Position = 1, Mandatory = $false, ParameterSetName = "InterconnectPort")]
        [object]$Port = $null,

        [Parameter(Position = 0, Mandatory = $true, ParameterSetName = "InterconnectPort")]
        [object]$Interconnect = $null,

		[parameter(Mandatory = $true, ValueFromPipelineByPropertyName)]
		[Alias('Appliance')]
		[Object]$ApplianceConnection

    )

	Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSBoundParameters['ApplianceConnection']))
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server object provided by pipeline."

			$PipelineInput = $True

		}

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if (-not($ApplianceConnection -is [HPOneView.Appliance.Connection]) -and (-not($ApplianceConnection -is [System.String])) -and (-not($PipelineInput)))
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException InvalidApplianceConnectionDataType InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter is not type [HPOneView.Appliance.Connection] or [System.String].  Please correct this value and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif (($ApplianceConnection | Measure-Object).Count -gt 1 -and (-not($PipelineInput)))
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException MultipleApplianceConnections InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter contains multiple Appliance Connections.  This CMDLET only supports 1 Appliance Connection in the ApplianceConnect parameter value.  Please correct this and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif (-not($PipelineInput))
		{

			Try 
			{
	
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError 'ApplianceConnection' -TargetType $ApplianceConnection.GetType().Name -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_.Exception)

			}

		}

		$_PortStatsCol = New-Object System.Collections.ArrayList
    
	}

    Process 
	{

        Switch ($PSCmdLet.ParameterSetName) 
		{

            "Pipeline" 
			{

				switch ($Port.GetType().Name)
				{

					#Do not support String Port values via pipeline, so generate error
					"String" 
					{

						$errorRecord = New-ErrorRecord HPOneView.InterconnectPortResourceException InvalidInterconnectPortParameter InvalidArgument 'Port' -Message "The -Port parameter only supports Objects via the pipeline.  Please refer to the CMDLET help for proper pipeline syntax."

						$pscmdlet.ThrowTerminatingError($errorRecord)  
						
					}

					"PSCustomObject" 
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Port Object provided: $($Port | Out-String)"

						#Validate the Port Object is type Port
						if ($Port.category -ne "ports") 
						{

							$errorRecord = New-ErrorRecord HPOneView.InterconnectPortResourceException InvalidInterconnectPortObject InvalidArgument 'Port' -TargetType "PSObject" -Message ("The object for the -Port parameter is the wrong type: {0}.  Expected category 'ports'.  Please check the object provided and try again." -f $Port.category )
							$pscmdlet.ThrowTerminatingError($errorRecord)  

						}

						Try
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Interconnect resource from Port Object."

							$_InterconnectUri = $Port.uri.Substring(0,$Port.uri.IndexOf('/ports/' + $Port.portId))

							$Interconnect = Send-HPOVRequest $_InterconnectUri -ApplianceConnection $Port.ApplianceConnection.Name

						}

						Catch
						{

							$PSCmdlet.ThrowTerminatingError($_)

						}

					}

				}

			}

			"InterconnectPort" 
			{ 

				switch ($Interconnect.GetType().Name)
				{

					"String" 
					{


						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Interconnect object '$Interconnect'"

						Try
						{

							$Interconnect = Get-HPOVInterconnect $Interconnect -ApplianceConnection $ApplianceConnection

						}

						Catch
						{

							$PSCmdlet.ThrowTerminatingError($_)

						}

					}

					"PSCustomObject" 
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Interconnect Object provided: $($Interconnect | Out-String)"

						#Validate the Port Object is type Port
						if ($Interconnect.category -ne 'interconnects') 
						{

							$errorRecord = New-ErrorRecord HPOneView.InterconnectPortResourceException InvalidInterconnectPortObject InvalidArgument 'Interconnect' -TargetType "PSObject" -Message ("The object for -Interconnect parameter is the wrong resource category: {0}.  Expected type 'interconnects'.  Please check the object provided and try again." -f  $Interconnect.category)

							$pscmdlet.ThrowTerminatingError($errorRecord)  

						}

					}

				}

				if ($PSBoundParameters['Port'])
				{

					if ($Port -is [String])
					{

						"[$($MyInvocation.InvocationName.ToString().ToUpper())] Filtering for '{0}' within '{1}' Interconnect." -f $Port, $Interconnect.name | Write-Verbose 

						$_originalport = $Port

						$Port = $Interconnect.ports | ? portName -like $Port

						if (-not($Port)) 
						{

							$errorRecord = New-ErrorRecord HPOneView.InterconnectPortResourceException InvalidInterconnectPort InvalidArgument 'Port' -Message ("The the port '{0}' was not found within '{1}'.  Available ports within the interconnect are '{2}' Please check the port value and try again." -f $_originalport, $Interconnect.name, ($interconnect.ports.portName -join ",") )

							$pscmdlet.ThrowTerminatingError($errorRecord)  

						}

					}

					elseif ($Port -is [PSCustomObject])
					{

						$_originalport = $Port.PSObject.Copy()

						"[$($MyInvocation.InvocationName.ToString().ToUpper())] Filtering for '{0}' within '{1}' Interconnect." -f $Port.name, $Interconnect.name | Write-Verbose 

						$Port = $Interconnect.ports | ? portName -like $Port.name

						if (-not($Port)) 
						{

							$errorRecord = New-ErrorRecord HPOneView.InterconnectPortResourceException InvalidInterconnectPort InvalidArgument 'Port' -TargetType 'PSObject' -Message ("The the port '{0}' was not found within '{1}'.  Available ports within the interconnect are '{2}' Please check the port value and try again." -f $_originalport.name, $Interconnect.name, ($interconnect.ports.portName -join ",") )

							$pscmdlet.ThrowTerminatingError($errorRecord)  

						}

					}

				}

			}

        }

		Try
		{

			$_InterconnectStats = Send-HPOVRequest ($Interconnect.uri + "/statistics") -ApplianceConnection $ApplianceConnection.Name

		}

		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}
		
		$_InterconnectStats | % { $_.PSObject.TypeNames.Insert(0,”HPOneView.Networking.InterconnectStatistics") }

		if ($Port) 
		{ 
			
			$_InterconnectStats.portStatistics = $_InterconnectStats.portStatistics | ? { $port.portName -contains $_.portName } 
		
		}

		#Set the specific TypeNames value for Formats to handle
		foreach ($_PortObj in $Interconnect.ports) 
		{

			switch ($_PortObj.configPortTypes) 
			{

				{@("EnetFcoe","Ethernet") -match $_ } 
				{

					$TypeName    = "HPOneView.Networking.PortStatistics.Ethernet"
					$SubTypeName = "Ethernet"
					Break

				}

				"FibreChannel" 
				{

					$TypeName    = "HPOneView.Networking.PortStatistics.FibreChannel"
        			$SubTypeName = "FibreChannel"
					Break

				}

			}

			"[$($MyInvocation.InvocationName.ToString().ToUpper())] inserting '{0}' into '{1}' [{2}]" -f $TypeName, $_PortObj.name, ($_PortObj.configPortTypes -join ",") | Write-Verbose 

			($_InterconnectStats.portStatistics | ? portName -eq $_PortObj.portName ).PSObject.TypeNames.Insert(0,$TypeName)
			($_InterconnectStats.portStatistics | ? portName -eq $_PortObj.portName ) | Add-Member -NotePropertyName portConfigType -NotePropertyValue $SubTypeName -force
		}

		#Insert sampleInterval from the Interconnect itself. Otherwise, portStatistics doesn't contain the interval.
		$_InterconnectStats.portStatistics | % { Add-Member -InputObject $_ -NotePropertyName sampleInterval -NotePropertyValue $_InterconnectStats.moduleStatistics.portTelemetryPeriod -force }

		$_InterconnectStats.portStatistics | sort-Object portConfigType,portName | % {

			[void]$_PortStatsCol.Add($_)

		}

	}

	End 
	{

		Return $_PortStatsCol

	}

} 

function Get-HPOVLogicalInterconnectGroup 
{

	# .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdLetBinding(DefaultParameterSetName = 'Default')]
	Param 
	(

		[parameter(ValueFromPipeline, Mandatory, ParameterSetName = 'Pipeline')]
		[Object]$Resource,

		[parameter (Position = 0, Mandatory = $false, ParameterSetName = 'Default')]
		[ValidateNotNullorEmpty()]
		[String]$Name = $null,

		[parameter(Mandatory = $false, ValueFromPipelineByPropertyName, ParameterSetName = 'Pipeline')]
		[parameter (Mandatory = $false, ParameterSetName = 'Default')]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions},

		[parameter (Mandatory = $false, ParameterSetName = 'Default')]
		[alias("x", "export")]
		[ValidateScript({split-path $_ | Test-Path})]
		[String]$exportFile

	)

	Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if ($PSCmdlet.ParameterSetName -eq 'Pipeline')
		{

			$PipelineInput = $True

		}

		Else
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
			$c = 0
		
			ForEach ($_connection in $ApplianceConnection) 
			{

				Try 
				{
			
					$ApplianceConnection[$c] = Test-HPOVAuth $_connection

				}

				Catch [HPOneview.Appliance.AuthSessionException] 
				{

					$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_connection -Message $_.Exception.Message -InnerException $_.Exception
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				Catch 
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

				$c++

			}

		}
		
		$LigCollection = New-Object System.Collections.ArrayList
        
	}
	
	Process 
	{

		if ($PipelineInput)
		{

			#Task Resource Object
			if ($Resource -is [PSCustomObject] -and $Resource.category -eq 'tasks')
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Task Resource input object."

				if ($Resource.taskState -eq 'Completed')
				{

					Try
					{

						$_LigObject = Send-HPOVRequest $Resource.associatedResource.resourceUri -Hostname $Resource.ApplianceConnection.Name

						$_LigObject | % { 
				
							$_.PSObject.TypeNames.Insert(0,'HPOneView.Networking.LogicalInterconnectGroup')	

							[void]$LigCollection.Add($_ ) 
				
						}

					}

					Catch
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] API Error Caught: $($_.Exception.Message)"

						$PSCmdlet.ThrowTerminatingError($_)

					}

				}

				#Generate error
				else
				{

					$Resource

					$errorRecord = New-ErrorRecord HPOneView.LogicalInterconnectGroupResourceException TaskFailure InvalidOperation 'Resource' -Message "The Task object provided by the pipeline did not complete successfully.  Please validate the task object resource and try again."
					$pscmdlet.ThrowTerminatingError($errorRecord)  

				}

			}

			else
			{

				$errorRecord = New-ErrorRecord HPOneView.LogicalInterconnectGroupResourceException LogicalInterconnectGroupNotFound ObjectNotFound 'Resource' -Message "The Logical Interconnect Group associated with the pipeline input task object was not found on '$($Resource.ApplianceConnection.Name)'.  Please check the value and try again."
				$pscmdlet.ThrowTerminatingError($errorRecord)  

			}

		}

		Else
		{

			ForEach ($_connection in $ApplianceConnection)
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_connection.Name)' Appliance (of $($ApplianceConnection.Count))"

				if ($PSboundParameters['name']) 
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Logical Interconnect Group name provided: '$name'"

					$name = $name -replace ("[*]","%25") -replace ("[&]","%26")

					$uri = $LogicalInterconnectGroupsUri + "?filter=name matches '$name'"

				}

				else 
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No Logical Interconnect Group name provided. Looking for all Logical Interconnect Group resources."

					$uri = $LogicalInterconnectGroupsUri

				}

				Try
				{

					$ligs = Send-HPOVRequest $uri -Hostname $_connection.Name

				}

				Catch
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] API Error Caught: $($_.Exception.Message)"

					$PSCmdlet.ThrowTerminatingError($_)

				}
			

				if ($ligs.count -eq 0 -and $name) 
				{ 

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Logical Interconnect Group '$name' resource not found. Generating error"

					$errorRecord = New-ErrorRecord InvalidOperationException LogicalInterconnectGroupNotFound ObjectNotFound 'Name' -Message "Specified Logical Interconnect Group '$name' was not found on '$($_connection.Name)'.  Please check the name and try again."
					$pscmdlet.ThrowTerminatingError($errorRecord)  
			    
				}

				elseif ($ligs.count -eq 0) 
				{ 

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No Logical Interconnect Group resources found on '$($_connection.Name)'."

				}

				else 
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Found $($ligs.count) Logical Interconnect Group resource(s)."
			    
					# // Todo Update ConvertTo-Object with LIG
					$ligs.members | % { 
				
						$_.PSObject.TypeNames.Insert(0,'HPOneView.Networking.LogicalInterconnectGroup')	

						[void]$LigCollection.Add($_ ) 
				
					}
 
				}

			}

		}

    }

    end 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Done. $($LigCollection.count) logical interconnect group(s) found."       

        if ($exportFile)
		{
			
			$LigCollection | convertto-json -Depth 99 | Set-Content -Path $exportFile -force -encoding UTF8 
		
		}
                
        else 
		{
			
			Return $LigCollection 
		
		}

    }

}

function New-HPOVLogicalInterconnectGroup 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding(DefaultParameterSetName = "Default")]
    param 
	(

        [Parameter(Mandatory = $True, ParameterSetName = "Default",HelpMessage = "Please specify the Logical Interconnect Name", Position = 0)]
        [ValidateNotNullOrEmpty()]
        [Alias('ligname')]
        [String]$Name,
        
        [Parameter(Mandatory = $True,ValueFromPipeline = $true, ParameterSetName = "Default",HelpMessage = "Please specify the Interconnect Modules in Hashtable format for all Interconnect Bays", Position = 1)]
        [Hashtable]$Bays,

        [Parameter(Mandatory = $False, ParameterSetName = "Default", HelpMessage = "Enable IGMP Snooping", Position = 2)]
		[Alias("IGMPSnoop")]
        [bool]$EnableIgmpSnooping = $False,
		
		[Parameter(Mandatory = $False, ParameterSetName = "Default",HelpMessage = "IGMP Idle Timeout Interval (1-3600 [sec])", Position = 3)]
        [ValidateRange(1,3600)]
		[Alias('IGMPIdle')]
	    [int]$IgmpIdleTimeoutInterval = 260,
		
		[Parameter(Mandatory = $False, ParameterSetName = "Default",HelpMessage = "Enable Fast MAC Cache Failover", Position = 4)]
		[Alias('FastMAC')]
	    [bool]$EnableFastMacCacheFailover = $True,
		
		[Parameter(Mandatory = $False, ParameterSetName = "Default",HelpMessage = "Fast MAC Cache Failover Interval (1-30 [sec])", Position = 5)]
        [ValidateRange(1,30)]
		[Alias('FastMACRefresh')]
    	[int]$MacRefreshInterval = 5,
		
		[Parameter(Mandatory = $False , ParameterSetName = "Default",HelpMessage = "Enable Network Loop Protection on the Downlink Ports)", Position = 6)]
		[Alias('LoopProtect')]
	    [bool]$EnableNetworkLoopProtection = $True,

		[Parameter(Mandatory = $False, ParameterSetName = "Default",HelpMessage = "Enable Network Pause Flood Protection on the Downlink Ports)", Position = 7)]
		[Alias('PauseProtect')]
	    [bool]$EnablePauseFloodProtection = $True,
		
		[Parameter(Mandatory = $False, ParameterSetName = "Default",HelpMessage = "Enable SNMP Settings", Position = 8)]
	    [Object]$SNMP = $null,

		[Parameter(Mandatory = $False, ParameterSetName = "Default",HelpMessage = "Array of Network Objects, Names or URIs", Position = 9)]
		[Array]$InternalNetworks,

		[Parameter(Mandatory = $False, ParameterSetName = "Default",HelpMessage = "QoS Configurtion Object", Position = 10)]
		[Alias('qos','QosConfig')]
		[Object]$QosConfiguration,

		[Parameter(Mandatory = $False, ParameterSetName = "Default",HelpMessage = "Appliance Connection Object or Name")]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions},

		[switch]$Async,

        [Parameter(Mandatory = $True, ParameterSetName = "Import",HelpMessage = "Specify JSON source file to create Logical Interconnect Group")]
        [ValidateScript({split-path $_ | Test-Path})]
        [Alias('i')]
	    [object]$Import

    )

    Begin 
	{
        
		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$LigTasks = New-Object System.Collections.ArrayList

    }
	
	Process
	{

		ForEach ($_appliance in $ApplianceConnection)
		{

			#move to ForEach loop above.
			If ($Import)
			{
            
				write-verbose "Reading input file"

				try 
				{

					#Open input file, join so we can validate if the JSON format is correct.
					$lig = [string]::Join("", (gc $import -ErrorAction Stop)) | convertfrom-json -ErrorAction Stop

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] LIG Object to Import: $($lig | ConvertTo-Json -depth 99 | Out-String)"

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request"
                
					$task = Send-HPOVRequest $logicalInterconnectGroupsUri POST $lig -Appliance $_appliance

					[void]$LigStatus.Add($task)

				}
            
				#If there was a problem with the input file (format, not syntax) throw error
				catch [System.ArgumentException] 
				{

					$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'Import' -TargetType "PSObject" -Message "JSON Input File is invalid.  Please check the contents and try again."
					$PSCmdLet.ThrowTerminatingError($errorRecord)

				}

				catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

			}

			Else 
			{

				#Create new LIgObject
			    $lig = NewObject -Lig 

				$lig.name                                         = $Name
				$lig.snmpConfiguration                            = $Snmp
				$lig.ethernetSettings.enableIgmpSnooping          = $EnableIgmpSnooping
				$lig.ethernetSettings.igmpIdleTimeoutInterval     = $IgmpIdleTimeoutInterval
				$lig.ethernetSettings.enableFastMacCacheFailover  = $EnableFastMacCacheFailover
				$lig.ethernetSettings.macRefreshInterval          = $MacRefreshInterval
				$lig.ethernetSettings.enableNetworkLoopProtection = $EnableNetworkLoopProtection
				$lig.ethernetSettings.enablePauseFloodProtection  = $EnablePauseFloodProtection

				#decide what type of QoS Configuration to add to activeQosConfig
				$lig.qosConfiguration.activeQosConfig = if ($QosConfiguration) 
				{ 

					if(-not($QosConfiguration -is [PSCustomObject]))
					{

						$Message = "The -QosConfiguration parameter does not contain a valid QOS Configuration Object.  Please check the value and try again."
						$errorRecord = New-ErrorRecord HPOneView.LogicalInterconnectGroupResourceException InvalidArgumentValue InvalidArgument 'QosConfiguration' -TargetType $QosConfiguration.Gettype().Name -Message $Message
						$PSCmdlet.ThrowTerminatingError($errorRecord)

					}
					
					if ($QosConfiguration.type -ne 'QosConfiguration')
					{

						$Message = "The -QosConfiguration parameter value does not contain a valid QOS Configuration Object.  OBject type expected 'QosConfiguration', recieved '$($QosConfiguration.type)'.  Please check the value and try again."
						$errorRecord = New-ErrorRecord HPOneView.LogicalInterconnectGroupResourceException InvalidArgumentValue InvalidArgument 'QosConfiguration' -TargetType 'PSObject' -Message $Message
						$PSCmdlet.ThrowTerminatingError($errorRecord)
					
					}

					$QosConfiguration 
				
				} 
				
				Else 
				{ 
					
					NewObject -QosConfiguration 
				
				}				
							
			    #Fill in missing bay locations from the input value if needed.
			    $Secondary = @{ 1 = $null; 2 = $null; 3 = $null; 4 = $null; 5 = $null; 6 = $null; 7 = $null; 8 = $null }

			    #check for any duplicate keys
			    $duplicates = $Bays.keys | where { $Secondary.ContainsKey($_) }

			    if ($duplicates) 
				{

			        foreach ($item in $duplicates) 
					{

			            $Secondary.Remove($item)

			        }

			    }

				#join the two hash tables
				$NewBays = $Bays + $Secondary 

			    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bay configuration: $($NewBays | Sort-Object Key -Descending | Out-String)"

				#Assign located Interconnect object URI to device bay mapping.
			    foreach ($_bay in ($NewBays.GetEnumerator() | Sort-Object Key))
				{

					$_interconnectObject = $null
			    
			   	    switch ($_bay.value) 
					{

				        "FlexFabric" 
						{            

				            #Get VC FlexFabric interconnect-type URI
			                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Found VC FF in bay $($_bay.name | out-string)"

				            $_interconnectObject = Get-HPOVInterconnectType -partNumber "571956-B21" -Appliance $_appliance

				        }

				        "Flex10" 
						{

				            #Get VC Flex-10 interconnect-type URI
			                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Found VC F10 in bay $($_bay.name | out-string)"

				            $_interconnectObject = Get-HPOVInterconnectType -partNumber "455880-B21" -Appliance $_appliance

				        }

				        "Flex1010D" 
						{

				            #Get VC Flex-10/10D interconnect-type URI
			                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Found VC F1010D in bay $($_bay.name | out-string)"

				            $_interconnectObject = Get-HPOVInterconnectType -partNumber "638526-B21" -Appliance $_appliance

				        }

				        "Flex2040f8" 
						{

				            #Get VC Flex-10/10D interconnect-type URI
			                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Found VC Flex2040f8 in bay $($_bay.name | out-string)"

				            $_interconnectObject = Get-HPOVInterconnectType -partNumber "691367-B21" -Appliance $_appliance

				        }

				        "VCFC20" 
						{

				            #Get VC Flex-10/10D interconnect-type URI
			                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Found VC FC 20-port in bay $($_bay.name | out-string)"

				            $_interconnectObject = Get-HPOVInterconnectType -partNumber "572018-B21" -Appliance $_appliance

				        }

				        "VCFC24" 
						{

				            #Get VC Flex-10/10D interconnect-type URI
			                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Found VC FC 24-port in bay $($_bay.name | out-string)"

				            $_interconnectObject = Get-HPOVInterconnectType -partNumber "466482-B21" -Appliance $_appliance

				        }

				        "FEX" 
						{

				            #Get Cisco Fabric Extender for HP BladeSystem interconnect-type URI
			                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Found Cisco Fabric Extender for HP BladeSystem in bay $($_bay.name | out-string)"
				            
							$_interconnectObject = Get-HPOVInterconnectType -partNumber "641146-B21" -Appliance $_appliance

				        }

					    default 
						{

						    $_interconnectObject = $null

					    }
					
			        }
				
				    [void]$lig.interconnectMapTemplate.interconnectMapEntryTemplates.Add(
						@{
						
							logicalDownlinkUri           = $null;
							permittedInterconnectTypeUri = $_interconnectObject.uri;
							logicalLocation = @{

								locationEntries = @(
									
									@{

										relativeValue = $_bay.name;
										type          = "Bay"

									}, @{
						
										relativeValue = "1"; 
										type          = "Enclosure"

									}

								)

							}

						}

					)

			    }

				#Loop through InternalNetwork array
				ForEach ($_network in $InternalNetworks)
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Internal Network Type: $($_network.GetType().Name)"

					switch ($_network.GetType().Name)
					{

						'String'
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Internal Network: $_network"

							if ($_network.StartsWith($script:ethNetworksUri))
							{

								Try
								{

									#Validating object
									$_network = Send-HPOVRequest $_network -Hostname $_appliance

									#Generate terminating error due to incorrect object from URI isn't the correct type
									if ($_network.category -ne 'ethernet-networks')
									{

										$Message = "The Internal Network '$_network' does not match the allowed value of 'ethernet-networks'.  Please specify an Ethernet Network to assign to the Internal Networks property."
										$errorRecord = New-ErrorRecord HPOneView.LogicalInterconnectGroupResourceException InvalidArgumentValue InvalidArgument 'InternalNetworks' -TargetType 'PSObject' -Message $Message
										$PSCmdlet.ThrowTerminatingError($errorRecord)

									}

								}

								catch
								{

									$PSCmdlet.ThrowTerminatingError($_)

								}

							}

							#Get network resource via Get-HPOVNetwork
							else
							{

								try
								{

									$_network = Get-HPOVNetwork $_network -ApplianceConnection $_appliance

								}

								catch
								{

									$PSCmdlet.ThrowTerminatingError($_)

								}

							}

						}

						'PSCustomObject'
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Internal PSObject Network: $($_network | fl * )"

							#Throw terminating error if the Internet Network object is not type Ethernet Network
							if (-not($_network.category -eq 'ethernet-networks'))
							{

								$Message = "The Internal Network category for ($_network.name) does not match the allowed value of 'ethernet-networks'."
								$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'InternalNetworks' -TargetType 'PSObject' -Message $Message
								$PSCmdlet.ThrowTerminatingError($errorRecord)

							}

							#Error if Netowrk Object does not match the appliance connection we are currently processing.
							if ($_network.ApplianceConnection.Name -ne $_appliance.Name)
							{

								$Message = "The Internal Network '($_network.name)' Appliance Connection ($($_network.ApplianceConnection.Name)) does not match the current Appliance Connection ($($_appliance.Name)) being processed."
								$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'InternalNetworks' -TargetType 'PSObject' -Message $Message
								$PSCmdlet.ThrowTerminatingError($errorRecord)
							
							}

						}

					}

					#Add to URI's to collection
					[void]$lig.internalNetworkUris.Add($_network.uri)

				}

				#Loop through Uplink Set Objects and attach to LIG
				# // TODO


			    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] LIG: $($lig | out-string)"

			    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request to create '$($lig.name)'..."
			
				Try
				{
				
					$task = Send-HPOVRequest $script:logicalInterconnectGroupsUri POST $lig -Hostname $_appliance
				
				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

			    if ($Async.IsPresent)
				{

					[void]$LigTasks.Add($task)

				}

				else
				{

					Try
					{

						$_FinalTaskStaus = Wait-HPOVTaskComplete $task

					}
					
					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

					[void]$LigTasks.Add($_FinalTaskStaus)

				}		

			}

		}

	}

    End 
	{

        Return $LigTasks

    }

}

function New-HPOVSnmpConfiguration
{

	# .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding(DefaultParameterSetName = "Default")]
    param 
	(

        [Parameter(Position = 0, Mandatory, ParameterSetName = 'Default', HelpMessage = 'Provide the Read Community value')]
        [ValidateNotNullOrEmpty()]
        [String]$ReadCommunity,
        
        [Parameter(Position = 1, Mandatory = $False, ParameterSetName = "Default", HelpMessage = 'Provide the System Contact name value')]
        [ValidateNotNullOrEmpty()]
		[String]$Contact,

        [Parameter(Position = 2, Mandatory = $False, ParameterSetName = "Default", HelpMessage = "Provide an Array of Allowed IP Addresses (e.g. 192.168.1.10/32) or Subnet (192.168.1.0/24).")]
        [ValidateNotNullOrEmpty()]
		[Array]$AccessList,
		
		[Parameter(Position = 3, Mandatory = $False, ParameterSetName = "Default", HelpMessage = "Provide an array of TrapDestinations. Can be generated from New-HPOVSnmpTrapDestination")]
        [ValidateNotNullOrEmpty()]
	    [Array]$TrapDestinations

    )

	Begin
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		$_SnmpConfigrationCol = New-Object System.Collections.ArrayList

	}

	Process
	{

		$_SnmpConfig = NewObject -SnmpConfig

		switch ($PSBoundParameters.keys)
		{

			'ReadCommunity'
			{

				$_SnmpConfig.readCommunity = $ReadCommunity

			}

			'Contact'
			{

				$_SnmpConfig.systemContact = $Contact
			
			}

			'AccessList'
			{
			
				ForEach ($_entry in $AccessList)
				{

					[void]$_SnmpConfig.snmpAccess.Add($_entry)

				}
			
			}

			'TrapDestinations'
			{
			

				ForEach ($_entry in $TrapDestinations)
				{

					[void]$_SnmpConfig.trapDestinations.Add($_entry)

				}

			}

		}


		$_SnmpConfig.PSObject.TypeNames.Insert(0,'HPOneView.Networking.SnmpConfiguration')

		[void]$_SnmpConfigrationCol.Add($_SnmpConfig)

	}

	End
	{

		Return $_SnmpConfigrationCol

	}

}

function New-HPOVSnmpTrapDestination
{

	# .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding(DefaultParameterSetName = "Default")]
    param 
	(

        [Parameter(Position = 0, Mandatory, ParameterSetName = 'Default')]
        [ValidateNotNullOrEmpty()]
        [String]$Destination,
        
        [Parameter(Position = 1, Mandatory = $false, ParameterSetName = "Default")]
        [ValidateNotNullOrEmpty()]
		[String]$Community = 'public',

        [Parameter(Position = 2, Mandatory = $False, ParameterSetName = "Default")]
        [ValidateNotNullOrEmpty()]
		[ValidateSet('SNMPv1', 'SNMPv2', IgnoreCase = $False)]
		[String]$SnmpFormat = 'SNMPv1',
		
		[Parameter(Position = 3, Mandatory = $False, ParameterSetName = "Default")]
		[ValidateNotNullOrEmpty()]
	    [Array]$TrapSeverities,

		[Parameter(Position = 4, Mandatory = $False, ParameterSetName = "Default")]
		[ValidateNotNullOrEmpty()]
		[Array]$VCMTrapCategories,

		[Parameter(Position = 5, Mandatory = $False, ParameterSetName = "Default")]
		[ValidateNotNullOrEmpty()]
		[Array]$EnetTrapCategories,

		[Parameter(Position = 6, Mandatory = $False, ParameterSetName = "Default")]
		[ValidateNotNullOrEmpty()]
		[Array]$FCTrapCategories

    )

	Begin
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		$_TrapDestinationCol = New-Object System.Collections.ArrayList

	}

	Process
	{

		$_TrapDestination = NewObject -SnmpTrapDestination

		$_TrapDestination.trapDestination    = $Destination
		$_TrapDestination.communityString    = $Community
		$_TrapDestination.trapFormat         = $SnmpFormat

		switch ($PSBoundParameters.keys)
		{

			'TrapSeverities'
			{

				ForEach ($_severity in $TrapSeverities)
				{
					
					#Throw error
					if ($SnmpTrapSeverityEnums -notcontains $_severity)
					{

						$ErrorRecord = New-ErrorRecord HPOneView.SnmpTrapDestination InvalidTrapSeverity InvalidArgument 'TrapSeverities' -Message ("The provided SNMP Trap Severity {0} is unsupported.  Please check the value, making sure it is one of these values: {1}." -f $_severity, ([System.String]::Join(", ", $SnmpTrapSeverityEnums)))

						$PSCmdlet.ThrowTerminatingError($ErrorRecord)  

					}

					$_severity = $_severity.substring(0,1).ToUpper() + $_severity.substring(1).tolower()
					
					"[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing {0} Trap Severity." -f $_severity  | Write-Verbose 
					
					[void]$_TrapDestination.trapSeverities.Add($_severity)

				}

			}

			'VCMTrapCategories'
			{
			
				ForEach ($_category in $VCMTrapCategories)
				{
					
					#Throw error
					if ($SnmpVcmTrapCategoryEnums -notcontains $_category)
					{

						$ErrorRecord = New-ErrorRecord HPOneView.SnmpTrapDestination InvalidVcmTrapCategory InvalidArgument 'VCMTrapCategories' -Message ("The provided VCM Trap Category {0} is unsupported.  Please check the value, making sure it is one of these values: {1}." -f $_category, ([System.String]::Join(", ", $SnmpVcmTrapCategoryEnums)))

						$PSCmdlet.ThrowTerminatingError($ErrorRecord)  

					}

					$_category = $_category.substring(0,1).ToUpper() + $_category.substring(1).tolower()
					
					"[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing {0} VCM Trap Category." -f $_category  | Write-Verbose 

					[void]$_TrapDestination.vcmTrapCategories.Add($_category)

				}
			
			}

			'EnetTrapCategories'
			{
			
				ForEach ($_category in $EnetTrapCategories)
				{
					
					#Throw error
					if ($SnmpEneTrapCategoryEnums -notcontains $_category)
					{

						$ErrorRecord = New-ErrorRecord HPOneView.SnmpTrapDestination InvalidEnetTrapCategory InvalidArgument 'EnetTrapCategories' -Message ("The provided Ethernet Trap Category {0} is unsupported.  Please check the value, making sure it is one of these values: {1}." -f $_category, ([System.String]::Join(", ", $SnmpEneTrapCategoryEnums)))

						$PSCmdlet.ThrowTerminatingError($ErrorRecord)  

					}

					if ($_category.StartsWith('port'))
					{

						$_category = $_category.substring(0,1).ToUpper() + $_category.substring(1,3).tolower() + $_category.substring(4,1).ToUpper() + $_category.substring(6).tolower()

					}

					"[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing {0} Enet Trap Category." -f $_category  | Write-Verbose 

					[void]$_TrapDestination.enetTrapCategories.Add($_category)

				}
			
			}

			'FCTrapCategories'
			{
			
				ForEach ($_category in $FCTrapCategories)
				{

					#Throw error
					if ($SnmpFcTrapCategoryEnums -notcontains $_category)
					{

						$ErrorRecord = New-ErrorRecord HPOneView.SnmpTrapDestination InvalidFcTrapCategory InvalidArgument 'FCTrapCategories' -Message ("The provided FC Trap Category {0} is unsupported.  Please check the value, making sure it is one of these values: {1}." -f $_category, ([System.String]::Join(", ", $SnmpFcTrapCategoryEnums)))

						$PSCmdlet.ThrowTerminatingError($ErrorRecord)  

					}

					"[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing {0} FC Trap Category." -f $_category  | Write-Verbose 
					
					[void]$_TrapDestination.fcTrapCategories.Add($_category)

				}
			
			}

		}

		$_TrapDestination.PSObject.TypeNames.Insert(0,'HPOneView.Networking.SnmpTrapDestination')

		[void]$_TrapDestinationCol.Add($_TrapDestination)

	}

	End
	{

		Return $_TrapDestinationCol

	}

}

function New-HPOVQosConfig
{

	# .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "Passthrough")]
    Param 
	(

        [parameter(Position = 0, Mandatory = $False, ValueFromPipeline = $False, ParameterSetName = "Passthrough", HelpMessage = "Specify the QOS Configuration Type; Passthrough, CustomNoFCoE, CustomWithFCoE.")]
		[parameter(Position = 0, Mandatory = $True, ValueFromPipeline = $False, ParameterSetName = "Custom", HelpMessage = "Specify the QOS Configuration Type; Passthrough, CustomNoFCoE, CustomWithFCoE.")]
		[ValidateSet("Passthrough", "CustomNoFCoE", "CustomWithFCoE", IgnoreCase = $False)]
        [String]$ConfigType = "Passthrough",

		[parameter(Position = 1, Mandatory = $False, ValueFromPipeline = $False, ParameterSetName = "Custom", HelpMessage = "Specify the uplink ports ingress traffic classification based on the values of dot1p or DSCP or both in Ethernet and IP headers respectively.")]
		[ValidateSet("DSCP", "DOT1P", "DOT1P_AND_DSCP", IgnoreCase = $False)]
		[String]$UplinkClassificationType = "DOT1P",

		[parameter(Position = 2, Mandatory = $False, ValueFromPipeline = $False, ParameterSetName = "Custom", HelpMessage = "Specify the downlink ports ingress traffic classification based on the values of dot1p or DSCP or both.")]
		[ValidateSet("DSCP", "DOT1P", "DOT1P_AND_DSCP", IgnoreCase = $False)]
		[String]$DownlinkClassificationType = "DOT1P_AND_DSCP",

		[parameter(Position = 3, Mandatory = $False, ValueFromPipeline = $False, ParameterSetName = "Custom", HelpMessage = "Array of TrafficClassifiers Classes.")]
		[System.Collections.ArrayList]$TrafficClassifiers = @()

    )

	Begin
	{

		#Helper CMDLET. Does not require appliance authentication.

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		#Validate the caller 
		if (($PSBoundParameters['UplinkClassificationType'] -or $PSBoundParameters['DownlinkClassificationType'] -or $PSBoundParameters['TrafficClassifiers']) -and $ConfigType -eq 'Passthrough')
        {

            $ParameterNames = New-Object System.Collections.ArrayList
        
            switch ($PSBoundParameters.Keys)
            {

                'UplinkClassificationType'   { [void]$ParameterNames.Add('UplinkClassificationType') }
                'DownlinkClassificationType' { [void]$ParameterNames.Add('DownlinkClassificationType') }
                'TrafficClassifiers'         { [void]$ParameterNames.Add('TrafficClassifiers') }

            }

            $Message = "ConfigType parameter value was set to 'Passthrough' and $($ParameterNames -join ", ") parameter(s) were provided.  When choosing 'Passthrough' QOS Config Type, the other parameters cannot be used."
			$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'ConfigType' -Message $Message
            $PSCmdlet.ThrowTerminatingError($errorRecord)

        }

	}

	Process
	{

		switch ($ConfigType)
		{

			'CustomNoFCoE'
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Building 'CustomNoFCoE' QOS Configuration."

				#$_QosConfigurationObject = $Script:QosConfigurationObject.PSObject.Copy()
				$_QosConfigurationObject = NewObject -DefaultNoFCoELosslessQosTrafficClassifiers

				#$_QosConfigurationObject.qosTrafficClassifiers.Clear()
				$_QosConfigurationObject.uplinkClassificationType   = $UplinkClassificationType
				$_QosConfigurationObject.downlinkClassificationType = $DownlinkClassificationType

				if ($PSBoundParameters['TrafficClassifiers'])
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding Custom Traffic Classifiers."

					$TrafficClassifiers | % { [void]$QosConfigurationObject.qosTrafficClassifiers.Add($_) }

				}
				
				else 
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding Default NoFCoELossless Traffic Classifiers."

					$QosConfigurationObject.qosTrafficClassifiers = $DefaultNoFCoELosslessQosTrafficClassifiers

				}
			
			}
			
			'CustomWithFCoE'
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Building 'CustomWithFCoE' QOS Configuration."
				$_QosConfigurationObject = NewObject -DefaultFCoELosslessQosTrafficClassifiers

				$_QosConfigurationObject.uplinkClassificationType   = $UplinkClassificationType
				$_QosConfigurationObject.downlinkClassificationType = $DownlinkClassificationType

				if ($PSBoundParameters['TrafficClassifiers'])
				{

					if ($TrafficClassifiers.Count -gt 6)
					{

						$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'TrafficClassifiers' -TargetType 'System.Collections.ArrayList' -Message "The number of provided TrafficClassifiers is exceeded by $($TrafficClassifiers.Count - 2).  When defining the QOS Configuration Type to 'CustomWithFCoE', only 6 Custom Traffic Classes are allowed."
						$PSCmdlet.ThrowTerminatingError($errorRecord)

					}

					elseif ($TrafficClassifiers.Count -le 6)
					{

						1..($TrafficClassifiers.Count - 6) | % { 
						
							#$NewBaseTrafficClass = 	$BaseTrafficClass #.Copy()
							$_NewBaseTrafficClass = NewObject -BaseTrafficClass
							
							$_NewBaseTrafficClass.qosTrafficClass.className += $_

							[void]$_QosConfigurationObject.qosTrafficClassifiers.Add($_NewBaseTrafficClass) 
						
						}

					}

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding Custom Traffic Classifiers."

					#Check to make sure caller has not provided 'Best effort' or 'FCoE lossless' Classes
					$TrafficClassifiers | % { 
					
						#Generate Error
						if ($_.name -eq 'FCoE lossless')
						{

							$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'TrafficClassifiers' -TargetType 'System.Collections.ArrayList' -Message "The 'FCoE lossless' traffic class is reserved.  Please remove it from the TrafficClassifiers parameter and try again."
							
							$PSCmdlet.ThrowTerminatingError($errorRecord)

						}	
						
						#Add to collection
						[void]$_QosConfigurationObject.qosTrafficClassifiers.Add($_) 
					
					}

					#Add FCoE Class
					[void]$_QosConfigurationObject.qosTrafficClassifiers.Add((NewObject -FCoELossLessTrafficClass))

				}
				
				else 
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding Default With FCoELossless Traffic Classifiers."

					$_QosConfigurationObject.qosTrafficClassifiers = NewObject -DefaultFCoELosslessQosTrafficClassifiers

				}

			}

		}

	}

	End
	{

		$_QosConfigurationObject.qosTrafficClassifiers | % { 
			
			if ($_.PSObject.TypeNames -notcontains 'HPOneView.Networking.Qos.TrafficClassifier')	
			{
			
				$_.PSObject.TypeNames.Insert(0,'HPOneView.Networking.Qos.TrafficClassifier') 
			
			}
		
		}

		$_QosConfigurationObject.PSObject.TypeNames.Insert(0,'HPOneView.Networking.Qos.Configuration')

		Return $_QosConfigurationObject

	}

}

function New-HPOVQosTrafficClass
{

	# .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "default",SupportsShouldProcess = $True,ConfirmImpact = 'High')]
    Param 
	(

		[parameter(Position = 0, Mandatory = $False, ValueFromPipeline = $False, ParameterSetName = "default", HelpMessage = "Specify a unique name for the traffic class.")]
		[Alias('ClassName')]
		[string]$Name,

		[parameter(Position = 1, Mandatory = $False, ValueFromPipeline = $False, ParameterSetName = "default", HelpMessage = "Maximum share the traffic class can use when other traffic classes are not using their guaranteed share")]
		[ValidateRange(1,100)]
        [int]$MaxBandwidth = $Null,

		[parameter(Position = 2, Mandatory = $False, ValueFromPipeline = $False, ParameterSetName = "default", HelpMessage = "Minimum guaranteed bandwidth for the traffic class.")]
		[string]$BandwidthShare,
		
		[parameter(Position = 3, Mandatory = $False, ValueFromPipeline = $False, ParameterSetName = "default", HelpMessage = "Specifies the dot1p priority value to remark for the egressing packets")]
		[int]$EgressDot1pValue,

		[parameter(Position = 4, Mandatory = $False, ValueFromPipeline = $False, ParameterSetName = "default", HelpMessage = "Specifies the DSCP priority value to map for the QoS Traffic Classifier")]
		[System.Collections.ArrayList]$IngressDot1pClassMapping,
		
		[parameter(Position = 5, Mandatory = $False, ValueFromPipeline = $False, ParameterSetName = "default", HelpMessage = "Specifies the DSCP priority value to map for the QoS Traffic Classifier.")]
		[System.Collections.ArrayList]$IngressDscpClassMapping,

		[parameter(Mandatory = $False, ValueFromPipeline = $False, ParameterSetName = "default", HelpMessage = "Specifies whether the traffic class is real time.")]
		[switch]$RealTime,

		[switch]$Enabled

    )

	Begin
	{

		#CMDLET doesn't require auth

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		$NoMatch = New-Object System.Collections.ArrayList
		
		#Validate the IngressDscpClassMapping values caller is providing
		ForEach ($item in $IngressDscpClassMapping)
		{

			if (-not($Script:IngressDscpClassMappingValues -contains $item))
			{

				[void]$NoMatch.Add($item)

			}

		}

		#Check to make sure caller isn't attempting to create an FCoE lossless Class
		if ($Name -eq "FCoE lossless")
		{

			$Message = "The 'FCoE lossless' Traffic Classifier cannot be modified or created.  It is automatically created when using the 'New-HPOVQosConfig' CMDLET."
			$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'Name' -Message $Message
            $PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		if ($Name -eq "Best effort" -and $PSBoundParameters['MaxBandwidth'] -and $PSBoundParameters.Count -gt 2 -and (-not($PSBoundParameters['verbose']) -or -not($PSBoundParameters['debug']) -or -not($PSBoundParameters['Enabled'])))
		{

			$Message = "The 'Best effort' Traffic Classifier can only be created with providing the 'Name' and 'MaxBandwidth' parameters."
			$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'Name' -Message $Message
            $PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		if ($NoMatch)
		{

			$Message = "Invalid IngressDscpClassMapping parameter values found: $($NoMatch -join ', ').  Please remove these values and try again."
			$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'IngressDscpClassMapping' -TargetType 'Array' -Message $Message
            $PSCmdlet.ThrowTerminatingError($errorRecord)

		}

	}

	Process
	{

		$_BaseTrafficClass = NewObject -BaseTrafficClass

		switch ($PSBoundParameters.Keys)
		{

			"Name"
			{

				$_BaseTrafficClass.qosTrafficClass.className = $Name

			}

			"MaxBandwidth"
			{
			
				$_BaseTrafficClass.qosTrafficClass.maxBandwidth = $MaxBandwidth
			
			}

			"BandwidthShare"
			{

				$_BaseTrafficClass.qosTrafficClass.bandwidthShare = $BandwidthShare
						
			}


			"EgressDot1pValue"
			{
			
				$_BaseTrafficClass.qosTrafficClass.egressDot1pValue = $EgressDot1pValue
			
			}

			"RealTime"
			{
			
				$_BaseTrafficClass.qosTrafficClass.realTime = $RealTime
			
			}
			
			"IngressDot1pClassMapping"
			{

				$IngressDot1pClassMapping | % { [void]$_BaseTrafficClass.qosClassificationMapping.dot1pClassMapping.Add($_) }

			}
			
			"IngressDscpClassMapping"
			{

				$IngressDscpClassMapping | % { [void]$_BaseTrafficClass.qosClassificationMapping.dscpClassMapping.Add($_) }

			}

		}

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] BaseTrafficClass Object: $($_BaseTrafficClass | fl * | Out-String) $($_BaseTrafficClass.qosTrafficClass | fl * | Out-String) $($_BaseTrafficClass.qosClassificationMapping | fl * | Out-String)"

	}

	End
	{

		$_BaseTrafficClass.PSObject.TypeNames.Insert(0,'HPOneView.Networking.QosTrafficClassifier')

		Return $_BaseTrafficClass

	}

}

function Remove-HPOVLogicalInterconnectGroup 
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "default", SupportsShouldProcess = $True, ConfirmImpact = 'High')]
    Param 
	(

        [parameter(Position = 0, Mandatory, ValueFromPipeline, ParameterSetName = "default", HelpMessage = "Specify the Logical Interconnect Group(s) to remove.")]
		[parameter(position = 0, Mandatory, ParameterSetName = "ApplianceRequired")]
        [ValidateNotNullOrEmpty()]
        [Alias("uri","name","Lig")]
        [Object]$Resource = $null,
	
		[parameter(Mandatory = $False, ValueFromPipelineByPropertyName, ParameterSetName = "ApplianceRequired", position = 1)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions},

	    [parameter(Mandatory = $false)] 
        [switch]$force

    )

    Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try {
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] {

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch {

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		if (-not($PSBoundParameters['Resource'])) { $PipelineInput = $True }

		$_taskcollection = New-Object System.Collections.ArrayList
		$_ligcollection = New-Object System.Collections.ArrayList

    }

    Process 
	{

		if ($PipelineInput) 
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Pipeline input"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] LIG Object provided: $($Resource | FL * | Out-String)"

			If ($Resource.category -eq 'logical-interconnect-groups')
			{

				If (-not($Resource.ApplianceConnection))
				{

					$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument "LIG:$($Resource.Name)" -TargetType PSObject -Message "The LIG resource provided is missing the source ApplianceConnection property.  Please check the object provided and try again."
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				[void]$_ligcollection.Add($Resource)

			}

			else
			{

				$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument "Network:$($Resource.Name)" -TargetType PSObject -Message "The LIG resource is not an expected category type [$($Resource.category)].  Allowed resource category type is 'logical-interconnect-groups'.  Please check the object provided and try again."
                $PSCmdlet.ThrowTerminatingError($errorRecord)

			}

		}

		else 
		{

			foreach ($_lig in $Resource) 
			{

				#LIG passed is a URI
				if (($_lig -is [String]) -and [System.Uri]::IsWellFormedUriString($_lig,'Relative')) 
				{

				    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Received URI: $($_lig)"

				    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Network Name"

					if ($ApplianceConnection.count -gt 1)
					{

						# // Throw Error due to lack of specific ApplianceConnection

					}

					else
					{

						[void]$_ligcollection.Add((Send-HPOVRequest $_lig -Appliance $ApplianceConnection.Name))

					}
				    
				}

				#LIG passed is the Name
				elseif (($_lig -is [string]) -and (-not($_lig.startsWith("/rest/")))) 
				{

				    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Received LIG Name $($_lig)"

				    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting LIG object from Get-HPOVLogicalInterconnectGroup"
				    
					Try
					{

						$_lig = Get-HPOVLogicalInterconnectGroup $_lig -ApplianceConnection $ApplianceConnection.Name

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}
				    

				    if ($_lig.count -gt 1 ) 
					{ 

				        $errorRecord = New-ErrorRecord InvalidOperationException NetworkResourceNameNotUnique InvalidResult 'Remove-HPOVNetwork' -Message "Invalid Network parameter: $net"
				        $PSCmdlet.WriteError($errorRecord)                
				    
				    }

					[void]$_ligcollection.Add($_lig)

				}

				#LIG passed is the object
				elseif ($_lig -is [PSCustomObject] -and ($_lig.category -ieq 'logical-interconnect-groups')) 
				{
				    
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] LIG Object provided: $($_lig | FL * | out-string)"

					[void]$_ligcollection.Add($_lig)
				
				}

				elseif ($_lig -is [PSCustomObject] -and ($_lig.category -ne 'logical-interconnect-groups'))
				{

				    $errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'Resource' -TargetType 'PSObject' -Message "Invalid LIG parameter: $($_lig | FL * | Out-String)"
				    $PSCmdlet.WriteError($errorRecord)

				}

			}

		}
        
    }

	End
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing $($_ligcollection.count) LIG resources to remove."

		#Process LIG Resources
		ForEach ($_lig in $_ligcollection)
		{
		
			if ($pscmdlet.ShouldProcess($_lig.name,"Remove Logical Interconnect Group from appliance '$($_lig.ApplianceConnection.Name)'?'")) 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Removing LIG '$($_lig.name)' from appliance '$($_lig.ApplianceConnection.Name)'."

				Try
				{
					
					if ($force.IsPresent)
					{

						$_lig.uri += "?force=true"

					}

					$_resp = Send-HPOVRequest $Resource.Uri DELETE -Hostname $Resource.ApplianceConnection.Name

					[void]$_taskcollection.Add($_resp)

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

			}

			elseif ($PSBoundParameters['WhatIf'])
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] WhatIf parameter was passed."

				Write-Host "WHATIF: Remove Logical Interconnect Group '$($_lig.name)' from appliance '$($_lig.ApplianceConnection.Name)'" -ForegroundColor Yellow

			}

		}

		Return $_taskcollection

	}

}

function Get-HPOVUplinkSet 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "Name")]

    Param 
	(

        [Parameter(Position = 0, Mandatory = $false, ParameterSetName = "Name")]
		[ValidateNotNullorEmpty()]
        [string]$Name = $null,

        [Parameter(Position = 1, Mandatory = $false, ValueFromPipeline, ParameterSetName = "Name")]
        [Parameter(Position = 1, Mandatory = $false, ValueFromPipeline, ParameterSetName = "Type")]
		[ValidateNotNullorEmpty()]
        [Alias('liname')]
		[object]$LogicalInterconnect = $null,

        [Parameter(Position = 0, Mandatory = $false, ParameterSetName = "Type")]
        [ValidateSet('Ethernet','FibreChannel', IgnoreCase=$False)]
        [string]$type = $null,
	
		[Parameter(Mandatory = $false)]
		[switch]$report,

		[parameter(Mandatory = $false)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions},

		[parameter (Mandatory = $false)]
		[alias("x", "export")]
		[ValidateScript({split-path $_ | Test-Path})]
		[String]$exportFile

    )
	
	Begin 
	{

		if ($PSBoundParameters['report'])
		{

			Write-Warning "The Report parameter has been deprecated.  The CMDLET will now display object data in Format-List view."

		}

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		ForEach ($_connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_UplinkSetCollection = New-Object System.Collections.ArrayList
        
	}
	
	Process 
	{

		if ($LogicalInterconnect -is [PSCustomObject])
		{

			$ApplianceConnection = $ApplianceConnection | ? { $_.Name -eq $LogicalInterconnect.ApplianceConnection.Name }

		}

		ForEach ($_connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_connection.Name)' Appliance"

			#Looking for UplinkSet Name without LI Object/Resource
			if ($PSCmdlet.ParameterSetName -eq 'Name' -and (-not($PSBoundParameters['LogicalInterconnect']))) 
			{

				if ($PSboundParameters['Name'])
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Uplink Set name provided: '$name'"

					$name = $name -replace ("[*]","%25") -replace ("[&]","%26")

					#We will crate a URI that uses filter at the resource URI
					$uri = $uplinkSetsUri + "?filter=name matches '$name'"

				}

				else
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Looking for all Uplink Sets."

					$uri = $uplinkSetsUri

				}

				$_uplinksets = Send-HPOVRequest $uri GET -Hostname $_connection

				if ($_uplinksets.count -eq 0)
				{

					#Generate Error if no name was found
					$errorRecord = New-ErrorRecord InvalidOperationException UplinkSetResourceNameNotFound ObjectNotFound 'Name' -Message "Specified Uplink Set '$name' was not found on '$($_connection.Name)'.  Please check the name and try again."
					$pscmdlet.ThrowTerminatingError($errorRecord)  

				}

				else
				{

					$_uplinksets = $_uplinksets.members

				}

			}

			#Looking for LI Object and associated Uplink Sets
			elseif ($PSboundParameters['LogicalInterconnect']) # -and (-not($PSBoundParameters['Name']))) 
			{

				#Check the LogicalInterconnect parameter value type
				switch ($LogicalInterconnect.GetType().Name)
				{
				
					'PSCustomObject'
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Recieved PSCustomObject for LogicalInterconnect parameter."

						if ($LogicalInterconnect.category -eq 'logical-interconnects')
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Logical Interconnect Object provided: $($LogicalInterconnect | FL * | Out-String)."

						}
						
						else
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Invalid Logical Interconnect Object provided: $($LogicalInterconnect | Out-String)."

							$errorRecord = New-ErrorRecord InvalidOperationException LogicalInterconnectInvalidCategroy InvalidArgument 'LogicalInterconnect' -TargetType 'PSObject' -Message "The provided LogicalInterconnect resource category '$($LogicalInterconnect.category)' does not match the required 'logical-interconnects' value.  Please check the parameter value and try again."
							$pscmdlet.ThrowTerminatingError($errorRecord) 

						}

					}

					'String'
					{

						#User provided Logical Interconnect Name, look for it on the appliance
						if (-not($LogicalInterconnect.StartsWith('/rest/')) -or (-not($LogicalInterconnect.StartsWith($logicalInterconnectsUri))))
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Logical Interconnect name provided: 'LogicalInterconnect'."

							Try
							{

								Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Logical Interconnect '$liName'"

								$LogicalInterconnect = Get-HPOVLogicalInterconnect $LogicalInterconnect -ApplianceConnection $_connection

							}

							Catch
							{

								$PSCmdlet.ThrowTerminatingError($_)

							}

						}

						#User didn't provide a Logical Interconnect Resource Name, generate error as URI's are not supported
						else
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Invalid Logical Interconnect parameter value provided: $($LogicalInterconnect | Out-String)."

							$errorRecord = New-ErrorRecord InvalidOperationException InvalidLogicalInterconnectParameterValue InvalidArgument 'LogicalInterconnect' -TargetType 'PSObject' -Message "The provided LogicalInterconnect resource category '$($LogicalInterconnect.category)' does not match the required 'logical-interconnects' value.  Please check the parameter value and try again."
							$pscmdlet.ThrowTerminatingError($errorRecord) 

						}
						
					}
				
				}

				#Use Index to find associations
				try 
				{ 
				
					$_uplinksets = New-Object System.Collections.ArrayList

				    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Looking for associated Uplink Sets to Logical Interconnects via Index."
					$_indexassociatedulinksets = Send-HPOVRequest "/rest/index/associations?parentUri=$($LogicalInterconnect.uri)&name=LOGICAL_INTERCONNECT_TO_UPLINK_SET" -Hostname $_connection
					
					if ($_indexassociatedulinksets.count -gt 0)
					{

						ForEach ($child in $_indexassociatedulinksets.members)
						{

							$_uplinksetobject = Send-HPOVRequest $child.childUri -Hostname $_connection

							if ($Name)
							{

								Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Filtering Uplink Sets for '$Name'"
				        
								if ($Name -match "\*" -or $Name -match "\?")
								{

									if ($_uplinksetobject.name -match $Name)
									{

										[void]$_uplinksets.Add($_uplinksetobject)

									}

								}

								else
								{

									if ($_uplinksetobject.name -eq $Name)
									{

										[void]$_uplinksets.Add($_uplinksetobject)

									}

								}

							}

							elseif ($type) 
							{

							    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Filtering Uplink Sets for '$type' type." 
							    if ($_uplinksetobject.networkType -eq $type)
								{

									[void]$_uplinksets.Add($_uplinksetobject)

								}

							}
							
						}
						
					}
					
					
					if ($Name -and $_uplinksets.count -eq 0)
					{
						
						#Generate Error if no name was found
						$errorRecord = New-ErrorRecord InvalidOperationException UplinkSetResourceNameNotFound ObjectNotFound 'Name' -Message "Specified Uplink Set '$name' was not found associated with '$($LogicalInterconnect.name)' on '$($_connection.Name)'.  Please check the name and try again."
						$pscmdlet.ThrowTerminatingError($errorRecord)  

					}

					elseif ($type -and $_uplinksets.count -eq 0)
					{

						$errorRecord = New-ErrorRecord InvalidOperationException UplinkSetResourceTypeNotFound ObjectNotFound 'Type' -Message "Specified Uplink Set Type '$type' was not found associated with '$($LogicalInterconnect.name)' on '$($_connection.Name)'.  Please check the name and try again."
						$pscmdlet.ThrowTerminatingError($errorRecord)  
					
					}

				}

				catch 
				{

				    $PSCmdlet.ThrowTerminatingError($_)

				}

			}

			#Update TypeNames
			if ($_uplinksets.count -gt 0)
			{

				foreach ($_object in $_uplinksets)
				{

					switch ($_object.networkType)
					{

						'Ethernet'     
						{ 

							$_object.PSObject.TypeNames.Insert(0,'HPOneView.Networking.LogicalInterconnect.UplinkSet.Ethernet') 
							$_object.portConfigInfos | % {
								
								Add-Member -InputObject $_ -NotePropertyName ApplianceConnection -NotePropertyValue $_object.ApplianceConnection

								$_.PSObject.TypeNames.Insert(0,'HPOneView.Networking.LogicalInterconnect.UplinkSet.Ethernet.UplinkPort') 

							}
							
						}

						'FibreChannel' 
						{ 
						
							$_object.PSObject.TypeNames.Insert(0,'HPOneView.Networking.LogicalInterconnect.UplinkSet.FibreChannel') 
							$_object.portConfigInfos | % {
								
								Add-Member -InputObject $_ -NotePropertyName ApplianceConnection -NotePropertyValue $_object.ApplianceConnection

								$_.PSObject.TypeNames.Insert(0,'HPOneView.Networking.LogicalInterconnect.UplinkSet.FibreChannel.UplinkPort') 

							}
						
						}

					}

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding '$($_object.name)' to final collection."

					[void]$_UplinkSetCollection.Add($_object)

				}

			}

		}

    }

    End 
	{

		#if ($report) {
		#
		#
        #   [Array]$uplinkSetReport = @()
		#
		#    foreach ($us in ($_UplinkSetCollection | sort-object -Property name)) 
		#	{
		#
        #        $uplinkSet = [PsCustomObject]@{ name = $Null; liName = $Null; type = $Null; reachability = $Null; state = $Null; networks = @(); ports = @() }
		#
        #        $uplinkSet.name         = $us.name
        #        $uplinkSet.liName       = (Send-HPOVRequest $us.logicalInterconnectUri -Hostname ).name
        #        $uplinkSet.reachability = $us.reachability
        #        $uplinkSet.state        = "$($us.status)($($us.state))"
		#
        #        if ($us.type -eq "Ethernet") { $uplinkSet | Add-Member -NotePropertyName ethernetNetworkType -NotePropertyValue $us.ethernetNetworkType }
		#
		#    	if ($us.networkType -eq "Ethernet"){
		#
        #            $uplinkSet.type = $us.ethernetNetworkType
		#    	
        #            #$ethNetwork = [PsCustomObject]@{ name = $Null }			
		#    		
		#    		foreach ($net in $us.networkUris){
		#    		
        #                $ethNetwork = [PsCustomObject]@{ name = $Null }	
        #                	
        #                $network = Send-HPOVRequest $net
	    #                
        #                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Found Ethernet Network name: $($network.name)"
		#    			
        #                #Compare if the net URI is the same as the native URI
		#    			if ($network.uri -eq $us.nativeNetworkUri){ 
        #                    
        #                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Ethernet Network $($net.name) is the Native/PVID for uplink set."
        #                    $ethNetwork.name = "$($network.name) [NATIVE]"
        #                    
        #                }
		#    			else { $ethNetwork.name = $network.name }
		#
        #                if ($network.vlanID) { $ethNetwork | Add-Member -NotePropertyName vlanId -NotePropertyValue $network.vlanId -force }
		#
        #                $uplinkSet.networks += $ethNetwork
		#    		}
		#
		#    	}
		#    	elseif ($us.networkType -eq "FibreChannel") {
		#
        #            $uplinkSet.type = $us.networkType
		#
		#    		foreach ($net in $us.fcNetworkUris){
		#    		    
        #                $fcNetwork = [PsCustomObject]@{ name = $Null; fabricType = $Null }				
		#    			
        #                #Send the request
		#    			$fcNet = Send-HPOVRequest $net
		#
	    #                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Found FC Network name: $($fcNet.name)"
        #                $fcNetwork.name = $fcNet.name
        #                $fcNetwork.fabricType = $fcNet.fabricType
		#    			$uplinkSet.networks += $fcNetwork
		#
		#    		}
		#    	}
	    #               
	    #        #Get Uplink Port Assignment.
		#    	foreach ($p in $us.portConfigInfos){
		#
        #            $tempPort = $Null                    
        #            
        #            $port = [PsCustomObject]@{ name = $Null; speed = $Null; opSpeed = $Null; status = $Null; neighbor = $Null }
        #            
        #            $tempPort = Send-HPOVRequest $p.portUri
        #            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Retrieved port info for '$($tempPort.interconnectName), $($tempPort.portName)'"
		#
        #            $port.name = "$($tempPort.interconnectName), $($tempPort.portName)"
        #            $port.speed = $p.desiredSpeed
        #            $port.opSpeed = $global:getUplinkSetPortSpeeds["$($tempPort.operationalSpeed)"]
        #            $port.status = "$($tempPort.portStatus)/$($tempPort.status)"
		#
        #            if ($us.networkType -eq "Ethernet") { 
        #            
        #                $port.neighbor = "$($tempPort.neighbor.remoteSystemName) [$(if (-not $tempPort.neighbor.remoteMgmtAddress) { $tempPort.neighbor.remoteChassisId } else {$tempPort.neighbor.remoteMgmtAddress})] $($tempPort.neighbor.remotePortDescription) $($tempPort.neighbor.remotePortId)"
        #                if ($tempPort.lagId) { $port | add-member -NotePropertyName lagid -NotePropertyValue $tempPort.lagId }
        #                else { $port | add-member -NotePropertyName lagid -NotePropertyValue "N/A" }
        #            
        #            }
        #            elseif ($us.networkType -eq "FibreChannel") { 
        #                $port.neighbor = $tempPort.fcPortProperties.wwpn 
        #                $port | add-member -NotePropertyName fabric -NotePropertyValue $tempPort.fcPortProperties.opOnlineReason
        #            }
		#
        #            $uplinkSet.ports += $port
		#
		#    	}
		#
        #        $u = @{Expression={$_.name};Label="Uplink Set Name"},
        #             @{Expression={$_.liName};Label="LI Name"},
        #             @{Expression={$_.type};Label="Type"},
        #             @{Expression={$_.reachability};Label="Reachability"},
        #             @{Expression={$_.state};Label="State"}
		#
        #        $uplinkSet | format-table $u -AutoSize -Wrap
		#
        #        if ($us.networkType -eq "Ethernet") { 
        #        
        #            $n = @{Expression={$_.name};Label="Network Name"},
        #                 @{Expression={$_.vlanId};Label="VLAN ID"}
		#
        #        }
        #        else { $n = @{Expression={$_.name};Label="Network Name"},
        #                 @{Expression={$_.fabricType};Label="Type"}
        #        }
		#
        #        $uplinkSet.networks | sort-object -Property name | format-table $n -AutoSize -Wrap
		#
        #        if ($us.networkType -eq "Ethernet") { 
        #        
        #            $p = @{Expression={$_.name};Label="Port Name"},
        #                 @{Expression={$_.speed};Label="Configured Speed"},
        #                 @{Expression={$_.opSpeed};Label="Connected Speed"},
        #                 @{Expression={$_.status};Label="Status"},
        #                 @{Expression={$_.lagid};Label="LAG ID"},
        #                 @{Expression={$_.neighbor};Label="(LLDP) Connected To"}
		#
        #        }
        #        else {
		#
        #            $p = @{Expression={$_.name};Label="Port Name"},
        #                 @{Expression={$_.speed};Label="Configured Speed"},
        #                 @{Expression={$_.opSpeed};Label="Connected Speed"},
        #                 @{Expression={$_.status};Label="Status"},
        #                 @{Expression={$_.fabric};Label="Fabric Connection"},
        #                 @{Expression={$_.neighbor};Label="WWPN Connected To"}
        #        
        #        }
		#
        #        $uplinkSet.ports | sort-object -Property name | format-table $p -AutoSize -Wrap
        #        write-host "------------------------------------------------------------------------------------------------------------------"
		#    }
        #    Write-Host "=================================================================================================================="
        #    write-host " "
        #    Write-Verbose "Done. $($uplinkSets.count) uplink set(s) found."
		#
		#}
		#
		#else 
		#{
            
            $_UplinkSetCollection | sort-object -Property networkType,name

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Done. $($_UplinkSetCollection.count) uplink set(s) found."
		    
		#}

    }

}

function New-HPOVUplinkSet 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "PipelineOrObjectEthernet")]
    Param 
	(

        [parameter(Mandatory = $false, ValueFromPipeline = $True, Position = 0, ParameterSetName = "PipelineOrObjectEthernet")]
		[parameter(Mandatory = $false, ValueFromPipeline = $True, Position = 0, ParameterSetName = "PipelineOrObjectFibreChannel")]
        [alias('li','lig')]
        [Object]$Resource,

		[parameter(Mandatory = $true, Position = 1, ParameterSetName = "PipelineOrObjectFibreChannel")]
        [parameter(Mandatory = $true, Position = 1, ParameterSetName = "PipelineOrObjectEthernet")]
        [alias('usName')]
        [String]$Name,

		[parameter(Mandatory = $true, Position = 2, ParameterSetName = "PipelineOrObjectFibreChannel")]
        [parameter(Mandatory = $true, Position = 2, ParameterSetName = "PipelineOrObjectEthernet")]
        [alias('usType')]
        [ValidateSet("Ethernet", "FibreChannel", "Untagged", "Tunnel", IgnoreCase=$false)]
        [String]$Type = $Null,

		[parameter(Mandatory = $false, Position = 3, ParameterSetName = "PipelineOrObjectFibreChannel")]
        [parameter(Mandatory = $false, Position = 3, ParameterSetName = "PipelineOrObjectEthernet")]
        [alias('usNetworks')]
        [Array]$Networks = @(),

        [parameter(Mandatory = $false, Position = 4, ParameterSetName = "PipelineOrObjectEthernet")]
        [Alias ('usNativeEthNetwork','Native','PVID')]
        [Object]$NativeEthNetwork = $Null,

		[parameter(Mandatory = $false, Position = 4, ParameterSetName = "PipelineOrObjectFibreChannel")]
        [parameter(Mandatory = $false, Position = 5, ParameterSetName = "PipelineOrObjectEthernet")]
        [Alias ('usUplinkPorts')]
        [ValidateScript({($_.Split(","))[0].contains(":")})]
        [Array]$UplinkPorts = @(),

        [parameter(Mandatory = $false, Position = 6, ParameterSetName = "PipelineOrObjectEthernet")]
        [alias('usEthMode')]
        [ValidateSet("Auto", "Failover", IgnoreCase=$false)]
        [String]$EthMode = "Auto",
        
        [parameter(Mandatory = $false, Position = 7, ParameterSetName = "PipelineOrObjectEthernet")]
        [ValidateSet("Short", "Long", IgnoreCase=$false)]
        [String]$LacpTimer = "Short",

        [parameter(Mandatory = $false, Position = 8, ParameterSetName = "PipelineOrObjectEthernet")]
        [ValidateSet("Short", "Long", IgnoreCase=$false)]
        [ValidateScript({$_.contains(":")})]
        [String]$PrimaryPort = $Null,

        [parameter(Mandatory = $false, Position = 9, ParameterSetName = "PipelineOrObjectEthernet")]
        [ValidateSet("Auto", "2", "4", "8", IgnoreCase=$false)]
        [String]$fcUplinkSpeed = "Auto",
		
		[parameter(Mandatory = $false, ValueFromPipelinebyPropertyName, ParameterSetName = "PipelineOrObjectEthernet")]
		[parameter(Mandatory = $false, ValueFromPipelinebyPropertyName, ParameterSetName = "PipelineOrObjectFibreChannel")]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Object]$ApplianceConnection = ${Global:ConnectedSessions}

    )

    Begin 
	{
        
		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if ($PSCmdlet.ParameterSetName -eq "PipelineOrObject")
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

			$c = 0

			ForEach ($_Connection in $ApplianceConnection) 
			{

				Try 
				{
	
					$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

				}

				Catch [HPOneview.Appliance.AuthSessionException] 
				{

					$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				Catch 
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

				$c++

			}

		}
		
		else
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Creating Uplink Set Object for caller without auth."

		}

		$Results = New-Object System.Collections.ArrayList

    }
	
	Process 
	{

		ForEach ($_resource in $Resource)
		{

			$_NewUpinkSetCol = New-Object System.Collections.ArrayList

			#if pipeline object is String and not PSCustomObject, fail the call
			if ($_resource -is [String] -or (-not($_resource -is [PSCustomObject])))
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Input Object is an unsupported type: $($_resource.GetType().FullName).  Generating error."
					
				$errorRecord = New-ErrorRecord ArgumentException InvalidParameter InvalidArgument 'Resource' -TargetType 'PSObject' -Message "The -Resource parameter value type($($_resource.GetType().Fullname)) provided is not a Logical Interconnect Group object.  Please check the value and try again."
				$pscmdlet.ThrowTerminatingError($errorRecord)

			}

			#Validate the resource contains the ApplianceConnection NoteProperty
			if (-not($_resource.ApplianceConnection))
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Input Object does not contain the ApplianceConnection NoteProperty, generating error."
					
				$errorRecord = New-ErrorRecord ArgumentException InvalidParameter InvalidArgument 'Resource' -TargetType 'PSObject' -Message "The -Resource parameter value does not contain the ApplianceConnection object property.  Please validate the object was retrieved from Get-HPOVLogicalInterconnectGroup or a resource URI via Send-HPOVRequest."
				$pscmdlet.ThrowTerminatingError($errorRecord)

			}

			#Determine the resource type; LIG or LI
			switch ($_resource.category)
			{

				#Uplink Sets are created differently for LI Resources
				'logical-interconnects'
				{

					# // TODO update with C# strongly typed name
					if(-not($_resource -is [PSCustomObject]))
					{
						
						$errorRecord = New-ErrorRecord ArgumentException InvalidParameter InvalidArgument 'Resource' -Message "The -Resource parameter value provided is not a Logical Interconnect object.  Please check the value and try again."
						$pscmdlet.ThrowTerminatingError($errorRecord)

					}

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Provided LI Resource Name: $($_resource.name)"
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Provided LI Resource Category: $($_resource.category)"
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Provided LI Resource URI: $($_resource.uri)"

					#Init Uplink Set Objects
					$_liUplinkSetObject  = NewObject -liUplinkSetObject

					$_liUplinkSetObject.name      = $Name
					$_liUplinkSetObject.lacpTimer = $LacpTimer

					#Add Logical Interconnect object URI to Uplink Set Object
					$_liUplinkSetObject.logicalInterconnectUri = $_resource.uri

					#Get list of interconnects within LI resource
					$_liInterconnects = $_resource.interconnectMap.interconnectMapEntries
					
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Uplink Ports: $($UplinkPorts | out-string)"

					#Loop through requested Uplink Ports
					$port              = New-Object System.Collections.ArrayList
					$uslogicalLocation = New-Object System.Collections.ArrayList

					foreach ($_p in $UplinkPorts)
					{

						#Split string to get bay and port
						$_p = $_p.Split(':')
						    
						#remove bay so we just have the ID
						$bay = $_p[0].ToLower().TrimStart('bay') -replace " ",''
						    
						#Get faceplate portName
						$uplinkPort = $_p[1]
						    
						write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())]] Processing Port Bay$($bay):$($uplinkPort)"

						write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())]] Looking for Interconnect URI for Bay $($bay)"

						#Loop through Interconnect Map Entry Template items looking for the provided Interconnet Bay number
						ForEach ($l in $_resource.interconnectMap.interconnectMapEntries) 
						{ 

						    $found = $l.location.locationEntries | ? { $_.type -eq "Bay" -and $_.value -eq $bay }
													            
						    if ($found) 
							{
						                
						        $permittedIcUri = $l.permittedInterconnectTypeUri

						        write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())]] Found permitted Interconnect Type URI $($permittedIcUri) for Bay $($bay)"

						    }

						} 
							
						#Get Interconnect Type object in order to get relative port ID
						$_interconnecttype = Send-HPOVRequest $permittedIcUri -Hostname $_resource.ApplianceConnection.Name

						#Translate the port number
						$_portRelativeValue = ($_interconnecttype.portInfos | ? portName -eq $uplinkPort).portNumber

						#Didn't find relative port number, so generate terminating error
						if (-not($_portRelativeValue)) 
						{

						    $errorRecord = New-ErrorRecord HPOneView.UplinkSetResourceException InvalidUplinkPortID InvalidArgument 'port' -Message "The provided uplink port 'BAY$($bay):$($uplinkPort)' is an invalid port ID.  Did you mean 'X$($uplinkPort)'?  Please check the value and try again."
						    $pscmdlet.ThrowTerminatingError($errorRecord)

						}

						#Add uplink port
						$_location = NewObject -UplinkSetLocation

						($_location.location.locationEntries | ? type -eq 'Bay').value = [int]$bay
						($_location.location.locationEntries | ? type -eq 'Port').value = [int]$_portRelativeValue

						#Create Primary Port logical location object
						if ($PrimaryPort -match $_p -and $EthMode -eq "Failover") 
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Setting Uplink Set mode to 'Failover', and Primary Port to '$PrimaryPort'"

							$_liUplinkSetObject.primaryPortLocation | Add-Member -NotePropertyName locationEntries -NotePropertyValue (New-Object System.Collections.ArrayList)

							$_liUplinkSetObject.mode = $EthMode

							[void]$_liUplinkSetObject.primaryPortLocation.locationEntries.Add((

									[PSCustomObject]@{
							                
										type  = "Enclosure";
										value = 1

									},
									[PSCustomObject]@{

										type  = "Bay";
										value = [int]$bay

									},
									[PSCustomObject]@{

										type  = "Port";
										value = [int]$_portRelativeValue

									}

								)

							)

						}
        
						#Set FC Uplink Port Speed
						if ($Type -eq "FibreChannel") 
						{ 

							$_location.desiredSpeed = $global:SetUplinkSetPortSpeeds[$fcUplinkSpeed] 

						}

						else 
						{ 
								
							$_location.desiredSpeed = "Auto" 
							
						}

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding Uplink Set to LIG: $($_logicalLocation | out-string)"
						        
						[void]$_liUplinkSetObject.portConfigInfos.Add($_location)

					}

					#Network Objects
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Network Uris"

					$_networkUris = GetNetworkUris $Networks $ApplianceConnection

					$_networkUris | ? { $_.StartsWith('/rest/ethernet-networks/') } | % {

						[void]$_liUplinkSetObject.networkUris.Add($_)

					}

					$_networkUris | ? { $_.StartsWith('/rest/fc-networks/') } | % {

						[void]$_liUplinkSetObject.networkUris.Add($_)

					}

					$_networkUris | ? { $_.StartsWith('/rest/fcoe-networks/') } | % {

						[void]$_liUplinkSetObject.networkUris.Add($_)

					}
						
					if ($NativeEthNetwork)
					{
							
						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Native Ethernet Network Uri"

						$_liUplinkSetObject | Add-Member -NotePropertyName nativeNetworkUri -NotePropertyValue $null

						$_liUplinkSetObject.nativeNetworkUri = GetNetworkUris $NativeEthNetwork $ApplianceConnection

					}

					#Validate Uplink Network Type.     
					$_liUplinkSetObject.networkType = $Type  

					if ($PSBoundParameters['EthMode'])
					{

						$_liUplinkSetObject.mode = $EthMode

					}
						
					#Rebuld uplinkset collection
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $($_resource.name) Rebuilding UplinkSet template collection."

					$_resource.uplinkSets | % {

						"[$($MyInvocation.InvocationName.ToString().ToUpper())] Saving Uplink Set object to new collection: {0}" -f $_.name | Write-Verbose

						[void]$_NewUpinkSetCol.Add($_)

					}

					[void]$_NewUpinkSetCol.Add($_liUplinkSetObject)
											
					$_resource.uplinkSets = $_NewUpinkSetCol
		
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $($_resource.name) Uplink Set object: $($_liUplinkSetObject | convertto-json -depth 99)"

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request..."

					Try
					{
							
						$resp = Send-HPOVRequest $script:uplinkSetsUri POST $_liUplinkSetObject -Hostname $_resource.ApplianceConnection.Name

						[void]$Results.Add($resp)

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

				}

				'logical-interconnect-groups'
				{

					# // todo update with C# strongly typed name
					if(-not($_resource -is [PSCustomObject]))
					{
						
						$errorRecord = New-ErrorRecord ArgumentException InvalidParameter InvalidArgument 'Resource' -Message "The -Resource parameter value provided is not a Logical Interconnect Group object.  Please check the value and try again."
						$pscmdlet.ThrowTerminatingError($errorRecord)

					}

					#Create new instance of the LIGUplinkSet Object
					$_ligUplinkSetObject = NewObject -ligUplinkSetObject

					$_ligUplinkSetObject.name      = $Name
					$_ligUplinkSetObject.lacpTimer = $LacpTimer

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Provided LIG Resource Name: $($_resource.name)"
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Provided LIG Resource Category: $($_resource.category)"
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Provided LIG Resource URI: $($_resource.uri)"

					#Get list of interconnects in LIG definition
					$ligInterconnects = $_resource.interconnectMapTemplate.interconnectMapEntryTemplates
					
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Uplink Ports: $($UplinkPorts | out-string)"

					#Loop through requested Uplink Ports
					$port              = New-Object System.Collections.ArrayList
					$uslogicalLocation = New-Object System.Collections.ArrayList

					foreach ($_p in $UplinkPorts)
					{
						    
						#Split string to get bay and port
						$_p = $_p.Split(':')
						    
						#remove bay so we just have the ID
						$bay = $_p[0].ToLower().TrimStart('bay') -replace " ",''
						    
						#Get faceplate portName
						$uplinkPort = $_p[1]
						    
						write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())]] Processing Port Bay$($bay):$($uplinkPort)"

						write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())]] Looking for Interconnect URI for Bay $($bay)"

						#Loop through Interconnect Map Entry Template items looking for the provided Interconnet Bay number
						ForEach ($l in $_resource.interconnectmaptemplate.interconnectmapentrytemplates) 
						{ 

						    $found = $l.logicalLocation.locationEntries | ? { $_.type -eq "Bay" -and $_.relativeValue -eq $bay }
													            
						    if ($found) 
							{
						                
						        $permittedIcUri = $l.permittedInterconnectTypeUri

						        write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())]] Found permitted Interconnect Type URI $($permittedIcUri) for Bay $($bay)"

						    }

						} 

						#Get Interconnect Type object in order to get relative port ID
						$_interconnecttype = Send-HPOVRequest $permittedIcUri -Hostname $_resource.ApplianceConnection.Name

						#Translate the port number
						$_portRelativeValue = ($_interconnecttype.portInfos | ? portName -eq $uplinkPort).portNumber

						#Didn't find relative port number, so generate terminating error
						if (-not($_portRelativeValue)) 
						{

						    $errorRecord = New-ErrorRecord HPOneView.UplinkSetResourceException InvalidUplinkPortID InvalidArgument 'port' -Message "The provided uplink port 'BAY$($bay):$($uplinkPort)' is an invalid port ID.  Did you mean 'X$($uplinkPort)'?  Please check the value and try again."
						    $pscmdlet.ThrowTerminatingError($errorRecord)

						}

						#Add uplink port
						$_logicalLocation = NewObject -UplinkSetLogicalLocation

						($_logicalLocation.logicalLocation.locationEntries | ? type -eq 'Bay').relativeValue = [int]$bay
						($_logicalLocation.logicalLocation.locationEntries | ? type -eq 'Port').relativeValue = [int]$_portRelativeValue

						#Create Primary Port logical location object
						if ($PrimaryPort -match $_p -and $EthMode -eq "Failover") 
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Setting Uplink Set mode to 'Failover', and Primary Port to '$PrimaryPort'"

							$_ligUplinkSetObject.primaryPortLocation | Add-Member -NotePropertyName locationEntries -NotePropertyValue (New-Object System.Collections.ArrayList)

							$_ligUplinkSetObject.mode = $EthMode

							[void]$_ligUplinkSetObject.primaryPortLocation.locationEntries.Add(
									
								(

									@{
							                
										type          = "Enclosure";
										relativeValue = 1

									},
									@{

										type          = "Bay";
										relativeValue = [int]$bay

									},
									@{

										type          = "Port";
										relativeValue = [int]$_portRelativeValue

									}

								)

							)

						}
        
						#Set FC Uplink Port Speed
						if ($Type -eq "FibreChannel") 
						{ 

							$_logicalLocation.desiredSpeed = $global:SetUplinkSetPortSpeeds[$fcUplinkSpeed] 

						}

						else 
						{ 
								
							$_logicalLocation.desiredSpeed = "Auto" 
							
						}

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding Uplink Set to LIG: $($_logicalLocation | out-string)"
						        
						[void]$_ligUplinkSetObject.logicalPortConfigInfos.Add($_logicalLocation)

					}

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Network Uris"
					
					$_NetworkUris = GetNetworkUris $Networks $ApplianceConnection

					$_NetworkUris | % {
						
						[void]$_ligUplinkSetObject.networkUris.Add($_)

					}			
						
					if ($NativeEthNetwork)
					{
							
						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Native Ethernet Network Uri"

						$_ligUplinkSetObject | Add-Member -NotePropertyName nativeNetworkUri -NotePropertyValue $null

						$_ligUplinkSetObject.nativeNetworkUri = GetNetworkUris $NativeEthNetwork $ApplianceConnection

					}

					#Validate Uplink Network Type.     
					$_ligUplinkSetObject.networkType = $UplinkSetNetworkTypeEnum[$Type]
					
					If ($Type -ne 'FibreChannel')
					{
					
						$_ligUplinkSetObject.ethernetNetworkType = $UplinkSetEthNetworkTypeEnum[$Type]
							
					}  

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $($_resource.name) Uplink Set object: $($_ligUplinkSetObject | convertto-json -depth 99)"

					#Rebuld uplinkset collection
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $($_resource.name) Rebuilding UplinkSet template collection."

					$_resource.uplinkSets | % {

						"[$($MyInvocation.InvocationName.ToString().ToUpper())] Saving Uplink Set object to new collection: {0}" -f $_.name | Write-Verbose

						[void]$_NewUpinkSetCol.Add($_)

					}

					[void]$_NewUpinkSetCol.Add($_ligUplinkSetObject)
											
					$_resource.uplinkSets = $_NewUpinkSetCol

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request..."

					Try
					{
							
						$resp = Send-HPOVRequest $_resource.uri PUT $_resource -Hostname $_resource.ApplianceConnection.Name

						[void]$Results.Add($resp)

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

				}

				#Unsupported resource category
				default
				{

					$errorRecord = New-ErrorRecord ArgumentException InvalidParameter InvalidArgument 'Resource' -TargetType 'PSObject' -Message "The Resource parameter value provided is not a Logical Interconnect Group or Logical Interconnect object.  Please check the value and try again."
					$pscmdlet.ThrowTerminatingError($errorRecord)

				}

			}

		}

	}

	End
	{

		Return $Results

	}

}

function GetNetworkUris
{
	[CmdLetBinding(DefaultParameterSetName = "Default")]
    Param 
	(

		[parameter(Mandatory, Position = 0, ParameterSetName = "Default")]
		[Array]$_Networks,

		[parameter(Mandatory, Position = 1, ParameterSetName = "Default")]
		[Object]$_ApplianceConnection

	)

	Begin
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		$_NetworkUris = New-Object System.Collections.ArrayList

	}

	Process
	{

		#Get Network URI's if values are of type String
		ForEach ($_net in $_Networks)
		{

			"[$($MyInvocation.InvocationName.ToString().ToUpper())] _net Type is {0}" -f $_net.GetType().FullName | Write-Verbose

			#Network is String and Name; call Get-HPOVNetwork
			if ($_net -is [String] -and (-not($_net.StartsWith('/rest/'))))
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Network is type String, and Network Name"

				#Get Network Object
				Try
				{

					$_net = Get-HPOVNetwork $_net -ApplianceConnection $_ApplianceConnection

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}
				
				"[$($MyInvocation.InvocationName.ToString().ToUpper())] Found Network {0} ({1})" -f $_net.name,$_net.uri | Write-Verbose 
	
				#Insert object into original arraylist
				[void]$_NetworkUris.Add($_net.uri)

			}

			elseif ($_net -is [String] -and $_net.StartsWith('/rest/'))
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Network is type String, and URI of network."

				"[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding URI to collection: {0}" -f $_net | Write-Verbose 

				[void]$_NetworkUris.Add($_net)

			}

			# // Need to change this to HPOneView.Networking.Networks.Ethernet
			elseif ($_net -is [PSCustomObject])
			{

				if (-not('HPOneView.Networking.EthernetNetwork','HPOneView.Networking.FCoENetwork','HPOneView.Networking.Networks.FibreChannelNetwork' -contains $_net.PSObject.TypeNames[0]))
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Input object is not a valid Network type."

				}
				
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Network '$($_net.name)' is [$($_net.GetType().Fullname)]"

				[void]$_NetworkUris.Add($_net.uri)

			}

		}

	}

	End
	{

		"[$($MyInvocation.InvocationName.ToString().ToUpper())] Network URIs: {0}" -f ($_NetworkUris -join ", ") | Write-Verbose

		Return $_NetworkUris
	
	}

}

#######################################################
# Server Profiles: 
#

 function Get-HPOVServerProfile 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml
    
    [CmdLetBinding(DefaultParameterSetName = "Default")]
    Param 
    (

        [parameter(ValueFromPipeline = $false, ParameterSetName = "Default", Mandatory = $false, Position = 0)]
        [parameter(ValueFromPipeline = $false, ParameterSetName = "Detailed", Mandatory = $false, Position = 0)]
        [parameter(ValueFromPipeline = $false, ParameterSetName = "Export", Mandatory = $false, Position = 0)]
        [Alias('profile')]
        [string]$name = $null,

        [parameter(ValueFromPipeline = $false, ParameterSetName = "Detailed", Mandatory = $true)]
        [switch]$detailed,

        [parameter(ValueFromPipeline = $false, ParameterSetName = "Default", Mandatory = $false)]
        [parameter(ValueFromPipeline = $false, ParameterSetName = "Export", Mandatory = $false)]
        [switch]$Unassigned,

		[parameter(Mandatory = $false)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions},
        
        [parameter(ValueFromPipeline = $false, ParameterSetName = "Export", Mandatory = $true)]
        [alias("x")]
        [switch]$export,

        [parameter(ValueFromPipeline = $false, ParameterSetName = "Export", Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [alias("save")]
        [string]$location

    )

    Begin 
    {

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

        #Validate the path exists.  If not, create it.
		if (($Export) -and (-not(Test-Path $Location)))
		{ 
        
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Directory does not exist.  Creating directory..."
            
			New-Item -path $Location -ItemType Directory
        
		}

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
            {
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
            {

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
            {

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}
        

        $uri = $script:ServerProfilesUri

        if ($name) 
        { 
               
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Received name: $($name)"
            $name = $name -replace ("[*]","%25") -replace ("[&]","%26")
            
            $uri += "?filter=name matches '$name'&sort=name:asc"
            
        }

        $ProfileCollection = New-Object System.Collections.ArrayList

	}

	Process 
    {
        
        ForEach ($_connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_connection.Name)' Appliance (of $($ApplianceConnection.Count))"

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request"

	        $profiles = Send-HPOVRequest $uri -Hostname $_connection

            if ($PSBoundParameters['Unassigned']) 
            {

                $profiles.members = $profiles.members | ? serverHardwareUri -eq $null

            }
        
            foreach ($_profile in $profiles.members)
            {
            
                $_profile.PSObject.TypeNames.Insert(0,'HPOneView.ServerProfile')
                    
                [void]$ProfileCollection.Add($_profile)
                
            }

        }

	}

    End 
    {

        "Done. {0} server profile resource(s) found." -f $ProfileCollection.count | write-verbose 

        #If a search for specific profile returns 0 results, throw a terminating error
        if(-not($ProfileCollection) -and $name)
        {

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Profile Resource Name was provided, yet no results were found.  Generate Error."

            $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException ServerProfileResourceNotFound ObjectNotFound "Name" -Message "The specified Server Profile '$name' not found. Please check the name again, and try again."
            $pscmdlet.ThrowTerminatingError($errorRecord)
            
        }

        elseif ($PSBoundParameters['Detailed']) 
        {

            #Display Pertinant Server Profile data in Table format
            $a1 = @{Expression={$_.name};Label="Name"},
                  @{Expression={$profileCache[$serverHardwareTypeUri].name};Label="Server Hardware Type"},
                  @{Expression={ if ($profileCache[$enclosureGroupUri]) {$profileCache[$enclosureGroupUri]}
								 else { 'N/A' }
								};Label="Enclosure Group"},
                  @{Expression={	if ($_.serverHardwareUri){ (Send-HPOVRequest $_.serverHardwareUri).name }
				 		        else { "Unassigned" }
				                 };Label="Assigned"},
                  @{Expression={
                  
                         switch ($_.affinity) {
                  
                             "Bay" { "Device bay" }
                             "BayAndServer" { "Device bay + Server Hardware" }
                  
                  
                         }
                  
                  };Label="Server Affinity"},
                  @{Expression={$_.state};Label="State"},
                  @{Expression={$_.status};Label="Status"}

            $a2 = @{Expression={$_.bios.manageBios};Label="Manage BIOS";align="Left"},
                  @{Expression={$_.boot.manageBoot};Label="Manage Boot Order";align="Left"},
                  @{Expression={$_.firmware.manageFirmware};Label="Manage Firmware";align="Left"},
                  @{Expression={if ($_.serialNumberType -eq "Virtual") { $_.serialNumber + " (v)" } else { $_.serialNumber + " (p)" }};Label="Serial Number"},
                  @{Expression={if ($_.serialNumberType -eq "Virtual") { $_.uuid + " (v)" } else { $_.uuid + " (p)" }};Label="UUID"}


            #Firmware Details
            $f = @{Expression={
                if ($_.firmware.manageFirmware) {

                    $baseline = Send-HPOVRequest $_.firmware.firmwareBaselineUri
                    "$($baseline.name) version $($baseline.version)"

                }
                else { "none" }
            
            };Label="Firmware Baseline"}

            $c = @{Expression={$_.id};Label="ID";width=2},
                 @{Expression={$_.functionType};Label="Type";width=12},
                 @{Expression={
                   
                   $address = @()
                 
                   #Mac Address
                   if ($_.macType -eq "Virtual" -and $_.mac) { $address += "MAC $($_.mac) (V)" }
                   elseif ($_.macType -eq "Physical" -and $_.mac) { $address += "MAC $($_.mac) (p)" }
                   
                   #WWNN
                   if ($_.wwpnType -eq "Virtual" -and $_.wwnn) { $address += "WWNN $($_.wwnn) (v)"} 
                   elseif ($_.wwpnType -eq "Physical" -and $_.wwnn) { $address += "WWNN $($_.wwnn) (p)" }
                   
                   #WWPN
                   if ($_.wwpnType -eq "Virtual" -and $_.wwpn) { $address += "WWPN $($_.wwpn) (v)"} 
                   elseif ($_.wwpnType -eq "Physical" -and $_.wwpn) { $address += "WWPN $($_.wwpn) (p)" }

                   $addressCol = $address | Out-String | % { $_ -replace '^\s+|\s+$' }
                   $addressCol
                   
                 };Label="Address";width=32},
                 @{Expression={$profileCache[$_.networkUri]};Label="Network"},
                 @{Expression={$_.portId};Label="Port Id";width=10},
                 @{Expression={[string]$_.requestedMbps};Label="Requested BW";width=12},
                 @{Expression={[string]$_.maximumMbps};Label="Maximum BW";width=10},
                 @{Expression={
                 
                      $bootSetting = @()
                      $bootSetting += $_.boot.priority
                      if ($_.boot.targets) {
                 
                           for ($i=0; $i -eq $boot.targets.count; $i++) { $bootSetting += "WWN $($_.boot.targets[$i].arrayWwpn)`nLUN $($_.boot.targets[$i].lun)" }
                 
                      }
                      $bootSettingString = $bootSetting | Out-String | % { $_ -replace '^\s+|\s+$' }
                      $bootSettingString
                 
                   
                  };Label="Boot";width=20},
                 @{Expression={
                 
                    if ($_.functionType -eq "FibreChannel" -and -not ($_.boot.targets)) { "Yes" } 
                    elseif ($_.functionType -eq "FibreChannel" -and $_.boot.targets) { "No" }
                    else { $Null }
                 
                  };Label="Use Boot BIOS";width=13}
                               
            #Display extended BIOS settings
            $b = @{Expression={$_.category};Label="BIOS Category"},
                 @{Expression={$_.settingName};Label="Setting Name"},
                 @{Expression={$_.valueName};Label="Configured Value"}

            $ls = @{Expression={$_.localStorage.manageLocalStorage};Label="Manage Local Storage";align="Left"},
                  @{Expression={$_.localStorage.initialize};Label="Initialize Disk";align="Left"},
                  @{Expression={
                  
                        $logicalDriveCol = @()
                        $d=0

                        while ($d -lt $sp.localStorage.logicalDrives.count) {

                            if ($_.localStorage.logicalDrives[$d].bootable) { $logicalDriveCol += "Drive {$d} $($sp.localStorage.logicalDrives[$d].raidLevel) (Bootable)" }
                            else { $logicalDriveCol += "Drive {$d} $($sp.localStorage.logicalDrives[$d].raidLevel)" }
                            $d++
                        }

                        $logicalDriveString = $logicalDriveCol | Out-String | % { $_ -replace '^\s+|\s+$' }
                        $logicalDriveString
                    
                   };Label="Logical Disk"}

            $ss = @{Expression={$_.manageSanStorage};Label="Manage SAN Storage";align="Left"},
                  @{Expression={$_.hostOSType};Label="Host OS Type";align="Left"}

            $p = @{Expression={[int]$_.connectionId};Label="Connection ID";align="Left"},
                 @{Expression={[string]$_.network};Label="Fabric";align="Left"},
                 @{Expression={[string]$_.initiator};Label="Initiator";align="Left"},
                 @{Expression={[string]$_.target};Label="Target";align="Left"},
                 @{Expression={[bool]$_.isEnabled};Label="Enabled";align="Left"}

            #Server Profile cache
            $profileCache = @{}
            
            #loop through all Server Profile objects and display details
            ForEach ($profile in ($ProfileCollection | sort-object -property name)) {

                $serverHardwareTypeUri = $profile.serverHardwareTypeUri
                $enclosureGroupUri = $profile.enclosureGroupUri

                #Cache resources during runtime to reduce API calls to appliance.
                if (-not ($profileCache[$serverHardwareTypeUri])) { $profileCache.Add($serverHardwareTypeUri,(Send-HPOVRequest $serverHardwareTypeUri -appliance $_.ApplianceConnection.name)) }
                if (-not ($profileCache[$enclosureGroupUri]) -and $profile.enclosureGroupUri) { $profileCache.Add($enclosureGroupUri,(Send-HPOVRequest $enclosureGroupUri -appliance $_.ApplianceConnection.name).name) }
                foreach ($connection in $profile.connections) {
                
                    $connection | % { $_.psobject.typenames.Insert(0,”HPOneView.Profile.Connection”) }

                    if (-not ($profileCache[$connection.networkUri])) { $profileCache.Add($connection.networkUri,(Send-HPOVRequest $connection.networkUri -appliance $_.ApplianceConnection.name ).name) } 
                
                }

                foreach ($volume in $profile.sanStorage.volumeAttachments) {

                    #insert HPOneView.Profile.SanVolume TypeName
                    $volume | % { $_.psobject.typenames.Insert(0,”HPOneView.Profile.SanVolume") }
	
                    #Cache Storage System, Storage Pool and Storage Volume Resources
                    if (-not ($profileCache[$volume.volumeStorageSystemUri])) { $profileCache.Add($volume.volumeStorageSystemUri,(Send-HPOVRequest $volume.volumeStorageSystemUri $_.ApplianceConnection.name)) }
                    if (-not ($profileCache[$volume.volumeStoragePoolUri])) { $profileCache.Add($volume.volumeStoragePoolUri,(Send-HPOVRequest $volume.volumeStoragePoolUri $_.ApplianceConnection.name)) }
                    if (-not ($profileCache[$volume.volumeUri])) { $profileCache.Add($volume.volumeUri,(Send-HPOVRequest $volume.volumeUri $_.ApplianceConnection.name)) }

                }

                #$profileCache

                #Initial Server Profile information
                $profile | format-table $a1 -AutoSize -wrap
                $profile | format-table $a2 -AutoSize -wrap

                #Firmware Baseline
                $profile | format-table $f

                #Server Profile Connection details
                $profile.connections | format-table -wrap
                
                #Local Storage
                $profile | format-table $ls -wrap -auto

                #SAN Storage
                $profile.sanStorage | Format-Table $ss -auto
                #$profile.sanStorage.volumeAttachments | format-table -auto

                $profile.sanStorage.volumeAttachments | % {

                    $_ | format-table -auto

                    $pathConnectionCol = @()

                    foreach ($path in $_.storagePaths) {

                        $pathObject = [PSCustomObject]@{
							connectionId = $Null; 
							network      = $Null; 
							initiator    = $Null; 
							target       = $Null; 
							isEnabled    = $Null
						}

                        $pathConnection = $profile.connections | where { $path.connectionId -eq $_.id }

                        $pathObject.connectionId = $pathConnection.id
                        $pathObject.network      = $profileCache[$pathConnection.networkUri]
                        $pathObject.initiator    = $pathConnection.wwpn
                        $pathObject.target       = if ($path.storageTargets) { $path.storageTargets }
												   else { "Pending" }
                        $pathObject.isEnabled    = [bool]$path.isEnabled
                        $pathConnectionCol += $pathObject

                    }

                    #
                    #Display path details with a left padded view. Format-Table doesn't have the ability to pad the display
                    $capture = ($pathConnectionCol | sort connectionId | format-table $p -AutoSize -wrap | out-string) -split "`n"
                    $capture | % { ($_).PadLeft($_.length + 5) }

                }

                #Boot Order
                $bootOrder = @()
                if ($profile.boot.manageBoot) {

                    $i = 0
                    while ($i -lt $profile.boot.order.count) {
                        $bootOrder += "$($i+1) $($profile.boot.order[$i])"
                        $i++
                    }
                    write-host "Boot Order"
                    write-host "----------"
                    $bootOrder

                }
                else { "No Boot Management" }

                #Display configured BIOS Settings from profile
                $configedBiosSettings = @()

                foreach ($setting in $profile.bios.overriddenSettings) {

                    $shtBiosSettingDetails = $profileCache[$serverHardwareTypeUri].biosSettings | ? { $setting.id -eq $_.id }

                    $biosSetting = [PSCustomObject]@{

                        Category = $shtBiosSettingDetails.category;
                        settingName = $shtBiosSettingDetails.name;
                        valueName = ($shtBiosSettingDetails.options | ? { $_.id -eq $setting.value } ).name;

                    }

                    $configedBiosSettings += $biosSetting
                
                }            
            
                $configedBiosSettings | sort category,settingName | format-list $b

                "----------------------------------------------------------------------"
            
            }

        }

        #If user wants to export the profile configuration
        elseif ($export) 
        {

            #Get the unique applianceConnection.name properties from the profile collection for grouping the output files
            $ProfileGroupings = $ProfileCollection.ApplianceConnection.name | Select -Unique

            ForEach ($pg in $ProfileGroupings)
            {
                
                $outputProfiles = New-Object System.Collections.ArrayList

                $profiles = $ProfileCollection | ? {$_.ApplianceConnection.Name -eq $pg}

                #Loop through all profiles
                foreach ($profile in $profiles) 
                {

                    #trim out appliance unique properties

                    $_profile = $profile | select-object -Property * -excludeproperty uri,etag,created,modified,status,state,inprogress,enclosureUri,enclosureBay,serverHardwareUri,taskUri,ApplianceConnection
                    $_profile.serialNumberType = "UserDefined"

                    #Loop through the connections to save the assigned address
                    $i = 0
                    foreach ($connection in $profile.connections) 
                    {

                        if ($profile.connections[$i].mac) { $_profile.connections[$i].macType = "UserDefined" }
                        if ($profile.connections[$i].wwpn) { $_profile.connections[$i].wwpnType = "UserDefined" }
                        $i++

                    }

                    [void]$outputProfiles.Add($_profile)
                    
                }

                #save profile to JSON file
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Saving $($_profile.name) to $($location)\$($_profile.name).json"

                convertto-json -InputObject $outputProfiles -depth 99 | new-item "$location\$pg`_$($_profile.name).json" -itemtype file

            }

        }

        else 
        {

            Return $ProfileCollection

        }

    }

 }

 function New-HPOVServerProfile 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdLetBinding(DefaultParameterSetName = "Default")]
    Param 
    (

        [parameter(Mandatory, ParameterSetName = "Default")]
        [parameter(Mandatory, ParameterSetName = "SANStorageAttach")]
		[parameter(Mandatory, ParameterSetName = "SPT")]
		[parameter(Mandatory, ParameterSetName = "SPTEmptyBay")]
		[ValidateNotNullOrEmpty()]
        [string]$Name,

        [parameter(Mandatory, ParameterSetName = "Default")]
        [parameter(Mandatory, ParameterSetName = "SANStorageAttach")]
		[ValidateSet("bay", "server", "unassigned")]
        [alias('assign')]
        [string]$AssignmentType,

        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
		[parameter(Mandatory, ParameterSetName = "SPTEmptyBay")]
        [ValidateNotNullOrEmpty()]
        [object]$Enclosure,

        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
		[parameter(Mandatory, ParameterSetName = "SPTEmptyBay")]
        [ValidateRange(1,16)]
        [Alias('bay')]
        [int32]$EnclosureBay,

        [parameter(Mandatory = $false, valuefrompipeline, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, valuefrompipeline, ParameterSetName = "SANStorageAttach")]
		[parameter(Mandatory, valuefrompipeline, ParameterSetName = "SPT")]
        [ValidateNotNullOrEmpty()]
        [object]$Server,

        [parameter(Mandatory = $false, ParameterSetName = "Default")] 
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
		[parameter(Mandatory = $false, ParameterSetName = "SPT")]
		[parameter(Mandatory = $false, ParameterSetName = "SPTEmptyBay")]
		[string]$Description = $null,

		[parameter(Mandatory, ParameterSetName = "SPT")]
		[parameter(Mandatory, ParameterSetName = "SPTEmptyBay")]
		[Object]$ServerProfileTemplate = $null,

        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
		[ValidateNotNullOrEmpty()]
        [array]$Connections = @(),

        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
		[ValidateNotNullOrEmpty()]
		[Alias('eg')]
        [object]$EnclosureGroup = $Null,

        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [ValidateNotNullOrEmpty()]
		[Alias('sht')]
        [object]$ServerHardwareType = $null,

        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [ValidateNotNullOrEmpty()]
        [switch]$Firmware,
	
        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [ValidateNotNullOrEmpty()]
        [object]$Baseline = $null,

		[parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [ValidateSet('FirmwaerOnly', 'FirmwareAndSoftware', 'FirmwareOffline')]
		[string]$FirmwareMode = 'FirmwareAndSoftware',

        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [switch]$ForceInstallFirmware,
	
        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [ValidateNotNullOrEmpty()]
        [switch]$Bios = $false,

	    [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [ValidateNotNullOrEmpty()]
        [array]$BiosSettings = @(),
        
        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]        
        [ValidateSet("UEFI","UEFIOptimized","BIOS", IgnoreCase = $False)]
        [string]$BootMode = "BIOS",

        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]        
        [ValidateSet("Auto","IPv4","IPv6","IPv4ThenIPv6","IPv6ThenIPv4", IgnoreCase = $False)]
        [string]$PxeBootPolicy = "Auto",

        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [Alias('boot')]
        [switch]$ManageBoot,

	    [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [array]$BootOrder = @(),

        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [switch]$LocalStorage,

		[parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
		[switch]$ImportLogicalDisk,

        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [switch]$Initialize,

		[parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
		[ValidateSet("HBA","RAID", IgnoreCase = $true)]
        [String]$ControllerMode,

		[parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
		[ValidateNotNullorEmpty()]
        [Object]$LogicalDisk,

		#DEPRECATED
        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]        
        [switch]$Bootable,

		#DEPRECATED
        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [ValidateSet("RAID1","RAID0","NONE", IgnoreCase=$true)]
        [string]$RaidLevel = $Null,

        [parameter(Mandatory = $True, ParameterSetName = "SANStorageAttach")]
        [switch]$SANStorage,

        [parameter(Mandatory = $true, ParameterSetName = "SANStorageAttach")]
        [ValidateSet('CitrixXen','AIX','IBMVIO','RHEL4','RHEL3','RHEL','RHEV','VMware','Win2k3','Win2k8','Win2k12','OpenVMS','Egenera','Exanet','Solaris9','Solaris10','Solaris11','ONTAP','OEL','HPUX11iv1','HPUX11iv2','HPUX11iv3','SUSE','SUSE9','Inform', IgnoreCase=$true)]
        [Alias('OS')]
        [string]$HostOStype = $Null,

        [parameter(Mandatory = $true, ParameterSetName = "SANStorageAttach")]
        [object]$StorageVolume = $Null,

        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [Alias('Even')]
        [switch]$EvenPathDisabled,

        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [Alias('Odd')]
        [switch]$OddPathDisabled,

        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [ValidateSet("Bay","BayAndServer", IgnoreCase=$false)]
        [string]$Affinity = "Bay",
	
        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [ValidateSet("Virtual", "Physical", "UserDefined", IgnoreCase=$true)]
        [string]$MacAssignment = "Virtual",

        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [ValidateSet("Virtual", "Physical", "'UserDefined", IgnoreCase=$true)]
        [string]$WwnAssignment = "Virtual",

        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [ValidateSet("Virtual", "Physical", "UserDefined", IgnoreCase=$true)]
        [string]$SnAssignment = "Virtual",

		[parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [string]$SerialNumber = $Null,

		[parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [string]$Uuid = $Null,

        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [bool]$HideUnusedFlexNics = $True,

        [parameter(Mandatory = $false, ValueFromPipelineByPropertyName)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions},

        [parameter(Mandatory = $true, ParameterSetName = "Import")]
        [switch]$Import,
        
        [parameter(Mandatory = $true, ParameterSetName = "Import", ValueFromPipeline = $true)]
        [alias("location","file")]
        [Object]$ProfileObj

    )
	
    Begin 
    {

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if ($PSBoundParameters['Bootable'])
		{

			Write-Warning 'The -Bootable parameter has been deprecated. In order to configure local storage, please read Help New-HPOVServerProfile and the LocalDisk parameter.'

		}

		if ($PSBoundParameters['RaidLevel'])
		{

			Write-Warning 'The -RaidLevel parameter has been deprecated. In order to configure local storage, please read Help New-HPOVServerProfile and the LocalDisk parameter.'

		}

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0

        ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
            {
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
            {

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
            {

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		if (-not($PSBoundParameters['ServerProfileTemplate']))
		{

			if ($snAssignment -eq "UserDefined" -and (-not($serialnumber)) -and (-not($uuid))) 
			{
		
        		$errorRecord = New-ErrorRecord HPOneview.ServerProfileResourceException InvalidArgument InvalidArgument 'snAssignment' -Message "The -snAssignment paramter was set to 'UserDefined', however both -serialnumber and -uuid are Null.  You must specify a value for both parameters."
        
				$PSCmdlet.ThrowTerminatingError($errorRecord)
		
			}
		
			elseif ($snAssignment -eq "UserDefined" -and $serialnumber -and (-not($uuid))) 
			{
		
				$errorRecord = New-ErrorRecord HPOneview.ServerProfileResourceException InvalidArgument InvalidArgument 'uuid' -Message "The -snAssignment paramter was set to 'UserDefined', however -uuid is Null.  You must specify a value for both parameters."
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			elseif ($snAssignment -eq "UserDefined" -and (-not($serialnumber)) -and $uuid) 
			{
			
				$errorRecord = New-ErrorRecord HPOneview.ServerProfileResourceException InvalidArgument InvalidArgument 'serialnumber' -Message "The -snAssignment paramter was set to 'UserDefined', however -serialnumber is Null.  You must specify a value for both parameters."
				$PSCmdlet.ThrowTerminatingError($errorRecord)
		
			}

			#Update the error information
			switch ($AssignmentType) 
			{ 

				"server" 
				{

					if (-not($server))
					{
						$errorRecord = New-ErrorRecord HPOneview.ServerProfileResourceException InvalidArgument InvalidArgument 'Server' -Message "The -AssignmentType parameter is set to 'server', but no server parameter was supplied."
						$PSCmdlet.ThrowTerminatingError($errorRecord)

					}

				}

				"bay" 
				{

					if (-not($enclosureBay))
					{

						$errorRecord = New-ErrorRecord HPOneview.ServerProfileResourceException InvalidArgument InvalidArgument 'AssignmentType' -Message "The -AssignmentType parameter is set to 'bay', but no bay parameter was supplied."
						$PSCmdlet.ThrowTerminatingError($errorRecord)

					}

					if (-not($enclosure))
					{

						$errorRecord = New-ErrorRecord HPOneview.ServerProfileResourceException InvalidArgument InvalidArgument 'AssignmentType' -Message "The -AssignmentType parameter is set to 'bay', but no Enclosure parameter was supplied."
						$PSCmdlet.ThrowTerminatingError($errorRecord)

					}

					if (-not($ServerHardwareType))
					{

						$errorRecord = New-ErrorRecord HPOneview.ServerProfileResourceException InvalidArgument InvalidArgument 'AssignmentType' -Message "The -AssignmentType parameter is set to 'bay', but no ServerHardwareType parameter was supplied."
						$PSCmdlet.ThrowTerminatingError($errorRecord)

					}

					if ($ApplianceConnection.Count -gt 1)
					{

						if($enclosure -is [string] -and $enclosure.StartsWith("/rest"))
						{

							$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidServerHardwareTypeObject InvalidArgument 'Enclosure' -Message "Enclosure as URI is not supported for multiple appliance connections."
	    	    			$PSCmdlet.ThrowTerminatingError($errorRecord)

						}

					}

				}

				"unassigned" 
				{
                
					#If the profile is not based on a template, the SHT is required
					if ((-not($PSBoundParameters['Template'])) -and (-not($PSBoundParameters['ServerHardwareType'])))
					{

						$errorRecord = New-ErrorRecord HPOneview.ServerProfileResourceException InvalidArgument InvalidArgument 'ServerHardwareType' -Message "The -AssignmentType parameter is set to 'unassigned', but no server hardware type was supplied."
						$PSCmdlet.ThrowTerminatingError($errorRecord)

					}

					if ($PSBoundParameters['Server'])
					{

						$errorRecord = New-ErrorRecord HPOneview.ServerProfileResourceException InvalidArgument InvalidArgument 'ServerHardwareType' -Message "The -AssignmentType parameter is set to 'unassigned', and a Server object/name was provided. You cannot both assign and unassign a Server Profile."
						$PSCmdlet.ThrowTerminatingError($errorRecord)

					}

				}

			}

			#Check for URI values in parameters and validate that only one appliance connection is provided in the call
			if($ApplianceConnection.Count -gt 1)
			{
            
				#SHT
				if($serverHardwareType -is [string] -and $serverHardwareType.StartsWith($script:serverHardwareTypesUri))
				{
                
					$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidServerHardwareTypeObject InvalidArgument 'New-HPOVPropfile' -Message "Server Hardware Type as URI is not supported for multiple appliance connections"
		    		$PSCmdlet.ThrowTerminatingError($errorRecord)
            
				}
            
				if($serverHardwareType -is [string] -and $serverHardwareType.StartsWith("/rest"))
				{
            
					$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidServerHardwareTypeObject InvalidArgument 'New-HPOVPropfile' -Message "Server Hardware Type as URI is not supported for multiple appliance connections."
		    		$PSCmdlet.ThrowTerminatingError($errorRecord)
            
				}

				#EG
				if(($enclosureGroup -is [string] -and $enclosureGroup.StartsWith("/rest")))
				{
            
					$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidServerHardwareTypeObject InvalidArgument 'New-HPOVPropfile' -Message "Enclosure Group as URI is not supported for multiple appliance connections."
		    		$PSCmdlet.ThrowTerminatingError($errorRecord)
            
				}

				#Server
				if ($server -is [string] -and $server.StartsWith("/rest")) 
				{
                
					$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidServerHardwareTypeObject InvalidArgument 'New-HPOVPropfile' -Message "Server as URI is not supported for multiple appliance connections."
		    		$PSCmdlet.ThrowTerminatingError($errorRecord)
            
				}

				#Baseline
				if (($baseline -is [string]) -and ($baseline.StartsWith('/rest'))) 
				{
                
					$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidServerHardwareTypeObject InvalidArgument 'New-HPOVPropfile' -Message "Baseline as URI is not supported for multiple appliance connections."
		    		$PSCmdlet.ThrowTerminatingError($errorRecord)
            
				}

				#import
				if($Import) 
				{
                
					$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidServerHardwareTypeObject InvalidArgument 'New-HPOVPropfile' -Message "Import functionality is not supported for multiple appliance connections."
		    		$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

			}

		}

        $uri = $script:ServerProfilesUri

        $colStatus = New-Object System.Collections.ArrayList

    }
	
	Process 
	{

        ForEach($_Connection in $ApplianceConnection)
		{

            #Import Server Profile JSON to appliance
            if ($PSBoundParameters['Import']) 
			{

                if (($ProfileObj -is [System.String]) -and (Test-Path $ProfileObj)) 
				{

                    #Recieved file location
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Received JSON file as input $($ProfileObj)"
                
					$serverProfile = (get-content $ProfileObj) -join "`n" | convertfrom-json
		    		
					#Remove unique values with Select-Object
		    		$serverProfile = $serverProfile | Select-Object * -Exclude uri,created,modified,eTag,ApplianceConnection

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request"
                    
					Try
					{
						
						$resp = Send-HPOVRequest $script:ServerProfilesUri POST $serverProfile -appliance $_Connection

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

                }

                #Input object could be the JSON object, which is type [System.String]
                elseif ($ProfileObj -is [System.String]) 
				{

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Received JSON resource object as input $($ProfileObj | out-string)"
                    
					$serverProfile = $ProfileObj -join "`n" | convertfrom-json

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request"
                    
					Try
					{
					
						$resp = Send-HPOVRequest $script:ServerProfilesUri POST $serverProfile -appliance $_Connection

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

                }

                #Input object is PsCustomObject of a Server Profile
                elseif ($ProfileObj -is [PsCustomObject]) 
				{

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Received JSON PsCustomObject as input $($ProfileObj | out-string)"
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request"
                    
					Try
					{

						$resp = Send-HPOVRequest $script:ServerProfilesUri POST $ProfileObj -appliance $_Connection

					}
					
					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

                }

                #Inavlid input type for $ProfileObj and Generate Terminating Error
                else 
				{ 

                    $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidImportObject InvalidArgument 'New-HPOVPropfile' -Message "Invalid `$Import input object.  Please check the object you provided for ProfileObj parameter and try again"
                    $PSCmdlet.ThrowTerminatingError($errorRecord)
                
                }

            }

			elseif ($PSBoundParameters['ServerProfileTemplate'])
			{

				#Validate ServerProfileTemplate parameter value
				switch ($ServerProfileTemplate.GetType().Name)
				{

					'PSCustomObject'
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Recieved PSCustomObject for ServerProfileTemplate."

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Recource Name: $($ServerProfileTemplate.name)"

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Recource Category: $($ServerProfileTemplate.category)"

						if ($ServerProfileTemplate.category -ne 'server-profile-templates')
						{

							$errorRecord = New-ErrorRecord HPOneView.ServerProfileTemplateResourceException InvalidServerProfileTemplateObject InvalidArgument 'ServerProfileTemplate' -TargetType 'PSObject' -Message "Invalid ServerProfileTemplate input object.    The input object category '$($ServerProfileTemplate.category)' is not the expected value 'server-profile-templates'.  Please check the value and try again."

							$PSCmdlet.ThrowTerminatingError($ErrorRecord)

						}

					}

					#Validate the String data value
					'String'
					{

						#URI's are not supported
						if ($ServerProfileTemplate.StartsWith($ServerProfileTemplatesUri))
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Resource URI recieved.  Getting resource object from API."

							Try
							{

								$ServerProfileTemplate = Send-HPOVRequest $ServerProfileTemplate -Hostname $_Connection.Name

							}

							Catch
							{

								$PSCmdlet.ThrowTerminatingError($_)

							}

						}

						else
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Resource Name recieved."

							Try
							{

								$ServerProfileTemplate = Get-HPOVServerProfileTemplate $ServerProfileTemplate -ApplianceConnection $_Connection.Name

							}

							Catch
							{

								$PSCmdlet.ThrowTerminatingError($_)

							}
							

						}

					}
					
				}

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Server Profile Template: $($ServerProfileTemplate.name)."

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Requesting new Server Profile from API."

				Try
				{

					$_NewServerProfileObj = Send-HPOVRequest ($ServerProfileTemplate.uri + "/new-profile") -Hostname $_Connection.Name

					$_NewServerProfileObj = $_NewServerProfileObj | Select * -ExcludeProperty templateCompliance,uri,serialnumber,uuid,taskUri,inProgress,state,status,modified,created,associatedServer,eTag,category

					$_NewServerProfileObj.name = $Name

					$_NewServerProfileObj.description = $Description

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

				if ($_NewServerProfileObj.connections)
				{

					$c = 0

					ForEach ($_conn in $_NewServerProfileObj.connections)
					{

						$_conn = $_conn | Select * -ExcludeProperty deploymentStatus,requestedVFs,allocatedVFs,interconnectUri,macType,wwpnType,mac,wwnn,wwpn,allocatedMbps,maximumMbps

						$_NewServerProfileObj.connections[$c] = $_conn

						$c++

					}

				}

				if ([bool]$PSBoundParameters['Server'])
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Server parameter."

					Switch ($Server.GetType().Name)
					{

						'PSCustomObject'
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server is type PSCustomObject."

							if ($Server.category -ne 'server-hardware')
							{

								$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidServerHardwareObject InvalidArgument 'Server' -TargetType 'PSObject' -Message "The Server parameter value contains an unsupported object category, '$($Server.category)'. Only objects with 'server-hardware' category are allowed.  Please correct and try again."
		    					$PSCmdlet.ThrowTerminatingError($errorRecord)

							}

						}
						
						'String'
						{

							if($Server.StartsWith($ServerHardwareUri))
							{ 

								Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server URI provided: $($Server)"
                                       
                                try 
								{

                                    $Server = Send-HPOVRequest $Server -appliance $_Connection

                                }

                                catch 
								{

		    		                $PSCmdlet.ThrowTerminatingError($_)
                                
								}

                            }

                            #server is a name
                            else
							{

                                try 
								{

                                    $Server = Get-HPOVServer $Server -appliance $_Connection
                                    
                                }

                                catch 
								{

		    		                $PSCmdlet.ThrowTerminatingError($_)

                                }

                            }

						}

					}

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server Name: $($Server.name)"

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server Uri: $($Server.uri)"

					#Throw error
					if ($Server.serverProfileUri)
					{

						$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException ServerProfileAlreadyAssigned ResourceExists 'Server' -TargetType 'PSObject' -Message "$((Send-HPOVRequest $Server.serverProfileUri).name) is already assigned to '$($Server.name)'.  Please specify a different server hardware device."

						$PSCmdlet.ThrowTerminatingError($_)

					}

					$_NewServerProfileObj.serverHardwareUri = $Server.uri

				}

				elseif ([bool]$PSBoundParameters['Enclosure'])
				{
					
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Server Profile to be assigned to ampty device bay."

					Switch ($Enclosure.GetType().Name)
					{

						'PSCustomObject'
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure is type PSCustomObject."

							if ($Enclosure.category -ne 'enclosures')
							{

								$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidEnclosureObject InvalidArgument 'Enclosure' -TargetType 'PSObject' -Message "The Enclosure parameter value contains an unsupported object category, '$($Enclosure.category)'. Only objects with 'enclosures' category are allowed.  Please correct and try again."
		    					$PSCmdlet.ThrowTerminatingError($errorRecord)

							}

						}
						
						'String'
						{

							if($enclosure.StartsWith($encosuresUri))
							{ 

								Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure URI provided: $($enclosure)"
                                       
                                try 
								{

                                    $enclosure = Send-HPOVRequest $enclosure -appliance $_Connection

                                }

                                catch 
								{

                                    $PSCmdlet.ThrowTerminatingError($_)
                                
								}

                            }

                            #enclosure is a name
                            else
							{

                                try 
								{

                                    $enclosure = Get-HPOVEnclosure $enclosure -appliance $_Connection
                                    
                                }

                                catch 
								{

		    		                $PSCmdlet.ThrowTerminatingError($_)

                                }

                            }

						}

					}

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Name: $($Enclosure.name)"
                    
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Uri: $($Enclosure.uri)"

					#Throw error that an server profile already exists
					if (($Enclosure.deviceBays | ? bayNumber -eq $EnclosureBay).profileUri)
					{

						$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException ServerProfileAlreadyAssigned ResourceExists 'Enclosure' -TargetType 'PSObject' -Message "$((Send-HPOVRequest $Enclosure.profileUri).name) is already assigned to '$(Enclosure.name), $EnclosureBay'.  Please specify a different Enclosure Bay."

						$PSCmdlet.ThrowTerminatingError($_)

					}

					elseif (($Enclosure.deviceBays | ? bayNumber -eq $EnclosureBay).coveredByProfile)
					{

						$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException ServerProfileAlreadyAssigned ResourceExists 'Enclosure' -TargetType 'PSObject' -Message "'$(Enclosure.name), $EnclosureBay' is subsumed by $((Send-HPOVRequest $Enclosure.coveredByProfile).name).  Please specify a different Enclosure Bay."

						$PSCmdlet.ThrowTerminatingError($_)

					}

                    $_NewServerProfileObj.enclosureUri      = $Enclosure.uri
                    $_NewServerProfileObj.enclosureGroupUri = $Enclosure.enclosureGroupUri
					$_NewServerProfileObj.enclosureBay      = $EnclosureBay


				}

				Try
				{

					$resp = Send-HPOVRequest $ServerProfilesUri POST $_NewServerProfileObj -Hostname $_Connection.Name

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}


			}

            #We are creating a Server Profile
            else
			{

				#New Server Resource Object
				$serverProfile = NewObject -ServerProfile
				    
				$serverProfile.name                          = $name
				$serverProfile.description                   = $description
				$serverProfile.affinity                      = $Affinity
				$serverProfile.hideUnusedFlexNics            = [bool]$hideUnusedFlexNics
				$serverProfile.bios.manageBios               = [bool]$bios
				$serverProfile.bios.overriddenSettings       = $biosSettings
				$serverProfile.boot.manageBoot               = $manageBoot.IsPresent
				$serverProfile.boot.order                    = $bootOrder
				$serverProfile.serialNumberType              = $snAssignment 
				$serverProfile.macType                       = $macAssignment
				$serverProfile.wwnType                       = $wwnAssignment
				$serverProfile.serialNumber                  = $serialnumber
				$serverProfile.uuid                          = $uuid

                if($assignmentType -eq 'bay' -and $enclosureBay)
                {

                    $serverProfile | Add-Member -NotePropertyName enclosureBay -NotePropertyValue $enclosureBay

                }
		    
		        # We are creating an unassigned server profile for profile assigned to an empty bay
                # Handle values provided for sht, eg, and enclosure
	            if ($assignmentType -eq 'unassigned' -or $assignmentType -eq 'bay') 
				{
		    	
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Profile assignmentType = $assignmentType"
		    	
		    	    #Check to see if the serverHardwareType is null, and generate error(s) then break.
		    	    if (-not($serverHardwareType))
					{

                        $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidServerHardwareTypeObject InvalidArgument 'ServerHardwareType' -Message "Server Hardware Type is missing.  Please provide a Server Hardware Type using the -sht parameter and try again."
		    		    $PSCmdlet.ThrowTerminatingError($errorRecord)

		    	    }
		    	
		    	    #If the URI is passed as the Server Hardware Type, then set the serverHardwareTypeUri variable
		    	    If ($serverHardwareType -is [string])
					{

		    		    if ($serverHardwareType.StartsWith($script:serverHardwareTypesUri))
						{ 
                            
                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] SHT URI Provided: $serverHardwareType" 

                            $serverProfile.serverHardwareTypeUri = $serverHardwareType

							Try
							{
							
								$serverHardwareType = Send-HPOVRequest $serverHardwareType -appliance $_Connection
							
							}
                            
                            Catch
							{

								$PSCmdlet.ThrowTerminatingError($_)

							}

                        }
		    		
		    		    #Otherwise, perform a lookup ofthe SHT based on the name
		    		    else 
						{

                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] SHT Name Provided: $serverHardwareType"

		    			    $serverHardwareType = Get-HPOVServerHardwareType -name $serverHardwareType -appliance $_Connection

                            if ($serverHardwareType) 
							{

								Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] SHT URI: $serverHardwareTypeUri"

		    			        $serverProfile.serverHardwareTypeUri = $serverHardwareType.uri

                            }

                            else 
							{

                                $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidServerHardwareTypeParameter InvalidArgument 'ServerHardwareType' -Message "The -ServerHardwareType parameter value is invalid.  Please make sure it is a Name, URI or resource Object."
                                $PSCmdlet.ThrowTerminatingError($errorRecord)

                            }

		    		    }

		    	    }

		    	    #Else the SHT object is passed
		    	    elseif ($serverHardwareType)
					{ 

                        #Get the SHT for just this connection if multiple are passed via Get-HPOVServerHardwareType
                        #$serverHardwareType = $serverHardwareType | ? {$_.ApplianceConnection.name -eq $_Connection.name}
                        ForEach ($sht in $serverHardwareType)
						{

                            if($sht.ApplianceConnection.name -eq $_Connection.name)
							{

                                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] ServerHardwareType object provided"

                                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] ServerHardwareType Name: $($sht.name)"

                                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] ServerHardwareType Uri: $($sht.uri)"

                                $serverProfile.serverHardwareTypeUri = $sht.uri

                            }
						
						}
                        
                    }

                    if (-not($enclosureGroup) -and (-not($serverHardwareType.model -match "DL")) -and $assignmentType -eq 'unassigned')
					{
		    			    
                        $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidEnclosureGroupObject InvalidArgument 'EnclosureGroup' -Message "Enclosure Group is missing.  Please provide an Enclosure Group using the -eg parameter and try again."
		    		    $PSCmdlet.ThrowTerminatingError($errorRecord)

                    }

                    elseif ($enclosureGroup -is [string])
					{

		    		    #If the URI is passed as the Enclosure Group, then set the enclosureGroupUri variable
		    		    if ($enclosureGroup.StartsWith('/rest'))
						{ 
							
							$serverProfile.enclosureGroupUri = $enclosureGroup
						
						}

		    		    #Otherwise, perform a lookup ofthe Enclosure Group
		    		    else
						{

							Try
							{

								$enclosureGroup = Get-HPOVEnclosureGroup -name $enclosureGroup -appliance $_Connection

							}
		    			    
							Catch
							{

								$PSCmdlet.ThrowTerminatingError($_)

							}

                            "[$($MyInvocation.InvocationName.ToString().ToUpper())] EG URI: $enclosureGroupUri {0}" -f $enclosureGroup.uri | Write-Verbose
                            
							$serverProfile.enclosureGroupUri = $enclosureGroup.uri
		    			    
		    		    }

		    	    }
		    				
		    	    #Else the EG object is passed
		    	    elseif (($enclosureGroup -is [Object]) -and ($enclosureGroup.category -eq "enclosure-groups")) 
					{ 

                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Group object provided"
                        "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Group Name: {0}" -f $enclosureGroup.name | Write-Verbose
                        "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Group Uri: {0}" -f $enclosureGroup.uri | Write-Verbose

                        $serverProfile.enclosureGroupUri = ($enclosureGroup | ? {$_Connection.name -eq $_.applianceConnection.name}).uri 

                    }

                    elseif (-not $enclosureGroup -and ($serverHardwareType.model -match "DL")) 
					{

                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server is a ProLiant DL model. Enclosure Group not required."

                    }

                    #EG param not required if assignment is to a bay
                    elseif (-not($enclosureGroup) -and ($assignmentType -eq 'bay'))
                    {

                        #First check for $enclosure param
                        if (-not($enclosure))
						{

                            $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidEnclosureObject InvalidArgument 'Enclosure' -Message "Enclosure is missing.  Please provide an Enclosure using the -enclosure parameter and try again."
		    		        $PSCmdlet.ThrowTerminatingError($errorRecord)

                        }
                        
                        #Retrieve the enclosure group uri from passed in enclosure uri param
                        elseif($enclosure -is [string]) 
						{
                            
                            if($enclosure.StartsWith('/rest'))
							{ 
                                       
                                try 
								{

                                    $enclosure = Send-HPOVRequest $enclosure -appliance $_Connection

                                }

                                catch 
								{

                                    $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidEnclosureGroupObject InvalidArgument 'Enclosure' -Message "Enclosure is missing.  Please provide an Enclosure using the -enclosure parameter and try again."
		    		                $PSCmdlet.ThrowTerminatingError($errorRecord)
                                
								}

                            }

                            #enclosure is a name
                            else
							{

                                try 
								{

                                    $enclosure = Get-HPOVEnclosure $enclosure -appliance $_Connection
                                    
                                }

                                catch 
								{

                                    $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidEnclosureGroupObject InvalidArgument 'Enclosure' -Message "Enclosure is missing.  Please provide an Enclosure using the -enclosure parameter and try again."
		    		                $PSCmdlet.ThrowTerminatingError($errorRecord)

                                }

                            }

                        }

                        elseif($enclosure -is [object] -and $enclosure.category -match 'enclosures')
						{

							$enclosure = $enclosure | ? { $_.ApplianceConnection.Name -eq $_Connection.name }

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Group Name: $($enclosure.name)"
                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Group Uri: $($enclosure.enclosureGroupUri)"
                            
                            #ForEach($e in $enclosure)
							#{
							#
                            #    if ($e.ApplianceConnection.name -eq $_Connection.name)
							#	{
							#
                            #        $serverProfile.enclosureUri      = $e.uri
                            #        $serverProfile.enclosureGroupUri = $e.enclosureGroupUri
							#
                            #        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Group Name: $($e.name)"
                            #        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Group Uri: $($e.enclosureGroupUri)"
							#
                            #    }
                            #     
                            #}

                        }

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Group Name: $($enclosure.uri)"

                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Group Uri: $($enclosure.enclosureGroupUri)"

                        $serverProfile.enclosureUri      = $enclosure.uri
                        $serverProfile.enclosureGroupUri = $enclosure.enclosureGroupUri
						$serverProfile.enclosureBay      = $EnclosureBay
                             
                    } 
          
                    else 
					{ 

                        $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidEnclosureGroupObject InvalidArgument 'EnclsoureGroup' -TargetType $EnclosureGroup.GetType().Name -Message "Enclosure Group is invalid.  Please specify a correct Enclosure Group name, URI or object and try again."

                        #Generate Terminating Error
		    		    $PSCmdlet.ThrowTerminatingError($errorRecord)
                        
                    }

	            }
	
		        # Creating an assigned profile
		        else 
				{
		    	
		    	    #Looking for the $server DTO to be string
		    	    if ($server -is [string]) 
					{
		    		
		    		    #If the server URI is passed, look up the server object
		    		    if ($server.StartsWith($ServerHardwareUri)) 
						{

		    			    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server URI passed: $server"
		    				
							Try
							{
							
								[object]$server = Send-HPOVRequest $server -appliance $_Connection
							
							}
							
							Catch
							{

								$PSCmdlet.ThrowTerminatingError($_)

							}

		    		    }
		    		
		    		    #Else the name is passed and need to look it up.
		    		    else
						{

							Try
							{

								[object]$server = Get-HPOVServer -name $server -appliance $_Connection

							}
		    			
							Catch
							{
								
								$PSCmdlet.ThrowTerminatingError($_)	
								
							}		    
                        
		    		    }

		    	    }
		    	
		    	    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server Object: $($server | out-string)"

		    	    #Check to make sure the server NoProfileApplied is true
		    	    if (-not($server.serverProfileUri))
					{

		    		    $serverProfile.serverHardwareUri     = $server.uri
		    		    $serverProfile.serverHardwareTypeUri = $server.serverHardwareTypeUri
		    		    
                        #Handle Blade Server objects
                        if ($server.serverGroupUri) 
						{ 
							
							$serverProfile.enclosureGroupUri = $server.serverGroupUri 
						
						}

		    	    }

		    	    else 
					{

                        $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException ServerProfileAlreadyAssigned ResourceExists 'New-HPOVServerProfile' -Message "$((Send-HPOVRequest $server.serverProfileUri).name) already has a profile assigned, '$($serverProfile.name)'.  Please specify a different Server Hardware object."
		    		    $pscmdlet.ThrowTerminatingError($errorRecord)

		    	    }

                    #Get the SHT of the SH that we are going to assign.
					Try
					{

						$serverHardwareType = Send-HPOVRequest $server.serverHardwareTypeUri -appliance $_Connection

					}
                    
					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

		        }

                #Handle DL Server Profiles by setting BL-specific properties to NULL
                if ($serverHardwareType.model -match "DL") 
				{

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server Hardware Type is a DL, setting 'macType', 'wwnType', 'serialNumberType', 'affinity' and 'hideUnusedFlexNics' to Null."

                    $serverProfile.macType            = $Null
                    $serverProfile.wwnType            = $Null
                    $serverProfile.serialNumberType   = $Null
                    $serverProfile.hideUnusedFlexNics = $Null
                    $serverProfile.affinity           = $Null

                }

				#User provided UEFI or UEFIOptimized for a non-Gen9 platform.
				if ((-not($BootMode -eq "BIOS")) -and (-not($ServerHardwareType.model -match "Gen9"))) 
				{

                    $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException BootModeNotSupported InvalidArgument 'BootMode' -Message "The -bootMode parameter was provided and the Server Hardware model '$($serverHardwareType.model)' does not support this parameter.  Please verify the Server Hardware Type is at least an HPE ProLiant Gen9."
		    		$pscmdlet.ThrowTerminatingError($errorRecord)    

                }

                #Handle Boot Order and BootManagement
				switch ($ServerHardwareType.model)
				{
					
					{$_ -match 'Gen7' -or $_ -match 'Gen8'}
					{

						if (-not($PSboundParameters['BootOrder']) -and $ManageBoot)
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No boot order provided for Gen8 Server resource type.  Defaulting to ‘CD’,’Floppy’,’USB’,’HardDisk’,’PXE’"

							[System.Collections.ArrayList]$serverProfile.boot.order = (‘CD’,’Floppy’,’USB’,’HardDisk’,’PXE’)

						}

					}

					{$_ -match 'Gen9'}
					{

						"[$($MyInvocation.InvocationName.ToString().ToUpper())] Gen 9 Server, setting BootMode to: {0}" -f $BootMode | Write-Verbose 

						switch ($BootMode) 
						{

						    "BIOS" 
							{
						    
						        $serverProfile.bootMode = [PSCustomObject]@{
						            manageMode = $true;
						            mode       = $BootMode;
						        }
						    
						    }

						    { "UEFI","UEFIOptimized" -match $_ } 
							{
						    
						        $serverProfile.bootMode = [PSCustomObject]@{
						            manageMode    = $true;
						            mode          = $BootMode;
						            pxeBootPolicy = $PxeBootPolicy
						        }
						    
						    }

						}

						"[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Gen 9 Server BootOrder settings." | Write-Verbose 

						if ($ManageBoot -and ($BootOrder -contains "Floppy") -and ($BootMode -match "UEFI"))
						{
		    				
							$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidUEFIBootOrderParameterValue InvalidArgument 'BootOrder' -TargetType 'Array' -Message	"The -BootOrder parameter contains 'Floppy' which is an invalid boot option for a UEFI-based system."
		    				$pscmdlet.ThrowTerminatingError($errorRecord)

						}

						elseif ((-not ($PSBoundParameters["BootOrder"])) -and $ManageBoot -and (-not($BootMode -match 'UEFI'))) 
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No boot order provided for Gen9 Server resource type.  Defaulting to ‘CD’,’USB’,’HardDisk’,’PXE’"

							[System.Collections.ArrayList]$serverProfile.boot.order = @(‘CD’,’USB’,’HardDisk’,’PXE’)
                
						}

						elseif ((-not ($PSBoundParameters["BootOrder"])) -and $ManageBoot -and ($BootMode -match 'UEFI') -and ($serverHardwareType.model -match 'BL'))
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No boot order provided for BL Gen9 Server resource type.  Defaulting to ’HardDisk’."

							[System.Collections.ArrayList]$serverProfile.boot.order = @(’HardDisk’)
                
						}

						elseif (($BootOrder.count -gt 1) -and $ManageBoot -and ($BootMode -match 'UEFI') -and ($serverHardwareType.model -match 'BL'))
						{

							$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidUEFIBootOrderParameterValue InvalidArgument 'BootOrder' -TargetType 'Array' -Message	("The -BootOrder parameter contains more than 1 entry, and the system BootMode is set to {0}, which is invalud for a UEFI-based system.  Please check the -BootOrder parameter and make sure either 'HardDisk' or 'PXE' are the only option." -f $BootMode)
		    				$pscmdlet.ThrowTerminatingError($errorRecord)
                
						}

						elseif ($BootOrder -and $ManageBoot -and ($BootMode -match 'UEFI') -and ($serverHardwareType.model -match 'DL'))
						{

							$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidUEFIBootOrderParameterValue InvalidArgument 'BootOrder' -TargetType 'Array' -Message	("The -BootOrder parameter is not supported with DL Gen9 servers when BootMode is also set to {0}. Either change the BootMode to 'BIOS' or remove the -BootOrder parameter." -f $BootMode)
		    				$pscmdlet.ThrowTerminatingError($errorRecord)
                
						}

						else
						{

							"[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding provided BootOrder {0} to Server Profile object." -f ($BootOrder -join ', ') | Write-Verbose 

							[System.Collections.ArrayList]$serverProfile.boot.order = $BootOrder

						}

					}

				}

				#Exmamine the profile connections parameter and pull only those connections for this appliance connection
				If ($Connections -and (-not($serverHardwareType.model -match "DL")))
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting available Network resources based on SHT and EG."

					#Get avaialble Networks based on the EG and SHT
					$_AvailableNetworksUri = $ServerProfilesAvailableNetworksUri + '?serverHardwareTypeUri={0}&enclosureGroupUri={1}' -f $ServerHardwareType.uri,$EnclosureGroup.uri

					Try
					{

						$_AvailableNetworkResources = Send-HPOVRequest $_AvailableNetworksUri -Hostname $_Connection.Name

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

					ForEach($c in $connections)
					{

						$Message = $null

						#Remove connection parameters no permitted in Template
						$c = $c | Select-Object -property * -ExcludeProperty ApplianceConnection

						switch (($c.networkUri.Split('\/'))[2])
						{

							'ethernet-networks'
							{
						
								if (-not($_AvailableNetworkResources.ethernetNetworks | ? uri -eq $c.networkUri))
								{

									$Message = "The Ethernet network {0} specified in Connection {1} was not found to be provisioned to the provided Enclosure Group, {2}, and SHT, {3}.  Please verify that the network is a member of an Uplink Set in the associated Logical Interconnect Group." -f (Send-HPOVRequest $c.networkUri -Hostname $_connection.Name).name, $c.id, $EnclosureGroup.name, $ServerHardwareType.name

								}

								else
								{

									"[$($MyInvocation.InvocationName.ToString().ToUpper())] {0} is available for Connection {1} in this SPT." -f $c.networkUri, $c.id | Write-Verbose 

								}
						
							}

							'network-sets'
							{
						
								if (-not($_AvailableNetworkResources.networkSets | ? uri -eq $c.networkUri))
								{

									$Message = "The network set {0} specified in Connection {1} was not found to be provisioned to the provided Enclosure Group, {2}, and SHT, {3}.  Please verify that the network is a member of an Uplink Set in the associated Logical Interconnect Group." -f (Send-HPOVRequest $c.networkUri -Hostname $_connection.Name).name, $c.id, $EnclosureGroup.name, $ServerHardwareType.name

								}
						
								else
								{

									"[$($MyInvocation.InvocationName.ToString().ToUpper())] {0} is available for Connection {1} in this SPT." -f $c.networkUri, $c.id | Write-Verbose 

								}

							}

							'fc-networks'
							{
						
								if (-not($_AvailableNetworkResources.fcNetworks | ? uri -eq $c.networkUri))
								{

									$Message = "The FC network {0} specified in Connection {1} was not found to be provisioned to the provided Enclosure Group, {2}, and SHT, {3}.  Please verify that the network is a member of an Uplink Set in the associated Logical Interconnect Group." -f (Send-HPOVRequest $c.networkUri -Hostname $_connection.Name).name, $c.id, $EnclosureGroup.name, $ServerHardwareType.name

								}
						
								else
								{

									"[$($MyInvocation.InvocationName.ToString().ToUpper())] {0} is available for Connection {1} in this SPT." -f $c.networkUri, $c.id | Write-Verbose 

								}

							}

							'fcoe-networks'
							{
						
								if (-not($_AvailableNetworkResources.fcNetworks | ? uri -eq $c.networkUri))
								{

									$Message = "The FCoE network {0} specified in Connection {1} was not found to be provisioned to the provided Enclosure Group, {2}, and SHT, {3}.  Please verify that the network is a member of an Uplink Set in the associated Logical Interconnect Group." -f (Send-HPOVRequest $c.networkUri -Hostname $_connection.Name).name, $c.id, $EnclosureGroup.name, $ServerHardwareType.name

								}
						
								else
								{

									"[$($MyInvocation.InvocationName.ToString().ToUpper())] {0} is available for Connection {1} in this SPT." -f $c.networkUri, $c.id | Write-Verbose 

								}
						
							}

						}

						if ($Message)
						{

							$ErrorRecord = New-ErrorRecord HPOneView.ServerProfileConnectionException NetworkResourceNotProvisioned InvalidArgument 'Connections' -TargetType 'PSObject' -Message $Message
		    				$PSCmdlet.ThrowTerminatingError($errorRecord)  

						}
					
						[void]$serverProfile.connections.Add($c)
			    
					}
			
				}

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $($_spt.connections | FL * -force | Out-String)"
                
		    	$BootableConnections = New-Object System.Collections.ArrayList

                #Loop through connections to look for bootable settings and if -manageboot is omitted from $PSBoundParameters
                foreach ($connection in $serverProfile.connections) 
				{
		    		
		    		if ($connection.boot.priority -ne "NotBootable") 
					{

		    			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Found bootable connection ID '$($connection.id)'"

		    			[void]$BootableConnections.Add($connection.id)

		    		}

		    	}

		    	if ((-not($manageBoot.IsPresent)) -and $BootableConnections.count -gt 0) 
				{

		    		$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException BootableConnectionsFound InvalidArgument 'manageBoot' -Message "Bootable Connections $($BootableConnections -join ",") were found, however the -manageBoot switch parameter was not provided.  Please correct your command syntax and try again."
		    		$pscmdlet.ThrowTerminatingError($errorRecord)  

		    	} 

                #Check to make sure Server Hardware Type supports Firmware Management (OneView supported G7 blade would not support this feature)
                if ($firmware) 
				{
                    
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Firmware Baseline $($baseline)"

                    if ($serverHardwareType.capabilities -match "firmwareUpdate" ) 
					{

						$serverProfile.firmware.manageFirmware       = [bool]$firmware
						$serverProfile.firmware.forceInstallFirmware = [bool]$forceInstallFirmware
						$serverProfile.firmware.firmwareInstallType  = $FirmwareControlModeEnum[$FirmwareMode]

                        #Validating that the baseline value is a string type and that it is an SPP name.
		                if (($baseline -is [string]) -and (-not ($baseline.StartsWith('/rest'))) -and ($baseline -match ".iso")) 
						{
                            
							try 
							{
		    	                
								$baseline = Get-HPOVBaseline -isoFileName $baseline -appliance $_Connection
		    	                
								$serverProfile.firmware.firmwareBaselineUri = $baseline.uri
                            
							}

                            catch 
							{
                                
								Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Error caught when looking for Firmware Baseline."
                                
								$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidBaselineResourceName ObjectNotFound  'Basline' -Message "The provided SPP Baseline '$($baseline)' was not found or an error occurred during lookup."
		    		            
								$pscmdlet.ThrowTerminatingError($errorRecord)
                            
							}
		                
						}

                        #Validating that the baseline value is a string type and that it is an SPP name.
		                elseif (($baseline -is [string]) -and (-not ($baseline.StartsWith('/rest')))) 
						{

                            try 
							{

		    	                $baseline = Get-HPOVBaseline -SppName $baseline -appliance $_Connection
		    	                $serverProfile.firmware.firmwareBaselineUri = $baseline.uri

                            }

                            catch 
							{

                                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Error caught when looking for Firmware Baseline."

                                $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidBaselineResourceUri ObjectNotFound 'Basline' -Message "The provided SPP Baseline '$($baseline)' was not found or an error occurred during lookup."
		    		            $pscmdlet.ThrowTerminatingError($errorRecord)

                            }

		                }
                
                        #Validating that the baseline value is a string type and that it is the Basline URI
		                elseif (($baseline -is [string]) -and ($baseline.StartsWith('/rest'))) 
						{
		    	    
		    	            $baselineObj = Send-HPOVRequest $baseline -appliance $_Connection

                            if ($baselineObj.category -eq "firmware-drivers") 
							{
		    	            
                                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Valid Firmware Baseline provided: $($baselineObj.baselineShortName)"

                                $serverProfile.firmware.firmwareBaselineUri = $baselineObj.uri 
                            
                            }

                            else 
							{

                                $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidBaselineResource ObjectNotFound 'Basline' -Message "The provided SPP Baseline URI '$($baseline)' is not valid or the correct resource category (expected 'firmware-drivers', received '$($baselineObj.category)'.  Please check the -baseline parameter value and try again."
		    		            $pscmdlet.ThrowTerminatingError($errorRecord)

                            }

		                }

                        #Else we are expecting the SPP object that contains the URI.
                        elseif (($baseline) -and ($baseline -is [object])) 
						{

                            $serverProfile.firmware.firmwareBaselineUri = $baseline.uri
                        
                        }

                        elseif (!$baseline) 
                        {
                            $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException ServerHardwareMgmtFeatureNotSupported NotImplemented 'New-HPOVServerProfile' -Message "Baseline is required when manage firmware is set to true."
		    		        $pscmdlet.ThrowTerminatingError($errorRecord)
                        }

                    }

                    else 
					{

                        $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException ServerHardwareMgmtFeatureNotSupported NotImplemented 'New-HPOVServerProfile' -Message "`"$($serverHardwareType.name)`" Server Hardware Type does not support Firmware Management."
		    		    $pscmdlet.ThrowTerminatingError($errorRecord)
                        
                    }

                }

                #Check to make sure Server Hardware Type supports Bios Management (OneView supported G7 blade do not support this feature)
                if ($PSBoundParameters['bios']) 
				{

					if ([bool]($bl460bios | Measure-Object).count) 
					{
		    			
						$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException BiosSettingsIsNull InvalidArgument 'biosSettings' -TargetType 'Array' -Message "BIOS parameter was set to TRUE, but no biosSettings were provided.  Either change -bios to `$False or provide valid bioSettings to set within the Server Profile."
		    			$pscmdlet.ThrowTerminatingError($errorRecord)
		    		
					}

		    		else 
					{
                    
						if ($serverHardwareType.capabilities -match "ManageBIOS" ) 
						{
							 

							#check for any duplicate keys
						    $biosFlag = $false
						    $hash = @{}
						    $biosSettings.id | % { $hash[$_] = $hash[$_] + 1 }

						    foreach ($biosItem in ($hash.GetEnumerator() | ? {$_.value -gt 1} | % {$_.key} )) 
							{
						         
						        $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException BiosSettingsNotUnique InvalidOperation 'BiosSettings' -TargetType 'Array' -Message "'$(($serverHardwareType.biosSettings | where { $_.id -eq $biosItem }).name)' is being set more than once. Please check your BIOS Settings are unique.  This setting might be a dependency of another BIOS setting/option.  Please check your BIOS Settings are unique.  This setting might be a dependency of another BIOS setting/option."
		    			        $pscmdlet.ThrowTerminatingError($errorRecord)

						    }

						}

						else 
						{ 

						    $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException ServerHardwareMgmtFeatureNotSupported NotImplemented 'New-HPOVServerProfile' -Message "`"$($serverHardwareType.name)`" Server Hardware Type does not support BIOS Management."
		    			    $pscmdlet.ThrowTerminatingError($errorRecord)                
		    			
						}
						
					}

				}

                #Set Local Storage Management and Check to make sure Server Hardware Type supports it (OneView supported G7 blade would not support this feature)
                if (($LocalStorage) -and ($serverHardwareType.capabilities -match "ManageLocalStorage" )) 
				{
                
					$_LocalStorageConfig = NewObject -ServerProfileLocalStorage

					$_LocalStorageConfig.managed    = [bool]$LocalStorage

					if ($PSBoundParameters['ImportLogicalDisk'] -and $PSBoundParameters['LogicalDisk'])
					{

						$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidImportLogicalDiskParameter InvalidOperation 'ImportLogicalDisk' -Message "You cannot set the LogicalDisk policy to 'ImportLogicalDisk' using the -ImportLogicalDisk and specify a Logical Disk configuration policy with the -LogicalDisk parameter.  Please specify one of those parameters and try your command again."
						$pscmdlet.ThrowTerminatingError($errorRecord)

					}

					elseif ($PSBoundParameters['ImportLogicalDisk'] -and $PSBoundParameters['Initialize'])
					{

						$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidImportLogicalDiskParameter InvalidOperation 'ImportLogicalDisk' -Message "You cannot set the LogicalDisk policy to 'ImportLogicalDisk' using the -ImportLogicalDisk and specify the -Initialize parameter.  Please specify one of those parameters and try your command again."
						$pscmdlet.ThrowTerminatingError($errorRecord)

					}

					if ($PSBoundParameters['ImportLogicalDisk'])
					{

						$_LocalStorageConfig.importConfiguration = $true

					}

					else
					{

						$_LocalStorageConfig.initialize = [bool]$Initialize

						[void]$_LocalStorageConfig.logicalDrives.Add($LogicalDisk)

					}

					[void]$serverProfile.localStorage.controllers.Add($_LocalStorageConfig)
                     
                }
		        
                #StRM Support
                if ([bool]$SANStorage -and $serverHardwareType.model -match "BL") 
				{ 

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] SAN Storage being requested"
                
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting list of available storage systems"

                    #Get list of available storage system targets and the associated Volumes based on the EG and SHT provided
                    
					Try
					{

						$availStorageSystems = (Send-HPOVRequest ($script:profileAvailStorageSystemsUri + "?enclosureGroupUri=$($serverProfile.enclosureGroupUri)&serverHardwareTypeUri=$($serverHardwareType.uri)") -appliance $_Connection).members

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}
					

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Available Storage Systems: $($availStorageSystems | fl | out-string)"

                    #Error on no available storage systems
                    if (-not ($availStorageSystems)) 
					{

                        $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException NoAvailableStorageSystems ObjectNotFound 'SANStorage' -Message "No available storage systems found for '$($serverHardwareType.name)' Server Hardware Type and '$((Send-HPOVRequest $serverProfile.enclosureGroupUri).name)' Enclosure Group.  Please verify an available Storage System exists, and has connectivity to the destination server or Enclosure Group."
		    		    $pscmdlet.ThrowTerminatingError($errorRecord)  

                    }
                    
                    $serverProfile.sanStorage = [pscustomobject]@{
                        
						hostOSType        = $script:profileSanManageOSType.($HostOsType);
                        manageSanStorage  = [bool]$SANStorage;
                        volumeAttachments = New-Object System.Collections.ArrayList
                    
					}
                    
                    #Copy the parameter array into a new object
                    $volumesToAttach = New-Object System.Collections.ArrayList
					$StorageVolume | % { 
						
						[void]$volumesToAttach.Add($_)
							
					}
                    
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Volumes to process $($StorageVolume | fl | out-string)"
                    
                    $i = 0
                    
                    #Process volumes being passed
                    foreach ($volume in $StorageVolume) 
					{  

                        #If the storage paths array is null, process connections to add mapping
                        if (-not ($volume.storagePaths)) 
						{

                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Storage Paths value is Null. Building connection mapping."

                            #Static Volume, must have volumeUri attribute present to be valid
                            if ($volume.volumeUri) 
							{

                                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting list of attachable volumes"

                                #Get list of attachable Volumes (i.e. they are not assigned private or are shareable volumes)
								Try
								{

									$attachableVolumes = (Send-HPOVRequest $script:attachableVolumesUri -appliance $_Connection).members

								}

								Catch
								{

									$PSCmdlet.ThrowTerminatingError($_)

								}

								#Get storage volume name for reporting purposes
								Try
								{

									$volumeName = (send-hpovrequest $volume.volumeUri -appliance $_Connection).name

								}
                                
                                Catch
								{

									$PSCmdlet.ThrowTerminatingError($_)

								}

                                "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Volume ID: {0}" -f $volume.id  | Write-Verbose 
                                "[$($MyInvocation.InvocationName.ToString().ToUpper())] Looking to see if volume '{0} ({1})' is attachable" -f $volume.volumeUri,$volumeName |Write-Verbose 
                    						   
                                #validate volume is attachable
                                $attachableVolFound = $attachableVolumes | ? uri -eq $volume.volumeUri

                                #If it is available, continue processing
                                if ($attachableVolFound) 
								{
                    
                                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] '$($attachableVolFound.uri) ($($attachableVolFound.name))' volume is attachable"
                    
                                    #validate the volume that is available, is also avialable to the server hardware type and enclosure group
                                    $volumeToStorageSystem = $availStorageSystems | ? { $_.storageSystemUri -eq $attachableVolFound.storageSystemUri }
                    
                                    #If available, process the volume networks
                                    if ($volumeToStorageSystem) 
									{ 
                                    
                                        #Check to make sure profile connections exist.
                                        if ($serverProfile.connections -and $serverProfile.connections.functionType -contains "FibreChannel") 
										{

                                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Profile has connections"
                                        
                                            #loop through profile connections
                                            $found = 0

                                            foreach ($volConnection in $attachableVolFound.availableNetworks) 
											{

                                                #write-verbose "Looking for $volConnection"
                                                $profileConnection = $serverProfile.connections | ? { $_.networkUri -eq $volConnection }

                                                if ($profileConnection) 
												{

                                                    #Keep track of the connections found for error reporting later
                                                    $found++

                                                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Mapping connection ID '$($profileConnection.id)' -> volume ID '$($volumesToAttach[$i].id)'"
                                                
                                                    $_StoragePath = NewObject -StoragePath

													$_StoragePath.connectionId = $profileConnection.id
													$_StoragePath.isEnabled = $True

													[void]$volume.storagePaths.Add($_StoragePath)

                                                }

                                            }

                                            if (-not ($found)) 
											{

                                                #Generate non-terminating error and continue
                                                $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException NoProfileConnectionsMapToVolume ObjectNotFound 'New-HPOVServerProfile' -Message "Unable to find a Profile Connection that will map to '$($volumeName)'. Creating server profile resource without Volume Connection Mapping." 
 
                                                $PSCmdlet.WriteError($errorRecord)

                                            }
                                        
                                        }

                                        #Else, generate an error that at least one FC connection must exist in the profile in order to attach volumes.
                                        else 
										{

                                            $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException NoProfileConnections ObjectNotFound 'New-HPOVServerProfile' -Message "The profile does not contain any Network Connections.  The Profile must contain at least 1 FC Connection to attach Storage Volumes.  Use the New-HPOVServerProfileConnection helper cmdlet to create 1 or more connections and try again." 
                                            $PSCmdlet.ThrowTerminatingError($errorRecord)

                                        }
                    
                                    }
                    
                                    #If not, then error
                                    elseif (-not($volumeToStorageSystem)) 
									{ 
                                
                                        $errorRecord = New-ErrorRecord InvalidOperationException StorageVolumeDoesNotExistOnStorageArray ObjectNotFound 'New-HPOVServerProfile' -Message "'$($volumeName)' Volume is not available on the '$($volumeToStorageSystem.storageSystemName)' storage system"
                                        $PSCmdlet.ThrowTerminatingError($errorRecord)                      
                                
                                    }
                    
                                }
                    
                                elseif (-not ($attachableVolFound)) 
								{ 
                            
                                    $errorRecord = New-ErrorRecord InvalidOperationException StorageVolumeUnavailableForAttach ResourceUnavailable 'New-HPOVServerProfile' -Message "'$($volumeName)' Volume is not available to be attached to the profile. Please check the volume and try again." 
                                    $PSCmdlet.ThrowTerminatingError($errorRecord)

                                }

                            }

                            #Ephemeral volume support
                            elseif (-not ($volume.volumeUri) -and $volume.volumeStoragePoolUri -and $volume.volumeStorageSystemUri) 
							{

                                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No volumeUri, ephemeral volume request."

                                #Check to make sure profile connections exist.
                                if ($serverProfile.connections -and $serverProfile.connections.functionType -contains "FibreChannel") 
								{

                                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Profile has connections"

                                    #Process available storage system and available FC networks
                                    $storageSystemVolCreate = $availStorageSystems | ? storageSystemUri -eq $volume.volumeStorageSystemUri

                                    if ($storageSystemVolCreate) 
									{
                                        
										"[$($MyInvocation.InvocationName.ToString().ToUpper())] Available Storage System targets: {0}" -f ($storageSystemVolCreate.storageSystemUri -join ", ") | Write-Verbose 
                                        
										#loop through profile connections
                                        $found = 0

                                        foreach ($storageSystemNetworks in $storageSystemVolCreate.availableNetworks) 
										{

                                            $profileConnection = $serverProfile.connections | ? networkUri -eq $storageSystemNetworks.uri

                                            if ($profileConnection) 
											{

                                                #Keep track of the connections found for error reporting later
                                                $found++

                                                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Mapping connection ID '$($profileConnection.id)' -> volume ID '$($volumesToAttach[$i].id)'"
                                                
												$_StoragePath = NewObject -StoragePath

												$_StoragePath.connectionId = $profileConnection.id
												$_StoragePath.isEnabled = $True

                                                [void]$volume.storagePaths.Add($_StoragePath)

                                            }

                                        }

                                        if (-not($found))
										{

                                            #Generate non-terminating error and continue
                                            $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException NoProfileConnectionsMapToVolume ObjectNotFound 'New-HPOVServerProfile' -Message "Unable to find a Profile Connection that will map to '$($volume.id)'. Creating server profile resource without Volume Connection Mapping." 

                                            $PSCmdlet.WriteError($errorRecord)

                                    
                                        }

                                    }

                                    else 
									{

                                        $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException StorageSystemNotFound ObjectNotFound 'New-HPOVServerProfile' -Message "The provided Storage System URI '$($volume.volumeStorageSystemUri)' for the ephemeral volume '$($volume.name)' was not found as an available storage system." 
                                        $PSCmdlet.ThrowTerminatingError($errorRecord)

                                    }
                                        
                                }

                                #Else, generate an error that at least one FC connection must exist in the profile in order to attach volumes.
                                else 
								{

                                    $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException NoProfileConnections ObjectNotFound 'New-HPOVServerProfile' -Message "The profile does not contain any Network Connections.  The Profile must contain at least 1 FC Connection to attach Storage Volumes.  Use the New-HPOVServerProfileConnection helper cmdlet to create 1 or more connections and try again." 
                                    $PSCmdlet.ThrowTerminatingError($errorRecord)

                                }

                            }
 
                        }
                        
						$volume = $volume | Select-Object * -ExcludeProperty ApplianceConnection

						[void]$serverProfile.sanStorage.volumeAttachments.Add($volume)

                        $i++

                    }

                    #$serverProfile.sanStorage.volumeAttachments = $volumesToAttach
                    
                    #Check to see if user passed -EvenPathDisable and/or -OddPathDisable parameter switches
                    if ($EvenPathDisabled.IsPresent -or $OddPathDisabled.IsPresent) 
					{
                        
                        if ($EvenPathDisabledd.IsPresent) { Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Disable Even Path: $([bool]$EvenPathDisable)" }
                        if ($OddPathDisable.IsPresent) { Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Disable Odd Path: $([bool]$OddPathDisable)" }

                        #Keep track of Volume Array index
                        $v = 0

                        foreach ($vol in $serverProfile.sanStorage.volumeAttachments) 
						{
                            
                            #Keep track of Volume Path Array index
                            $p = 0

                            foreach ($path in $vol.storagePaths) 
							{

                                if ([bool]$OddPathDisabled -and [bool]($path.connectionID % 2)) { $isEnabled = $false }
                                elseif ([bool]$EvenPathDisabled -and [bool]!($path.connectionID % 2)) { $isEnabled = $false }
                                else { $isEnabled = $true }

                                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Setting Connection ID '$($path.connectionID)' path enabled:  $($isEnabled)"

                                $serverProfile.sanStorage.volumeAttachments[$v].storagePaths[$p].isEnabled = $isEnabled
                                $p++
                            }

                            $v++

                        }
                        
                    }

                }

		        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Profile: $($serverProfile | out-string)"
				Try
				{

					$resp = Send-HPOVRequest $uri POST $serverProfile -appliance $_Connection

				}
	            
				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

	        }
            
            [void]$colStatus.Add($resp)

        }

    }

    End 
	{

        return $colStatus
    
	}    
    
}

function Update-HPOVServerProfile
{

	# .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding(DefaultParameterSetName = "Update", SupportsShouldProcess = $True, ConfirmImpact = 'High')]
    Param 
	(
        
        [parameter(Position = 0, ValueFromPipeline, Mandatory, HelpMessage = "Enter the Server Profile Object, Name, or an Array of names.", ParameterSetName = "Update")]
        [ValidateNotNullOrEmpty()]
		[Alias('le')]
        [object]$ServerProfile,

		[parameter(Position = 1, ValueFromPipelineByPropertyName, Mandatory = $false, ParameterSetName = 'Update')]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions},

        [parameter(Mandatory = $false, HelpMessage = "Return created task object without waiting for completion.", ParameterSetName = "Update")]
        [Switch]$Async

    )

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSBoundParameters['ServerProfile']))
		{

			$PipelineInput = $True

		}

		else
		{
			
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
			$c = 0
		
			#Support ApplianceConnection property value via pipeline from Enclosure Object
			if($PSboundParameters['ApplianceConnection'])
			{

				ForEach ($_connection in $ApplianceConnection) 
				{

					Try 
					{
			
						$ApplianceConnection[$c] = Test-HPOVAuth $_connection

					}

					Catch [HPOneview.Appliance.AuthSessionException] 
					{

						$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_connection -Message $_.Exception.Message -InnerException $_.Exception
						$PSCmdlet.ThrowTerminatingError($errorRecord)

					}

					Catch 
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

					$c++

				}

			}

		}

		$_TaskCollection          = New-Object System.Collections.ArrayList
		$_ServerProfileCollection = New-OBject System.Collections.ArrayList
        
	}

    Process 
	{

		if ($PipelineInput) 
		{
		
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Pipeline input."

			#error if the input value is not a PSObject
			if (-not($ServerProfile -is [PSCustomObject]))
			{

				$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidServerProfileObjectType InvalidArgument 'ServerProfile' -TargetType 'PSObject' -Message "The provided ServerProfile value is not a valid PSObject ($($ServerProfile.GetType().Name)). Please correct your input value."
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] ServerProfile PSObject: $($ServerProfile | FL * | out-string)."

			#Validate the Input object is the allowed category
			if ($ServerProfile.category -ne 'server-profiles')
			{

				$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidServerProfileCategory InvalidArgument 'ServerProfile' -TargetType 'PSObject' -Message "The provided ServerProfile object ($($ServerProfile.name)) category '$($ServerProfile.category)' is not an allowed value.  Expected category value is 'server-profiles'. Please correct your input value."
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			if(-not($ServerProfile.ApplianceConnection))
			{

				$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidServerProfileObject InvalidArgument 'ServerProfile' -TargetType 'PSObject' -Message "The provided ServerProfile object ($($ServerProfile.name)) does not contain the required 'ApplianceConnection' object property. Please correct your input value."
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			[void]$_ServerProfileCollection.Add($ServerProfile)
		
		}

		#Not Pipeline input, and support Array of ServerProfile Name or PSObject
		else
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing ServerProfile parameter."

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] ServerProfile is [$($ServerProfile.GetType().Name)]."

			ForEach ($_profile in $ServerProfile)
			{

				switch ($_profile.GetType().Name)
				{

					#Name
					'String' 
					{
					
						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] ServerProfile value: $($_profile)."

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Looking for Server Profile Name on connected sessions provided"

						#Loop through all Appliance Connections
						ForEach ($_connection in $ApplianceConnection)
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_connection.Name)' Session."

							Try
							{

								$_resp = Get-HPOVServerProfile $_profile -ApplianceConnection $_connection.Name

							}

							Catch
							{

								$PSCmdlet.ThrowTerminatingError($_)

							}

							[void]$_ServerProfileCollection.Add($_resp)

						}
					
					}

					#Object
					'PSCustomObject'
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] ServerProfile PSObject: $($_profile | FL * | out-string)."

						#Validate the Input object is the allowed category
						if ($_profile.category -ne 'server-profiles')
						{

							$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidServerProfileCategory InvalidArgument 'ServerProfile' -TargetType 'PSObject' -Message "The provided ServerProfile object ($($_profile.name)) category '$($_profile.category)' is not an allowed value.  Expected category value is 'server-profiles'. Please correct your input value."
							$PSCmdlet.ThrowTerminatingError($errorRecord)

						}

						[void]$_ServerProfileCollection.Add($_profile)

					}

				}

			}

		}

	}

	End
	{
        #Perform the work
        ForEach ($_spObject in $_ServerProfileCollection) 
		{

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Server Profile: '$($_spObject.name) [$($_spObject.uri)]'"
            
			$_Operation = NewObject -PatchOperation
			
			$_Operation.op    = "replace"
			$_Operation.path  = "/templateCompliance"
			$_Operation.value = "Compliant" 

			Write-Verbose ("[$($MyInvocation.InvocationName.ToString().ToUpper())] Is Server Profile 'Compliant': {0}" -f $_spObject.templateCompliance)

			if ($_spObject.templateCompliance -ne 'Compliant')
			{

				try
				{
				
					$_spUpdateOperations = Send-HPOVRequest ($_spObject.uri + '/compliance-preview') -Hostname $_spObject.ApplianceConnection.Name

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}
			
				$_spUpdateOperations

				if ($pscmdlet.ShouldProcess($_spObject.name,"$Update Server Profile configuration. WARNING: Depending on this action, there might be a brief outage."))
				{ 

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request to $($PSCmdlet.ParameterSetName) configuration"

					Try
					{

						$_task = Send-HPOVRequest $_spObject.uri PATCH $_Operation -Hostname $_spObject.ApplianceConnection.Name

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

					if (-not($PSBoundParameters['Async']))
					{
					
						 $_task = Wait-HPOVTaskComplete $_task -ApplianceConnection $_task.ApplianceConnection.Name
				
					}

					[void]$_TaskCollection.Add($_task)
                    
				}

				elseif ($PSBoundParamters['WhatIf'])
				{
				
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User included -WhatIf."
			
				}

				else
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User cancelled."

				}    

			}

			else
			{

				Write-Warning ('Skipping {0} Server Profile, as it is Compliant.' -f $_spObject.name)

			}
			       
        }

		Return $_TaskCollection

    }

}

function Get-HPOVServerProfileTemplate 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml
    
    [CmdLetBinding(DefaultParameterSetName = "Default")]
    Param 
    (

        [parameter(ValueFromPipeline = $false, ParameterSetName = "Default", Mandatory = $false, Position = 0)]
        [parameter(ValueFromPipeline = $false, ParameterSetName = "Detailed", Mandatory = $false, Position = 0)]
        [parameter(ValueFromPipeline = $false, ParameterSetName = "Export", Mandatory = $false, Position = 0)]
        [Alias('profile')]
        [string]$Name = $null,

        [parameter(ValueFromPipeline = $false, ParameterSetName = "Detailed", Mandatory = $true)]
        [switch]$Detailed,

		[parameter(Mandatory = $false)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions},
        
        [parameter(ValueFromPipeline = $false, ParameterSetName = "Export", Mandatory = $true)]
        [alias("x")]
        [switch]$Export,

        [parameter(ValueFromPipeline = $false, ParameterSetName = "Export", Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [alias("save")]
        [string]$Location

    )

    Begin 
    {

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

        #Validate the path exists.  If not, create it.
		if (($Export) -and (-not(Test-Path $Location)))
		{ 
        
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Directory does not exist.  Creating directory..."
            
			New-Item -path $Location -ItemType Directory
        
		}

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
            {
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
            {

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
            {

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}
        

        $uri = $ServerProfileTemplatesUri

        if ($name) 
        { 
               
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Received name: $($name)"

            $name = $name -replace ("[*]","%25") -replace ("[&]","%26")
            
            $uri += "?filter=name matches '$name'&sort=name:asc"
            
        }

        $TemplateCollection = New-Object System.Collections.ArrayList

	}

	Process 
    {
        
        ForEach ($_connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_connection.Name)' Appliance (of $($ApplianceConnection.Count))"

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request"

			Try
			{

				$templates = Send-HPOVRequest $uri -Hostname $_connection

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}
        
            foreach ($_template in $templates.members)
            {
            
                $_template.PSObject.TypeNames.Insert(0,'HPOneView.ServerProfileTemplate')
                    
                [void]$TemplateCollection.Add($_template)
                
            }

        }

	}

    End 
    {

        "Done. {0} server profile template resource(s) found." -f $TemplateCollection.count | write-verbose 

        #If a search for specific profile returns 0 results, throw a terminating error
        if(-not($TemplateCollection) -and $name)
        {

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Profile Template Resource Name was provided, yet no results were found.  Generate Error."

            $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException ServerProfileResourceNotFound ObjectNotFound "Name" -Message "The specified Server Profile Template '$name' not found. Please check the name again, and try again."
            $pscmdlet.ThrowTerminatingError($errorRecord)
            
        }

        #If user wants to export the profile configuration
        elseif ($export) 
        {

            #Get the unique applianceConnection.name properties from the profile collection for grouping the output files
            $ProfileGroupings = $TemplateCollection.ApplianceConnection.name | Select -Unique

            ForEach ($pg in $ProfileGroupings)
            {
                
                $outputProfiles = New-Object System.Collections.ArrayList

                $templates = $TemplateCollection | ? { $_.ApplianceConnection.Name -eq $pg }

                #Loop through all profiles
                foreach ($profile in $templates) 
                {

                    #trim out appliance unique properties

                    $_profile = $profile | select-object -Property * -excludeproperty uri,etag,created,modified,status,state,inprogress,enclosureUri,enclosureBay,serverHardwareUri,taskUri,ApplianceConnection
                    $_profile.serialNumberType = "UserDefined"

                    #Loop through the connections to save the assigned address
                    $i = 0
                    foreach ($connection in $profile.connections) 
                    {

                        if ($profile.connections[$i].mac) { $_profile.connections[$i].macType = "UserDefined" }
                        if ($profile.connections[$i].wwpn) { $_profile.connections[$i].wwpnType = "UserDefined" }
                        $i++

                    }

                    [void]$outputProfiles.Add($_profile)
                    
                }

                #save profile to JSON file
                "[$($MyInvocation.InvocationName.ToString().ToUpper())] Saving Server Profile Templates to {0}" -f ($location + '\' + $pg + '_ServerProfileTemplates.json') | Write-Verbose

                convertto-json -InputObject $outputProfiles -depth 99 | new-item ($location + '\' + $pg + '_ServerProfileTemplates.json') -itemtype file

            }

        }

        else 
        {

            Return $TemplateCollection

        }

    }

 }

function New-HPOVServerProfileTemplate 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdLetBinding(DefaultParameterSetName = "Default")]
    Param 
    (

        [parameter(Mandatory = $true, ParameterSetName = "Default", Position = 0)]
        [parameter(Mandatory = $true, ParameterSetName = "SANStorageAttach", Position = 0)]
		[ValidateNotNullOrEmpty()]
        [string]$Name,

        [parameter(Mandatory = $false, ParameterSetName = "Default", position = 2)] 
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach", position = 2)]
		[string]$Description = $null,

        [parameter(Mandatory = $false, ParameterSetName = "Default", position = 3)]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach", position = 3)]
		[ValidateNotNullOrEmpty()]
        [array]$Connections = @(),

        [parameter(Mandatory = $false, ParameterSetName = "Default",position = 4)]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach", position = 4)]
		[ValidateNotNullOrEmpty()]
		[Alias('eg')]
        [object]$EnclosureGroup = $Null,

        [parameter(Mandatory = $false, ParameterSetName = "Default", position = 5)]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach", position = 5)]
        [ValidateNotNullOrEmpty()]
		[Alias('sht')]
        [array]$ServerHardwareType = $null,

        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [ValidateNotNullOrEmpty()]
        [switch]$Firmware,

		[parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [ValidateSet('FirmwaerOnly', 'FirmwareAndSoftware', 'FirmwareOffline')]
		[string]$FirmwareMode = 'FirmwareAndSoftware',
	
        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [ValidateNotNullOrEmpty()]
        [object]$Baseline = $null,

        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [switch]$ForceInstallFirmware,
	
        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [ValidateNotNullOrEmpty()]
        [switch]$Bios = $false,

	    [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [ValidateNotNullOrEmpty()]
        [array]$BiosSettings=@(),
        
        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]        
        [ValidateSet("UEFI","UEFIOptimized","BIOS", IgnoreCase = $False)]
        [string]$BootMode = "BIOS",

        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]        
        [ValidateSet("Auto","IPv4","IPv6","IPv4ThenIPv6","IPv6ThenIPv4", IgnoreCase = $False)]
        [string]$PxeBootPolicy = "Auto",

        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [Alias('boot')]
        [switch]$ManageBoot,

	    [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [array]$BootOrder = @(),

        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [switch]$LocalStorage,

        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [switch]$Initialize,

		[parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
		[ValidateSet("HBA","RAID", IgnoreCase = $true)]
        [String]$ControllerMode,

		[parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
		[ValidateNotNullorEmpty()]
        [Object]$LogicalDisk,

		#DEPRECATED
        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]        
        [switch]$Bootable,

		#DEPRECATED
        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [ValidateSet("RAID1","RAID0","NONE", IgnoreCase=$true)]
        [string]$RaidLevel = $Null,

        [parameter(Mandatory = $True, ParameterSetName = "SANStorageAttach")]
        [switch]$SANStorage,

        [parameter(Mandatory = $true, ParameterSetName = "SANStorageAttach")]
        [ValidateSet('CitrixXen','AIX','IBMVIO','RHEL4','RHEL3','RHEL','RHEV','VMware','Win2k3','Win2k8','Win2k12','OpenVMS','Egenera','Exanet','Solaris9','Solaris10','Solaris11','ONTAP','OEL','HPUX11iv1','HPUX11iv2','HPUX11iv3','SUSE','SUSE9','Inform', IgnoreCase=$true)]
        [Alias('OS')]
        [string]$HostOStype = $Null,

        [parameter(Mandatory = $true, ParameterSetName = "SANStorageAttach")]
        [object]$StorageVolume = $Null,

        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [Alias('Even')]
        [switch]$EvenPathDisabled,

        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [Alias('Odd')]
        [switch]$OddPathDisabled,

        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [ValidateSet("Bay","BayAndServer", IgnoreCase=$false)]
        [string]$Affinity = "Bay",
	
        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [ValidateSet("Virtual", "Physical", "UserDefined", IgnoreCase=$true)]
        [string]$MacAssignment = "Virtual",

        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [ValidateSet("Virtual", "Physical", "'UserDefined", IgnoreCase=$true)]
        [string]$WwnAssignment = "Virtual",

        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [ValidateSet("Virtual", "Physical", "UserDefined", IgnoreCase=$true)]
        [string]$SnAssignment = "Virtual",

        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "SANStorageAttach")]
        [bool]$HideUnusedFlexNics = $True,

        [parameter(Mandatory = $false)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}


    )
	
    Begin 
    {

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if ($PSBoundParameters['Bootable'])
		{

			Write-Warning 'The -Bootable parameter has been deprecated. In order to configure local storage, please read Help New-HPOVServerProfile and the LocalDisk parameter.'

		}

		if ($PSBoundParameters['RaidLevel'])
		{

			Write-Warning 'The -RaidLevel parameter has been deprecated. In order to configure local storage, please read Help New-HPOVServerProfile and the LocalDisk parameter.'

		}

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0

        ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
            {
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
            {

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
            {

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

        #Check for URI values in parameters and validate that only one appliance connection is provided in the call
        if($ApplianceConnection.Count -gt 1)
		{
            
            #SHT
            if($serverHardwareType -is [string] -and $serverHardwareType.StartsWith($script:serverHardwareTypesUri))
			{
                
				$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidServerHardwareTypeObject InvalidArgument 'New-HPOVPropfile' -Message "Server Hardware Type as URI is not supported for multiple appliance connections"
		    	$PSCmdlet.ThrowTerminatingError($errorRecord)
            
			}
            
			if($serverHardwareType -is [string] -and $serverHardwareType.StartsWith("/rest"))
			{
            
				$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidServerHardwareTypeObject InvalidArgument 'New-HPOVPropfile' -Message "Server Hardware Type as URI is not supported for multiple appliance connections."
		    	$PSCmdlet.ThrowTerminatingError($errorRecord)
            
			}

            #EG
            if(($enclosureGroup -is [string] -and $enclosureGroup.StartsWith("/rest")))
			{
            
				$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidServerHardwareTypeObject InvalidArgument 'New-HPOVPropfile' -Message "Enclosure Group as URI is not supported for multiple appliance connections."
		    	$PSCmdlet.ThrowTerminatingError($errorRecord)
            
			}

            #Baseline
            if (($baseline -is [string]) -and ($baseline.StartsWith('/rest'))) 
			{
                
				$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidServerHardwareTypeObject InvalidArgument 'New-HPOVPropfile' -Message "Baseline as URI is not supported for multiple appliance connections."
		    	$PSCmdlet.ThrowTerminatingError($errorRecord)
            
			}


        }

        $uri = $script:serverProfileTemplatesUri

        $colStatus = New-Object System.Collections.ArrayList

    }
	
	Process 
	{
        
        ForEach($_Connection in $ApplianceConnection)
		{

			#New Server Resource Object
			$_spt = NewObject -ServerProfileTemplate
			    
			$_spt.name                          = $name
			$_spt.description                   = $description
			$_spt.affinity                      = $Affinity
			$_spt.hideUnusedFlexNics            = [bool]$hideUnusedFlexNics
			$_spt.bios.manageBios               = [bool]$bios
			$_spt.bios.overriddenSettings       = $biosSettings
			$_spt.firmware.manageFirmware       = [bool]$firmware
			$_spt.firmware.forceInstallFirmware = [bool]$forceInstallFirmware
			$_spt.boot.manageBoot               = $manageBoot.IsPresent
			$_spt.boot.order                    = $bootOrder
			$_spt.serialNumberType              = $snAssignment 
			$_spt.macType                       = $macAssignment
			$_spt.wwnType                       = $wwnAssignment
					    
		    #Check to see if the serverHardwareType or enclosureGroup is null, and generate error(s) then break.
		    if (-not($ServerHardwareType))
			{

                $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidServerHardwareTypeObject InvalidArgument 'ServerHardwareType' -Message "Server Hardware Type is missing.  Please provide a Server Hardware Type using the -sht parameter and try again."
		        $PSCmdlet.ThrowTerminatingError($errorRecord)

		    }
		    
		    #If the URI is passed as the Server Hardware Type, then set the serverHardwareTypeUri variable
		    If ($ServerHardwareType -is [string])
			{

		    	if ($serverHardwareType.StartsWith($script:serverHardwareTypesUri))
				{ 
                            
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] SHT URI Provided: $serverHardwareType" 

                    $_spt.serverHardwareTypeUri = $serverHardwareType

					Try
					{
							
						$serverHardwareType = Send-HPOVRequest $serverHardwareType -appliance $_Connection
							
					}
                            
                    Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

                }
		    		
		    	#Otherwise, perform a lookup ofthe SHT based on the name
		    	else 
				{

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] SHT Name Provided: $serverHardwareType"

					Try
					{

						$serverHardwareType = Get-HPOVServerHardwareType -name $serverHardwareType -appliance $_Connection

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}
		    		

                    if ($serverHardwareType) 
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] SHT URI: $serverHardwareTypeUri"

		    			$_spt.serverHardwareTypeUri = $serverHardwareType.uri

                    }

                    else 
					{

                        $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidServerHardwareTypeParameter InvalidArgument 'ServerHardwareType' -Message "The -ServerHardwareType parameter value is invalid.  Please make sure it is a Name, URI or resource Object."
                        $PSCmdlet.ThrowTerminatingError($errorRecord)

                    }

		    	}

		    }
		    
		    #Else the SHT object is passed
		    else 
			{ 

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] ServerHardwareType object provided"
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] ServerHardwareType Name: $($serverHardwareType.name)"
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] ServerHardwareType Uri: $($serverHardwareType.uri)"

                $_spt.serverHardwareTypeUri = ($serverHardwareType | ? {$_.ApplianceConnection.name -eq $_Connection.name}).uri
                        
            }

            if (-not($EnclosureGroup) -and (-not($ServerHardwareType.model -match "DL")))
			{
		    	    
                $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidEnclosureGroupObject InvalidArgument 'EnclosureGroup' -Message "Enclosure Group is missing.  Please provide an Enclosure Group using the -eg parameter and try again."
		        $PSCmdlet.ThrowTerminatingError($errorRecord)

            }

            elseif ($EnclosureGroup -is [string])
			{

		        #If the URI is passed as the Enclosure Group, then set the enclosureGroupUri variable
		        if ($enclosureGroup.StartsWith('/rest'))
				{ 
					
					$_spt.enclosureGroupUri = $enclosureGroup
				
				}

		        #Otherwise, perform a lookup ofthe Enclosure Group
		        else
				{

					Try
					{

						$enclosureGroup = Get-HPOVEnclosureGroup -name $enclosureGroup -appliance $_Connection

					}
		    	    
					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] EG URI: $enclosureGroupUri"					    
                    
					$_spt.enclosureGroupUri = $enclosureGroup.uri
		    	    
		        }

		    }
		    		
		    #Else the EG object is passed
		    elseif (($EnclosureGroup -is [Object]) -and ($EnclosureGroup.category -eq "enclosure-groups")) 
			{ 
                #Retrieve only EG from this appliance connection
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Group object provided"
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Group Name: $($enclosureGroup.name)"
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Group Uri: $($enclosureGroup.uri)"

                #Retrieve only EG from this appliance connection
                $_spt.enclosureGroupUri = ($enclosureGroup | ? {$_Connection.name -eq $_.applianceConnection.name}).uri 

            }

            elseif (-not($EnclosureGroup) -and ($ServerHardwareType.model -match "DL")) 
			{

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server is a ProLiant DL model. Enclosure Group not required."

            }
                            
            else 
			{ 
 
                $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidEnclosureGroupObject InvalidArgument 'EnclsoureGroup' -TargetType $EnclosureGroup.GetType().Name -Message "Enclosure Group is invalid.  Please specify a correct Enclosure Group name, URI or object and try again."

                #Generate Terminating Error
		        $PSCmdlet.ThrowTerminatingError($errorRecord)
                
            }

            #Handle DL Server Profiles by setting BL-specific properties to NULL
            if ($ServerHardwareType.model -match "DL") 
			{

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server Hardware Type is a DL, setting 'macType', 'wwnType', 'serialNumberType', 'affinity' and 'hideUnusedFlexNics' to Null."

                $_spt.macType            = $Null
                $_spt.wwnType            = $Null
                $_spt.serialNumberType   = $Null
                $_spt.hideUnusedFlexNics = $Null
                $_spt.affinity           = $Null

            }

            #User provided UEFI or UEFIOptimized for a non-Gen9 platform.
			if ((-not($BootMode -eq "BIOS")) -and (-not($ServerHardwareType.model -match "Gen9"))) 
			{

                $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException BootModeNotSupported InvalidArgument 'BootMode' -Message "The -bootMode parameter was provided and the Server Hardware model '$($serverHardwareType.model)' does not support this parameter.  Please verify the Server Hardware Type is at least an HPE ProLiant Gen9."
		    	$pscmdlet.ThrowTerminatingError($errorRecord)    

            }

            #Handle Boot Order and BootManagement
			switch ($ServerHardwareType.model)
			{
					
				{$_ -match 'Gen7' -or $_ -match 'Gen8'}
				{

					if (-not($PSboundParameters['BootOrder']) -and $ManageBoot)
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No boot order provided for Gen8 Server resource type.  Defaulting to ‘CD’,’Floppy’,’USB’,’HardDisk’,’PXE’"

						[System.Collections.ArrayList]$_spt.boot.order = (‘CD’,’Floppy’,’USB’,’HardDisk’,’PXE’)

					}

				}

				{$_ -match 'Gen9'}
				{

					"[$($MyInvocation.InvocationName.ToString().ToUpper())] Gen 9 Server, setting BootMode to: {0}" -f $BootMode | Write-Verbose 

					switch ($BootMode) 
					{

						"BIOS" 
						{
						    
						    $_spt.bootMode = [PSCustomObject]@{
						        manageMode = $true;
						        mode       = $BootMode;
						    }
						    
						}

						{ "UEFI","UEFIOptimized" -match $_ } 
						{
						    
						    $_spt.bootMode = [PSCustomObject]@{
						        manageMode    = $true;
						        mode          = $BootMode;
						        pxeBootPolicy = $PxeBootPolicy
						    }
						    
						}

					}

					"[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Gen 9 Server BootOrder settings." | Write-Verbose 

					if ($ManageBoot -and ($BootOrder -contains "Floppy") -and ($BootMode -match "UEFI"))
					{
		    				
						$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidUEFIBootOrderParameterValue InvalidArgument 'BootOrder' -TargetType 'Array' -Message	"The -BootOrder parameter contains 'Floppy' which is an invalid boot option for a UEFI-based system."
		    			$pscmdlet.ThrowTerminatingError($errorRecord)

					}

					elseif ((-not ($PSBoundParameters["BootOrder"])) -and $ManageBoot -and (-not($BootMode -match 'UEFI'))) 
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No boot order provided for Gen9 Server resource type.  Defaulting to ‘CD’,’USB’,’HardDisk’,’PXE’"

						[System.Collections.ArrayList]$_spt.boot.order = @(‘CD’,’USB’,’HardDisk’,’PXE’)
                
					}

					elseif ((-not ($PSBoundParameters["BootOrder"])) -and $ManageBoot -and ($BootMode -match 'UEFI') -and ($serverHardwareType.model -match 'BL'))
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No boot order provided for BL Gen9 Server resource type.  Defaulting to ’HardDisk’."

						[System.Collections.ArrayList]$_spt.boot.order = @(’HardDisk’)
                
					}

					elseif (($BootOrder.count -gt 1) -and $ManageBoot -and ($BootMode -match 'UEFI') -and ($serverHardwareType.model -match 'BL'))
					{

						$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidUEFIBootOrderParameterValue InvalidArgument 'BootOrder' -TargetType 'Array' -Message	("The -BootOrder parameter contains more than 1 entry, and the system BootMode is set to {0}, which is invalud for a UEFI-based system.  Please check the -BootOrder parameter and make sure either 'HardDisk' or 'PXE' are the only option." -f $BootMode)
		    			$pscmdlet.ThrowTerminatingError($errorRecord)
                
					}

					elseif ($BootOrder -and $ManageBoot -and ($BootMode -match 'UEFI') -and ($serverHardwareType.model -match 'DL'))
					{

						$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidUEFIBootOrderParameterValue InvalidArgument 'BootOrder' -TargetType 'Array' -Message	("The -BootOrder parameter is not supported with DL Gen9 servers when BootMode is also set to {0}. Either change the BootMode to 'BIOS' or remove the -BootOrder parameter." -f $BootMode)
		    			$pscmdlet.ThrowTerminatingError($errorRecord)
                
					}

					else
					{

						"[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding provided BootOrder {0} to Server Profile object." -f ($BootOrder -join ', ') | Write-Verbose 

						[System.Collections.ArrayList]$_spt.boot.order = $BootOrder

					}

				}

			}

			#Exmamine the profile connections parameter and pull only those connections for this appliance connection
			If ($connections -and (-not($serverHardwareType.model -match "DL")))
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting available Network resources based on SHT and EG."

				#Get avaialble Networks based on the EG and SHT
				$_AvailableNetworksUri = $ServerProfilesAvailableNetworksUri + '?serverHardwareTypeUri={0}&enclosureGroupUri={1}' -f $ServerHardwareType.uri,$EnclosureGroup.uri

				Try
				{

					$_AvailableNetworkResources = Send-HPOVRequest $_AvailableNetworksUri -Hostname $_Connection.Name

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

				ForEach($c in $connections)
				{

					$Message = $null

			        #Remove connection parameters no permitted in Template
                    $c = $c | Select-Object -property * -ExcludeProperty macType, wwnType, wwpnType, mac, wwnn, wwpn, ApplianceConnection

					switch (($c.networkUri.Split('\/'))[2])
					{

						'ethernet-networks'
						{
						
							if (-not($_AvailableNetworkResources.ethernetNetworks | ? uri -eq $c.networkUri))
							{

								$Message = "The Ethernet network {0} specified in Connection {1} was not found to be provisioned to the provided Enclosure Group, {2}, and SHT, {3}.  Please verify that the network is a member of an Uplink Set in the associated Logical Interconnect Group." -f (Send-HPOVRequest $c.networkUri -Hostname $_connection.Name).name, $c.id, $EnclosureGroup.name, $ServerHardwareType.name

							}

							else
							{

								"[$($MyInvocation.InvocationName.ToString().ToUpper())] {0} is available for Connection {1} in this SPT." -f $c.networkUri, $c.id | Write-Verbose 

							}
						
						}

						'network-sets'
						{
						
							if (-not($_AvailableNetworkResources.networkSets | ? uri -eq $c.networkUri))
							{

								$Message = "The network set {0} specified in Connection {1} was not found to be provisioned to the provided Enclosure Group, {2}, and SHT, {3}.  Please verify that the network is a member of an Uplink Set in the associated Logical Interconnect Group." -f (Send-HPOVRequest $c.networkUri -Hostname $_connection.Name).name, $c.id, $EnclosureGroup.name, $ServerHardwareType.name

							}
						
							else
							{

								"[$($MyInvocation.InvocationName.ToString().ToUpper())] {0} is available for Connection {1} in this SPT." -f $c.networkUri, $c.id | Write-Verbose 

							}

						}

						'fc-networks'
						{
						
							if (-not($_AvailableNetworkResources.fcNetworks | ? uri -eq $c.networkUri))
							{

								$Message = "The FC network {0} specified in Connection {1} was not found to be provisioned to the provided Enclosure Group, {2}, and SHT, {3}.  Please verify that the network is a member of an Uplink Set in the associated Logical Interconnect Group." -f (Send-HPOVRequest $c.networkUri -Hostname $_connection.Name).name, $c.id, $EnclosureGroup.name, $ServerHardwareType.name

							}
						
							else
							{

								"[$($MyInvocation.InvocationName.ToString().ToUpper())] {0} is available for Connection {1} in this SPT." -f $c.networkUri, $c.id | Write-Verbose 

							}

						}

						'fcoe-networks'
						{
						
							if (-not($_AvailableNetworkResources.fcNetworks | ? uri -eq $c.networkUri))
							{

								$Message = "The FCoE network {0} specified in Connection {1} was not found to be provisioned to the provided Enclosure Group, {2}, and SHT, {3}.  Please verify that the network is a member of an Uplink Set in the associated Logical Interconnect Group." -f (Send-HPOVRequest $c.networkUri -Hostname $_connection.Name).name, $c.id, $EnclosureGroup.name, $ServerHardwareType.name

							}
						
							else
							{

								"[$($MyInvocation.InvocationName.ToString().ToUpper())] {0} is available for Connection {1} in this SPT." -f $c.networkUri, $c.id | Write-Verbose 

							}
						
						}

					}

					if ($Message)
					{

						$ErrorRecord = New-ErrorRecord HPOneView.ServerProfileConnectionException NetworkResourceNotProvisioned InvalidArgument 'Connections' -TargetType 'PSObject' -Message $Message
		    			$PSCmdlet.ThrowTerminatingError($errorRecord)  

					}
					
					[void]$_spt.connections.Add($c)
			    
				}
			
			}

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $($_spt.connections | FL * -force | Out-String)"
            
		    $BootableConnections = New-Object System.Collections.ArrayList

            #Loop through connections to look for bootable settings and if -manageboot is omitted from $PSBoundParameters
            foreach ($connection in $_spt.connections) 
			{
		    	
		    	if ($connection.boot.priority -ne "NotBootable") 
				{

		    		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Found bootable connection ID '$($connection.id)'"

		    		[void]$BootableConnections.Add($connection.id)

		    	}

		    }

		    if ((-not($manageBoot.IsPresent)) -and $BootableConnections.count -gt 0) 
			{

		    	$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException BootableConnectionsFound InvalidArgument 'manageBoot' -Message "Bootable Connections $($BootableConnections -join ",") were found, however the -manageBoot switch parameter was not provided.  Please correct your command syntax and try again."
		    	$pscmdlet.ThrowTerminatingError($errorRecord)  

		    } 

            #Check to make sure Server Hardware Type supports Firmware Management (OneView supported G7 blade would not support this feature)
            if ($firmware) 
			{
                
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Firmware Baseline $($baseline)"

                if ($serverHardwareType.capabilities -match "firmwareUpdate" ) 
				{

                    #Validating that the baseline value is a string type and that it is an SPP name.
		            if (($baseline -is [string]) -and (-not ($baseline.StartsWith('/rest'))) -and ($baseline -match ".iso")) 
					{
                        
						try 
						{
		                    
							$baseline = Get-HPOVBaseline -isoFileName $baseline -appliance $_Connection
		                    
							$_spt.firmware.firmwareBaselineUri = $baseline.uri
							$_spt.firmware.firmwareInstallType  = $FirmwareControlModeEnum[$FirmwareMode]
                        
						}

                        catch 
						{
                            
							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Error caught when looking for Firmware Baseline."
                            
							$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidBaselineResourceName ObjectNotFound  'Basline' -Message "The provided SPP Baseline '$($baseline)' was not found or an error occurred during lookup."
		    	            
							$pscmdlet.ThrowTerminatingError($errorRecord)
                        
						}
		            
					}

                    #Validating that the baseline value is a string type and that it is an SPP name.
		            elseif (($baseline -is [string]) -and (-not ($baseline.StartsWith('/rest')))) 
					{

                        try 
						{

		                    $baseline = Get-HPOVBaseline -SppName $baseline -appliance $_Connection
		                    $_spt.firmware.firmwareBaselineUri = $baseline.uri

                        }

                        catch 
						{

                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Error caught when looking for Firmware Baseline."

                            $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidBaselineResourceUri ObjectNotFound 'Basline' -Message "The provided SPP Baseline '$($baseline)' was not found or an error occurred during lookup."
		    	            $pscmdlet.ThrowTerminatingError($errorRecord)

                        }

		            }
            
                    #Validating that the baseline value is a string type and that it is the Basline URI
		            elseif (($baseline -is [string]) -and ($baseline.StartsWith('/rest'))) 
					{
		        
		                $baselineObj = Send-HPOVRequest $baseline -appliance $_Connection

                        if ($baselineObj.category -eq "firmware-drivers") 
						{
		                
                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Valid Firmware Baseline provided: $($baselineObj.baselineShortName)"
                            $_spt.firmware.firmwareBaselineUri = $baselineObj.uri 
                        
                        }

                        else 
						{

                            $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidBaselineResource ObjectNotFound 'Basline' -Message "The provided SPP Baseline URI '$($baseline)' is not valid or the correct resource category (expected 'firmware-drivers', received '$($baselineObj.category)'.  Please check the -baseline parameter value and try again."
		    	            $pscmdlet.ThrowTerminatingError($errorRecord)

                        }

		            }

                    #Else we are expecting the SPP object that contains the URI.
                    elseif (($baseline) -and ($baseline -is [object])) 
					{
                        # Baseline object can be collection due to multi-appliance connections
                        # Get just that baseline for this appliance connection
                        $baseline = $baseline | ? {$_.applianceConnection.name -eq $_Connection.name }
                        $_spt.firmware.firmwareBaselineUri = $baseline.uri
                    
                    }

                    elseif(!$basline)
                    {
                        $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException ServerHardwareMgmtFeatureNotSupported NotImplemented 'New-HPOVServerProfileTemplate' -Message "Baseline is required if manage firmware is set to true."
		    		    $pscmdlet.ThrowTerminatingError($errorRecord)
                    }

                    
                }

                else 
				{

                    $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException ServerHardwareMgmtFeatureNotSupported NotImplemented 'New-HPOVServerProfile' -Message "`"$($serverHardwareType.name)`" Server Hardware Type does not support Firmware Management."
		    	    $pscmdlet.ThrowTerminatingError($errorRecord)
                    
                }

            }
            
            #Check to make sure Server Hardware Type supports Bios Management (OneView supported G7 blade do not support this feature)
            if ($PSBoundParameters['bios']) 
			{

				if (![bool]($biosSettings | Measure-Object).count) 
				{
		    		
					$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException BiosSettingsIsNull InvalidArgument 'biosSettings' -TargetType 'Array' -Message "BIOS parameter was set to TRUE, but no biosSettings were provided.  Either change -bios to `$False or provide valid bioSettings to set within the Server Profile."
		    		$pscmdlet.ThrowTerminatingError($errorRecord)
		    	
				}

		    	else 
				{
                
					if ($serverHardwareType.capabilities -match "ManageBIOS" ) 
					{
						 

						#check for any duplicate keys
					    $biosFlag = $false
					    $hash = @{}
					    $biosSettings.id | % { $hash[$_] = $hash[$_] + 1 }

					    foreach ($biosItem in ($hash.GetEnumerator() | ? {$_.value -gt 1} | % {$_.key} )) 
						{
					         
					        $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException BiosSettingsNotUnique InvalidOperation 'BiosSettings' -TargetType 'Array' -Message "'$(($serverHardwareType.biosSettings | where { $_.id -eq $biosItem }).name)' is being set more than once. Please check your BIOS Settings are unique.  This setting might be a dependency of another BIOS setting/option.  Please check your BIOS Settings are unique.  This setting might be a dependency of another BIOS setting/option."
		    		        $pscmdlet.ThrowTerminatingError($errorRecord)

					    }

					}

					else 
					{ 

					    $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException ServerHardwareMgmtFeatureNotSupported NotImplemented 'New-HPOVServerProfile' -Message "`"$($serverHardwareType.name)`" Server Hardware Type does not support BIOS Management."
		    		    $pscmdlet.ThrowTerminatingError($errorRecord)                
		    		
					}
					
				}

			}

			#Set Local Storage Management and Check to make sure Server Hardware Type supports it (OneView supported G7 blade would not support this feature)
            if (($LocalStorage) -and ($serverHardwareType.capabilities -match "ManageLocalStorage" )) 
			{
                
				$_LocalStorageConfig = NewObject -ServerProfileTemplateLocalStorage

				$_LocalStorageConfig.managed    = [bool]$LocalStorage

				$_LocalStorageConfig.initialize = [bool]$Initialize

				[void]$_LocalStorageConfig.logicalDrives.Add($LogicalDisk)

				[void]$_spt.localStorage.controllers.Add($_LocalStorageConfig)
                     
            }
		    
            #StRM Support
            if ([bool]$SANStorage -and $serverHardwareType.model -match "BL") 
			{ 

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] SAN Storage being requested"
            
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting list of available storage systems"

                #Get list of available storage system targets and the associated Volumes based on the EG and SHT provided
                
				Try
				{

					$availStorageSystems = (Send-HPOVRequest ($script:profileAvailStorageSystemsUri + "?enclosureGroupUri=$($_spt.enclosureGroupUri)&serverHardwareTypeUri=$($serverHardwareType.uri)") -appliance $_Connection).members

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}
				

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Available Storage Systems: $($availStorageSystems | fl | out-string)"

                #Error on no available storage systems
                if (-not ($availStorageSystems)) 
				{

                    $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException NoAvailableStorageSystems ObjectNotFound 'SANStorage' -Message "No available storage systems found for '$($serverHardwareType.name)' Server Hardware Type and '$((Send-HPOVRequest $_spt.enclosureGroupUri).name)' Enclosure Group.  Please verify an available Storage System exists, and has connectivity to the destination server or Enclosure Group."
		    	    $pscmdlet.ThrowTerminatingError($errorRecord)  

                }
                
                $_spt.sanStorage = [pscustomobject]@{
                    
					hostOSType        = $script:profileSanManageOSType.($HostOsType);
                    manageSanStorage  = [bool]$SANStorage;
                    volumeAttachments = New-Object System.Collections.ArrayList
                
				}
                
                #Copy the parameter array into a new object
                $volumesToAttach = New-Object System.Collections.ArrayList
				$StorageVolume | % { 
					
					[void]$volumesToAttach.Add($_)
						
				}
                
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Volumes to process $($volumesToAttach | fl | out-string)"
                
                $i = 0
                
                #Process volumes being passed
                foreach ($volume in $volumesToAttach) 
				{  

                    #If the storage paths array is null, process connections to add mapping
                    if (-not ($volume.storagePaths)) 
					{

                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Storage Paths value is Null. Building connection mapping."

                        #Static Volume, must have volumeUri attribute present to be valid
                        if ($volume.volumeUri) 
						{

                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting list of attachable volumes"

                            #Get list of attachable Volumes (i.e. they are not assigned private or are shareable volumes)
							Try
							{

								$attachableVolumes = (Send-HPOVRequest $script:attachableVolumesUri -appliance $_Connection).members

							}

							Catch
							{

								$PSCmdlet.ThrowTerminatingError($_)

							}

							#Get storage volume name for reporting purposes
							Try
							{

								$volumeName = (send-hpovrequest $volume.volumeUri -appliance $_Connection).name

							}
                            
                            Catch
							{

								$PSCmdlet.ThrowTerminatingError($_)

							}

                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Volume ID: $($volume.id)"
                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Looking to see if volume '$($volume.volumeUri) ($($volumeName))' is attachable"
                
                            #validate volume is attachable
                            $attachableVolFound = $attachableVolumes | ? { $_.uri -eq $volume.volumeUri }

                            #If it is available, continue processing
                            if ($attachableVolFound) 
							{
                
                                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] '$($attachableVolFound.uri) ($($attachableVolFound.name))' volume is attachable"
                
                                #validate the volume that is available, is also avialable to the server hardware type and enclosure group
                                $volumeToStorageSystem = $availStorageSystems | ? { $_.storageSystemUri -eq $attachableVolFound.storageSystemUri }
                
                                #If available, process the volume networks
                                if ($volumeToStorageSystem) 
								{ 
                                
                                    #Check to make sure profile connections exist.
                                    if ($_spt.connections -and $_spt.connections.functionType -contains "FibreChannel") 
									{

                                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Profile has connections"
                                    
                                        #loop through profile connections
                                        $found = 0

                                        foreach ($volConnection in $attachableVolFound.availableNetworks) 
										{

                                            #write-verbose "Looking for $volConnection"
                                            $profileConnection = $_spt.connections | ? { $_.networkUri -eq $volConnection }

                                            if ($profileConnection) 
											{

                                                #Keep track of the connections found for error reporting later
                                                $found++

                                                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Mapping connection ID '$($profileConnection.id)' -> volume ID '$($volumesToAttach[$i].id)'"
                                            
                                                [void]$volumesToAttach[$i].storagePaths.Add(

                                                    [pscustomobject]@{
                                                        connectionId = $profileConnection.id;
                                                        isEnabled    = $True
                                                    }

                                                )

                                            }

                                        }

                                        if (-not ($found)) 
										{

                                            #Generate non-terminating error and continue
                                            $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException NoProfileConnectionsMapToVolume ObjectNotFound 'New-HPOVServerProfile' -Message "Unable to find a Profile Connection that will map to '$($volumeName)'. Creating server profile resource without Volume Connection Mapping." 
                                            #$PSCmdlet.ThrowTerminatingError($errorRecord)
                                            $PSCmdlet.WriteError($errorRecord)

                                        }
                                    
                                    }

                                    #Else, generate an error that at least one FC connection must exist in the profile in order to attach volumes.
                                    else 
									{

                                        $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException NoProfileConnections ObjectNotFound 'New-HPOVServerProfile' -Message "The profile does not contain any Network Connections.  The Profile must contain at least 1 FC Connection to attach Storage Volumes.  Use the New-HPOVServerProfileConnection helper cmdlet to create 1 or more connections and try again." 
                                        $PSCmdlet.ThrowTerminatingError($errorRecord)

                                    }
                
                                }
                
                                #If not, then error
                                elseif (-not($volumeToStorageSystem)) 
								{ 
                            
                                    $errorRecord = New-ErrorRecord InvalidOperationException StorageVolumeDoesNotExistOnStorageArray ObjectNotFound 'New-HPOVServerProfile' -Message "'$($volumeName)' Volume is not available on the '$($volumeToStorageSystem.storageSystemName)' storage system"
                                    $PSCmdlet.ThrowTerminatingError($errorRecord)                      
                            
                                }
                
                            }
                
                            elseif (-not ($attachableVolFound)) 
							{ 
                        
                                $errorRecord = New-ErrorRecord InvalidOperationException StorageVolumeUnavailableForAttach ResourceUnavailable 'New-HPOVServerProfile' -Message "'$($volumeName)' Volume is not available to be attached to the profile. Please check the volume and try again." 
                                $PSCmdlet.ThrowTerminatingError($errorRecord)

                            }

                        }

                        #Ephemeral volume support
                        elseif (-not ($volume.volumeUri) -and $volume.volumeStoragePoolUri -and $volume.volumeStorageSystemUri) 
						{

                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No volumeUri, ephemeral volume request."

                            #Check to make sure profile connections exist.
                            if ($_spt.connections -and $_spt.connections.functionType -contains "FibreChannel") 
							{

                                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Profile has connections"

                                #Process available storage system and available FC networks
                                $storageSystemVolCreate = $availStorageSystems | where { $_.storageSystemUri -eq $volume.volumeStorageSystemUri }

                                if ($storageSystemVolCreate) 
								{
                                    
                                    #loop through profile connections
                                    $found = 0

                                    foreach ($storageSystemConnection in $storageSystemVolCreate.connections) 
									{

                                        $profileConnection = $_spt.connections | ? { $_.networkUri -eq $storageSystemConnection }

                                        if ($profileConnection) 
										{

                                            #Keep track of the connections found for error reporting later
                                            $found++
                                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Mapping connection ID '$($profileConnection.id)' -> volume ID '$($volumesToAttach[$i].id)'"
                                            
                                            [void]$volumesToAttach[$i].storagePaths.Add(
                                                
                                                [pscustomobject]@{
                                                
                                                    connectionId      = $profileConnection.id;
                                                    isEnabled         = $True;
                                                    storageTargetType =  "Auto"

                                                }
                                            
                                            )

                                        }

                                    }

                                    if (-not($found))
									{

                                        #Generate non-terminating error and continue
                                        $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException NoProfileConnectionsMapToVolume ObjectNotFound 'New-HPOVProfile' -Message "Unable to find a Profile Connection that will map to '$($volumeName)'. Creating server profile resource without Volume Connection Mapping." 
                                        #$PSCmdlet.ThrowTerminatingError($errorRecord)
                                        $PSCmdlet.WriteError($errorRecord)

                                    }

                                }

                                else 
								{

                                    $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException StorageSystemNotFound ObjectNotFound 'New-HPOVServerProfile' -Message "The provided Storage System URI '$($volume.volumeStorageSystemUri)' for the ephemeral volume '$($volume.name)' was not found as an available storage system." 
                                    $PSCmdlet.ThrowTerminatingError($errorRecord)

                                }
                                    
                            }

                            #Else, generate an error that at least one FC connection must exist in the profile in order to attach volumes.
                            else 
							{

                                $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException NoProfileConnections ObjectNotFound 'New-HPOVServerProfile' -Message "The profile does not contain any Network Connections.  The Profile must contain at least 1 FC Connection to attach Storage Volumes.  Use the New-HPOVServerProfileConnection helper cmdlet to create 1 or more connections and try again." 
                                $PSCmdlet.ThrowTerminatingError($errorRecord)

                            }

                        }
 
                    }
                    
                    $i++
                }

                $_spt.sanStorage.volumeAttachments = $volumesToAttach
                
                #Check to see if user passed -EvenPathDisable and/or -OddPathDisable parameter switches
                if ($EvenPathDisabled.IsPresent -or $OddPathDisabled.IsPresent) 
				{
                    
                    if ($EvenPathDisabledd.IsPresent) { Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Disable Even Path: $([bool]$EvenPathDisable)" }
                    if ($OddPathDisable.IsPresent) { Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Disable Odd Path: $([bool]$OddPathDisable)" }

                    #Keep track of Volume Array index
                    $v = 0

                    foreach ($vol in $_spt.sanStorage.volumeAttachments) 
					{
                        
                        #Keep track of Volume Path Array index
                        $p = 0

                        foreach ($path in $vol.storagePaths) 
						{

                            if ([bool]$OddPathDisabled -and [bool]($path.connectionID % 2)) 
							{ 
								
								$isEnabled = $false 
							
							}
                            
							elseif ([bool]$EvenPathDisabled -and [bool]!($path.connectionID % 2)) 
							{ 
								
								$isEnabled = $false 
							
							}
                            
							else 
							{ 
								
								$isEnabled = $true 
							
							}

                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Setting Connection ID '$($path.connectionID)' path enabled:  $($isEnabled)"

                            $_spt.sanStorage.volumeAttachments[$v].storagePaths[$p].isEnabled = $isEnabled

                            $p++

                        }

                        $v++

                    }
                    
                }

            }

		    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Profile: $($_spt | out-string)"
			Try
			{

				$resp = Send-HPOVRequest -uri $uri POST $_spt -appliance $_Connection.Name

			}
	        
			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

            [void]$colStatus.Add($resp)

        }

    }

    End 
	{

        return $colStatus
    
	}    

}

function Join-HPOVServerProfileToTemplate 
{

    [CmdLetBinding(SupportsShouldProcess = $True)]

    Param 
	(

        [parameter (Mandatory = $true, ValueFromPipeline = $true, HelpMessage = "Enter the template to attach to the profile.", Position = 0)]
        [ValidateNotNullOrEmpty()]
        [Alias("t")]
        [object]$template,

	    [parameter(Mandatory = $true)]
        [Alias("p")] 
        [object]$profile,

        [parameter(Mandatory = $false)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = $Global:ConnectedSessions

    )

    Begin 
    {

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0

        ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
            {
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
            {

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
            {

				$PSCmdlet.ThrowTerminatingError($_.Exception)

			}

			$c++

		}
        
        #If multiple appliance connections check for URI values in the parameters
        If($ApplianceConnection.count -gt 1)
		{
            
            If ($template -is [string] -and $template.startswith('/rest/'))
			{

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $template"

                $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidTemplateParameter InvalidArgument 'Template' -Message "Template parameter as URI is not supported with multiple appliance connections."
		        $PSCmdlet.ThrowTerminatingError($errorRecord)

            }

            If ($profile -is [string] -and $profile.startswith('/rest/'))
			{

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $profile"

                $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidProfileParameter InvalidArgument 'Profile' -Message "Profile parameter as URI is not supported with multiple appliance connections."
		        $PSCmdlet.ThrowTerminatingError($errorRecord)

            }

        }

		$uri = $script:ServerProfilesUri

        $colStatus = New-Object System.Collections.ArrayList

    }
    
    Process 
	{
        
        ForEach($_Connection in $ApplianceConnection)
		{
        
            #Process the template parameter
            #Template passed as string
            if ($template -is [string])
	        {
                
	            #If the URI is passed as set the Template Uri variable. Should not process if multiple connections identified
	            if ($template.StartsWith('/rest'))
	        	{ 

		    		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Template URI: $template"
		    		$templateUri = $template
		    
		        }

	            #Otherwise, perform a lookup of the Enclosure Group
	            else
	        	{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Template Name: $template"					    
                
		    		$templateUri = (Get-HPOVServerProfileTemplate $template -appliance $ApplianceConnection).Uri
		        
				}

	        }
	        	    				
	        #Else the template object or template object collection is passed
	        elseif (($template -is [Object]) -and ($template.category -eq "server-profile-templates")) 
	        { 

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Template object provided"

                $thisTemplate = $template | ? { $_.ApplianceConnection.name -eq $_Connection.name }

                $templateUri = $thisTemplate.uri

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Group Name: $($thisTemplate.name)"

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Group Uri: $($thisTemplate.uri)"

            }

            #Process the profile parameter
            #profile passed as string
            if ($profile -is [string])
	        {
                
	            #If the URI is passed as set the Template Uri variable. Should not process if multiple connections identified
	            if ($profile.StartsWith('/rest'))
	        	{ 

		    		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Template URI: $profile"

					Try
					{

						$thisProfile = Send-HPOVRequest $profile -appliance $_Connection

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}
		    	
		        }

	            #Otherwise, perform a lookup of the Enclosure Group
	            else
	        	{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Template Name: $profile"					    
                
					Try
					{

						$thisProfile = Get-HPOVServerProfile $profile -appliance $_Connection

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

				}

	        }
	        	    				
	        #Else the template object or template object collection is passed
	        elseif (($profile -is [Object]) -and ($profile.category -eq "server-profiles")) 
	        { 

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Profile object provided"

                $thisProfile = $profile | ? { $_.ApplianceConnection.name -eq $_Connection.name }

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Group Name: $($thisProfile.name)"

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Enclosure Group Uri: $($thisProfile.uri)"

            }

            if ($thisProfile.ApplianceConnection.name -eq $_Connection.name)
			{
                
                $thisProfile.serverProfileTemplateUri = $templateUri

				Try
				{

					$task = Set-HPOVResource $thisProfile -appliance $_Connection

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

                [void]$colStatus.Add($task)

            }

        }

    } #End Process Block

    End 
	{

        return $colStatus

    }

}

function ConvertTo-HPOVServerProfileTemplate
{
    
    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding()]
    Param 
    (
    
        [parameter (Mandatory, ValueFromPipeline, HelpMessage = "Provide the Source Server Profile object or Name to create as a Server Profile Template.", Position = 0)]
        [ValidateNotNullOrEmpty()]
        [Alias("source")]
        [Object]$ServerProfile,

		[parameter(Mandatory = $False)] 
		[String]$Name,

		[parameter(Mandatory = $False)] 
		[Switch]$Async,

		[parameter(Mandatory = $False, ValueFromPipelineByPropertyName)]
		[Alias('Appliance')]
		[Object]$ApplianceConnection = ${Global:ConnectedSessions}
	
    )

    Begin 
    {

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if (-not($PSBoundParameters['ServerProfile']))
		{

			$PipelineInput = $True

		}

		if (-not($PipelineInput) -and (($ApplianceConnection | Measure-Object).Count -eq 1 ))
		{

			Try 
			{
			
				$ApplianceConnection = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $ApplianceConnection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}
        
		elseif (-not($PipelineInput) -and (($ApplianceConnection | Measure-Object).Count -gt 1 ))
		{

			$c = 0

			ForEach ($_Connection in $ApplianceConnection) 
			{

				Try 
				{
			
					$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

				}

				Catch [HPOneview.Appliance.AuthSessionException] 
				{

					$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				Catch 
				{

					$PSCmdlet.ThrowTerminatingError($_.Exception)

				}

				$c++

			}

		}

		$_ConvertedSPTCol = New-Object System.Collections.ArrayList

    }

	Process
	{

		#Process Pipeline Input here
		if ($PipelineInput)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Pipeline input."

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Received Server Profile: $($ServerProfile.name)"

			Try
			{

				$_ConvertedSPT = Generate-ServerProfileTemplate $ServerProfile

				if ($PSBoundParameters['Name'])
				{

					$_ConvertedSPT.name = $Name

				}

				$_result = Send-HPOVRequest $ServerProfileTemplatesUri POST $_ConvertedSPT -Hostname $ApplianceConnection.Name

				if (-not($PSBoundParameters['Async']))
				{

					$_result = Wait-HPOVTaskComplete $_result

				}
				
				[void]$_ConvertedSPTCol.Add($_result)

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}

		#Process everything else
		else
		{

			ForEach ($_connection in $ApplianceConnection)
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_connection.name)' Appliance Connection"

				Try
				{

					$_ConvertedSPT = Get-HPOVServerProfile $ServerProfile -ApplianceConnection $_connection | Generate-ServerProfileTemplate

					$_ConvertedSPT.name = $Name

					$_result = Send-HPOVRequest $ServerProfileTemplatesUri POST $_ConvertedSPT

					if (-not($PSBoundParameters['Async']))
					{

						$_result = Wait-HPOVTaskComplete $_result

					}
					
					[void]$_ConvertedSPTCol.Add($_result)

				}

				Catch
				{

					$PScmdlet.ThrowTerminatingError($_)

				}


			}



		}


	}

	End
	{

		Return $_ConvertedSPTCol

	}

}

function Generate-ServerProfileTemplate
{

	#Helper Function

	[CmdLetBinding()]
    Param 
	(

		[parameter(Mandatory, ValueFromPipeline, Position = 0)]
        [ValidateNotNullOrEmpty()]
        [Object]$Source = $Null

	)

	Begin
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		$_ServerProfileTemplateCol = New-Object System.Collections.ArrayList

	}

	Process
	{

		#create a profile template based on profile
		$_ServerProfileTemplate = NewObject -ServerProfileTemplate
				 
		$_ServerProfileTemplate.name                     = "Temporary Name - $($Source.name)"
		$_ServerProfileTemplate.description              = "Created from '$($Source.name)' source Server Profile."
		$_ServerProfileTemplate.serverProfileDescription = $Source.description
		$_ServerProfileTemplate.serverHardwareTypeUri    = $Source.serverHardwareTypeUri
		$_ServerProfileTemplate.enclosureGroupUri		 = $Source.enclosureGroupUri
		$_ServerProfileTemplate.affinity				 = $Source.affinity
		$_ServerProfileTemplate.hideUnusedFlexNics		 = $Source.hideUnusedFlexNics
		$_ServerProfileTemplate.macType                  = $Source.macType
		$_ServerProfileTemplate.wwnType                  = $Source.wwnType
		$_ServerProfileTemplate.serialNumberType         = $Source.serialNumberType
		$_ServerProfileTemplate.connections              = $Source.connections | select-object -property * -excludeproperty mac,wwnn,wwpn,deploymentstatus,interconnectUri,allocatedVFs,mactype,wwntype,wwpntype,allocatedMbps,maximumMbps
		$_ServerProfileTemplate.firmware	             = $Source.firmware
		$_ServerProfileTemplate.bootMode	             = $Source.bootMode
		$_ServerProfileTemplate.boot		             = $Source.boot
		$_ServerProfileTemplate.bios		             = $Source.bios
		$_ServerProfileTemplate.localStorage             = $Source.localStorage
		$_ServerProfileTemplate.sanStorage	             = $Source.sanStorage

		#Adjust connection boot info from profile for use in template
		if ($_ServerProfileTemplate.connections)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing source Server Profile Connections."
			
			$i = 0
		
			forEach ($_conn in $_ServerProfileTemplate.connections)
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Connection ID: $($_conn.id)"

				if ($_conn.boot.priority -ne "NotBootable" -and $_conn.functionType -eq 'FibreChannel')
				{

					$_conn.boot | Add-Member -NotePropertyName specifyBootTarget -NotePropertyValue $true

					$_ServerProfileTemplate.connections[$i] = $_conn

				}

				$i++

			}

		}

		#adjust local storage info for template
		if ($_ServerProfileTemplate.localStorage)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing source Server Profile Local Storage Configuration."

			$c = 0

			forEach ($_controller in $_ServerProfileTemplate.localStorage.controllers)
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Controller in Slot: $($_controller.slotNumber)"

				if ($_controller.importConfiguration)
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] The source Server Profile is set to import an existing Smart Array configuration, but Server Profile Templates do not support this feature."
					
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Setting Smart Array Controller to 'unmanaged'."

					Write-Warning "The source Server Profile contains a Managed Smart Array Controller with the 'Import existing logical drives' policy set.  Server Profile Templates do not support this feature.  Setting Controller in Slot '$($_controller.slotNumber)' to 'Unmanaged'."

					$_controller = $_controller | Select * -Exclude importConfiguration

					$_controller.managed = $false

				}

				else
				{

					$_controller = $_controller | Select * -Exclude importConfiguration
	
					#adjust logical drive info
					$l = 0

					forEach ($_logicalDrive in $_controller.logicalDrives)
					{

						$_controller.logicalDrives[$l] = $_logicalDrive | Select * -Exclude driveNumber

						$l++

					}

					$_ServerProfileTemplate.localStorage.controllers[$c] = $_controller

					$c++

				}

			}

		}

		#adjust SAN storage for template
		if ($_ServerProfileTemplate.sanStorage.volumeAttachments)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing source Server Profile SAN Storage Configuration."

			$i=0

			forEach ($_volAttachment in $_ServerProfileTemplate.sanStorage.volumeAttachments)
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Volume Attachment ID: $($_volAttachment.id)"

				$_volAttachment = $_volAttachment | Select * -Exclude status,state

				$_TemplateVolAttachment = NewObject -EphemeralStorageVolume | Select * -Exclude ApplianceConnection

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Volume Object from API."

				Try
				{

					$_volume = Send-HPOVRequest $_volAttachment.volumeUri

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

				#Need to set this to Manual and set lun to Array Index ID or Array Index ID + n
				if ($_volAttachment.lunType -ieq "Auto")
				{

					$_buffer = 0

					Do
					{

						$_NewLunId = [array]::indexof($_ServerProfileTemplate.sanStorage.volumeAttachments,$_volAttachment) + $_buffer

						if ($_ServerProfileTemplate.sanStorage.volumeAttachments | ? id -eq $_NewLunId)
						{

							$_buffer++

							$_NewLunId = $null

						}

						else
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Found unqie LUN ID value: '$_NewLunId'."

						}

					}
					Until ($_NewLunId -ne $null)
					
					Write-Warning "The source Server Profile contains a Volume Attachment set to 'Auto' LUN ID assignment. Server Profile Templates do not support this feature.  Setting Volume ID '$($_volAttachment.id)' to 'Manual' and specifying '$_NewLunId' as the new LUN ID."

					$_volAttachment.lunType = "Manual"

					$_volAttachment.lun = $_NewLunId

				}

				#adjust storage path info
				$p = 0
				
				forEach ($_Path in $_volAttachment.storagePaths)
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Storage Path for Connection ID: $($_Path.connectionId)."

					$_volAttachment.storagePaths[$p] = $_Path | Select * -Exclude status

					$p++

				}

				#Handle Private volume differently than Shared volume
				if (-not($_volume.shareable))
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Saving new Private Volume object to Template Object."

					$_TemplateVolAttachment.id                             = $_volAttachment.id
					$_TemplateVolAttachment.lun                            = $_volAttachment.lun
					$_TemplateVolAttachment.volumeName                     = "Copy Of - " + $_volAttachment.Name
					$_TemplateVolAttachment.volumeStoragePoolUri           = $_volAttachment.volumeStoragePoolUri
					$_TemplateVolAttachment.volumeProvisionType            = $_volume.provisionType
					$_TemplateVolAttachment.volumeProvisionedCapacityBytes = $_volume.provisionedCapacity
					$_TemplateVolAttachment.permanent                      = $_volume.isPermanent
					$_TemplateVolAttachment.volumeShareable                = $false

					$_TemplateVolAttachment | Add-Member -NotePropertyName storagePaths -NotePropertyValue $_volAttachment.storagePaths

					$_ServerProfileTemplate.SanStorage.volumeAttachments[$i] = $_TemplateVolAttachment

				}

				else
				{
					
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Saving Share Volume object to Template Object."

					$_ServerProfileTemplate.SanStorage.volumeAttachments[$i] = $_volAttachment
				
				}				
				
				$i++
			}

		}
		
		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Cloned Server Profile Template Object: $($_ServerProfileTemplate | ConvertTo-Json -depth 99)"

		[void]$_ServerProfileTemplateCol.Add($_ServerProfileTemplate)

	}

	End
	{

		Return $_ServerProfileTemplateCol

	}

}

function New-HPOVServerProfileAssign 
{

	# .ExternalHelp HPOneView.200.psm1-help.xml
	
	[CmdLetBinding(DefaultParameterSetName = "Default")]
    
	Param 
	(

		[parameter(Mandatory, valuefrompipeline, ParameterSetName = "Unassigned", Position = 0)]
		[parameter(Mandatory, valuefrompipeline, ParameterSetName = "Default", Position = 0)]
        [ValidateNotNullOrEmpty()]
        [Object]$Profile = $Null,
        
		[parameter(Mandatory, valuefrompipeline = $false, ParameterSetName = "Default", Position = 1)]
        [ValidateNotNullOrEmpty()]
        [Object]$Server = $Null,
        
		[parameter(Mandatory = $false, ParameterSetName = "Unassigned")]
        [switch]$Unassigned,

		[parameter(Mandatory = $false, ValueFromPipelineByPropertyName)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Object]$ApplianceConnection = $null

    )

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSBoundParameters['Profile']))
		{

			$PipelineInput = $True

		}

		else
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
			$c = 0

			Try 
			{
			
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}     

        $_taskCollection = New-Object System.Collections.ArrayList

    }

	Process 
	{

		#Look at Profile and Server if they are objects, and make sure ApplianceConnection.Name match
		if ($Profile -is [PSCustomObject] -and $Server -is [PSCustomObject])
		{

			if ($Profile.ApplianceConnection.Name -ne $Server.ApplianceConnection.Name)
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server Profile ($($Profile.ApplianceConnection.Name)) and Server Hardware ($($Server.ApplianceConnection.Name)) ApplianceConnection noteproperties do not match."

				$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException ProfileAndServerApplianceConnectionMismatch InvalidArgument 'Profile' -TargetType 'PSObject' -Message "The Server Profile ($($Profile.ApplianceConnection.Name)) and Server Hardware ($($Server.ApplianceConnection.Name)) ApplianceConnection NoteProperty do not match.  Please correct the value and try again."
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

		}

		#Looking for the $server DTO to be string
		if ($Profile -is [string]) 
		{

			try 
			{ 
				
				$Profile = Get-HPOVServerProfile -name $Profile -ApplianceConnection $ApplianceConnection
			
			}
            
			catch
			{

				$PSCmdlet.ThrowTerminatingError($_)
				
			}

		}

		elseif ($Server -is [PSCustomObject] -and $Server.category -ne 'server-profiles')
		{

			$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException ProfileObjectInvalidCategory InvalidArgument 'Profile' -TargetType 'PSObject' -Message "The Server Profile ($($Profile.name)) is an unsupported resource category type, '$($Profile.category)'.  Only 'server-profiles' are supported.  Please correct the value and try again."
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server Profile Object: $($Profile | out-string)"
		
		#Check to make sure the server hardware the profile is assigned to is powered off
		if ($Profile.serverHardwareUri) 
		{

			Try
			{

				$_ServerResource = Send-HPOVRequest $Profile.serverHardwareUri -Hostname $Profile.ApplianceConnection.Name

			}
			
			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			if ($_ServerResource.powerState -ne "Off") 
			{

				$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException InvalidServerPowerState InvalidResult 'Profile' -Message "The Server '$($_ServerResource.name)' is currently powered On.  Please power off the server and then perform the operation again."
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

		}

		#Looking for the $server DTO to be string
		if ($Server -is [string]) 
		{

			try 
			{ 

				$Server = Get-HPOVServer -name $Server -ApplianceConnection $ApplianceConnection

			}

            catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server Object: $($Server | out-string)"
		
		if ($PSBoundParameters['Unassigned'])
		{

			$Profile.serverHardwareUri = $Null
			
			if ($Profile.enclosureUri) 
			{

				$Profile.enclosureUri      = $Null
				$Profile.enclosureBay      = $Null	

			}

		}

		else 
		{

			if ($Server.serverHardwareTypeUri -ne $Profile.serverHardwareTypeUri) 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server Profile assigned serverHardwareTypeUri does not match the destination Server resource.  Updating Server Profile with new serverHardwareTypeUri value."

				$Profile.serverHardwareTypeUri = $Server.serverHardwareTypeUri

				#$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException IncorrectServerHardwareTypeUri InvalidArgument 'Server' -Message "The Server resource '$($Server.name)' provided does not match the same required Server Hardware Type ['$((Send-HPOVRequest $profile.serverHardwareTypeUri).name)'] found in the Server Profile.  This operation is not permitted, as the Server Hardware Types must match." #-#verbose
				#$pscmdlet.ThrowTerminatingError($errorRecord)
			
			}

			$Profile.serverHardwareUri = $server.uri
			$Profile.enclosureUri      = $server.locationUri

		}

		try 
		{ 

			$_resp = Send-HPOVRequest $Profile.uri PUT $Profile -Hostname $ApplianceConnection.Name

		}

        catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

		[void]$_taskCollection.Add($_resp)
		

	}

    End 
	{

        return $_taskCollection

    }

}

function Copy-HPOVServerProfile 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml
    
    [CmdLetBinding()]
    Param
	(
	
        [parameter(Mandatory = $True, ValueFromPipeline = $true, position = 0)]
        [Alias('sname','src')]
        [ValidateNotNullOrEmpty()]
        [object]$SourceName = $null,
        
        [parameter(Mandatory = $false, position = 1)]
        [alias('dname','dst')]
        [string]$DestinationName = $null,
        
        [parameter(Mandatory = $false, position = 2)]
        [object]$assign = "unassigned",

        [parameter(Mandatory = $false)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

    )
    
    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0

        ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}
        
        if($ApplianceConnection.count -gt 1)
		{
		
            # Check for appliance specific URI parameters and error if more than one appliance connection supplied
            if (($SourceName -is [string]) -and ($SourceName.StartsWith($script:ServerProfilesUri))) 
			{
                    
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] SourceName is a Server Profile URI: $($SourceName)"
                $errorRecord = New-ErrorRecord ArgumentNullException ParametersNotSpecified InvalidArgument 'Copy-HPOVProfile' -Message "The input parameter 'SourceName' is a URI. For multiple appliance connections this is not supported."
                $PSCmdlet.ThrowTerminatingError($errorRecord)
				
            }

            if (($assign -is [string]) -and ($assign.StartsWith($ServerHardwareUri))) 
			{
                
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Assign is a Server Profile URI: $($SourceName)"
                $errorRecord = New-ErrorRecord ArgumentNullException ParametersNotSpecified InvalidArgument 'Copy-HPOVProfile' -Message "The input parameter 'Assign' is a URI. For multiple appliance connections this is not supported."
                $PSCmdlet.ThrowTerminatingError($errorRecord)
            
			}

        }

        $taskCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

        if (!$SourceName) 
		{ 
        
            $errorRecord = New-ErrorRecord ArgumentNullException ParametersNotSpecified InvalidArgument 'Copy-HPOVProfile' -Message "The input parameter 'SourceName' was Null. Please provide a value and try again."
            $PSCmdlet.ThrowTerminatingError($errorRecord)
            
        }

        ForEach($_Connection in $ApplianceConnection)
		{

            if (($SourceName -is [string]) -and (!$SourceName.StartsWith($script:ServerProfilesUri))) 
			{
                
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] SourceName is a Server Profile Name: $($SourceName)"
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting Server Profile URI"

                $profile = Get-HPOVServerProfile $SourceName -appliance $_Connection
                $profileSourceSHT = $profile.serverHardwareTypeUri

            }

            #Checking if the input is System.String and IS a URI - Should not process on multi-appliance connections
            elseif (($SourceName -is [string]) -and ($SourceName.StartsWith($script:ServerProfilesUri))) 
			{
                
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] SourceName is a Server Profile URI: $($SourceName)"

                $profile = Send-HPOVRequest $SourceName -appliance $_Connection
                $profileSourceSHT = $profile.serverHardwareTypeUri
            
            }

            #Checking if source is object or object collection
            elseif (($SourceName -is [PSCustomObject]) -and ($SourceName.category -ieq "server-profiles")) 
			{
                
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] SourceName is a Server Profile object: $($profile.name)"
                #For multi-appliance connections retrieve the source object only for this connection
                $profile = $SourceName | ? { $_.applianceConnection.name -eq $_Connection.name }
                
                #if no such profile for this appliance connection move onto the next connection
                if (!$profile){continue}
                $profileSourceSHT = $SourceName.serverHardwareTypeUri
            
            }

            else 
			{

                $errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'Copy-HPOVProfile' -Message "The parameter -SourceName value is invalid.  Please validate the SourceName parameter value you passed and try again."
                $pscmdlet.ThrowTerminatingError($errorRecord)

            }

            if ($assign -ine 'unassigned') 
			{
                
                #Target Server is the server device name. Could be any empty bay assignment
                if (($assign -is [string]) -and (-not ($assign.StartsWith($ServerHardwareUri)))) 
				{
                    
                    # Get-HPOVServer needs to be in a try/catch since it may be an empty bay
                    Try
					{
					
                        $serverDevice = Get-HPOVServer $assign -appliance $_Connection
						
					}
					
                    Catch 
					{
					
                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $($assign) server resource does not exist."
                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Check for empty bay assignment."
							
                    }

                    Try
					{

                        if(!$serverDevice -and ($assign -match "bay"))
						{
                            
 
                            $assign = $assign.split(',').trim()
                            $thisEnc = Get-HPOVEnclosure $assign[0] -appliance $_Connection
                            [int]$thisBay = (($assign[1]) -replace "bay", "").trim()

                            $presence = $thisEnc.deviceBays[($thisBay - 1)].devicePresence
                            
                            #if presence is null, invalid device bay
                            if(!$presence) 
							{
							
                                $errorRecord = New-ErrorRecord ArgumentNullException ParametersNotSpecified InvalidArgument 'Copy-HPOVProfile' -Message "The bay number $thisBay is not valid or not present."

                                $PSCmdlet.ThrowTerminatingError($errorRecord)
                            
							}
							
                            else 
							{
							
                                $profile.enclosureGroupUri = $thisEnc.uri
                                $profile.enclosureBay = $thisBay
                                $profileDestSHT = $profileSourceSHT
                            
							} 
                        
						}

                        else 
						{
						
                            $profileDestSHT = $serverDevice.serverHardwareTypeUri
							
                        }
						
                    }

                    Catch 
					{
					
                        $PSCmdlet.ThrowTerminatingError($_)
						
                    }
                    
                }

                #Checking if the input is System.String and IS a URI
                elseif (($assign -is [string]) -and ($assign.StartsWith($ServerHardwareUri))) 
				{
                
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Assign to the Server hardware URI: $($assign)"

                    $serverDevice = Send-HPOVRequest $assign -appliance $_Connection
                    $profileDestSHT = $serverDevice.serverHardwareTypeUri
            
                }

                #Checking if the input is PSCustomObject, and the category type is server-profiles, which would be passed via pipeline input
                elseif (($assign -is [PSCustomObject]) -and ($assign.category -ieq "server-hardware")) 
				{
                    
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Assign to the Server object: $($assign.name)"

                    $serverDevice = $assign | ? { $_.applianceConnection.name -eq $_Connection.name }
                    $profileDestSHT = $serverDevice.serverHardwareTypeUri
            
                }

                else 
				{

                    $errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'Copy-HPOVProfile' -Message "The parameter -Assign value is invalid.  Please validate the Assign parameter value you passed and try again."
                    $pscmdlet.ThrowTerminatingError($errorRecord)

                }

                #Checking if the input is PSCustomObject, and the category type is server-hardware, which would be passed via pipeline input
                if ($serverDevice.serverProfileUri) 
				{

                    $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException ServerPropfileResourceAlreadyExists ResourceExists 'Copy-HPOVProfile' -Message "A server profile is already assigned to $($serverDevice.name) ($(Get-HPOVServerProfile $serverDevice.serverProfileUri).name). Please try specify another server."
                    $pscmdlet.ThrowTerminatingError($errorRecord)                
            
                }

            }

            elseif ($assign -ieq "unassigned") 
			{
                
                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Server will be unassigned"

            }

            #Check to see if the SHT is different from the Profile and Target Assign Server
            if (($profileDestSHT -ine $profileSourceSHT) -and ($assign -ine "unassigned") -and (!$profile.enclosureBay))
			{
			
                $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException ServerHardwareTypeMismatch InvalidOperation 'Copy-HPOVProfile' -Message "The Target Server Hardware Type does not match the source Profile Server Hardware Type. Please specify a different Server Hardware Device to assign."
                $pscmdlet.ThrowTerminatingError($errorRecord)          
                    
            }

            #Remove Profile Specifics:
            $profile = $profile | select-object -Property * -excludeproperty uri,etag,created,modified,uuid,status,state,inprogress,serialNumber,enclosureUri,enclosureBay,serverHardwareUri,taskUri #,sanStorage

            $newConnections = New-Object System.Collections.ArrayList
            #Create new connections with excluded properties and add to the newConnections array
            $profile.connections | select-object -property * -excludeproperty mac,wwnn,wwpn,deploymentstatus,interconnectUri, applianceConnection | % {
			
				#Assign the newConnections array to $profile.connections
				[void]$newConnections.Add($_)
			
			}
            $profile.connections = $newConnections

            #Process SAN Volume Attachments
            if ($profile.sanStorage -and $profile.sanStorage.volumeAttachments) 
			{ 

		    	$newVolumeAttachments = @()
		    
		    	Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing SAN Volume Attachments"

		    	ForEach ($attachVolume in $profile.sanStorage.volumeAttachments ) 
				{

		    		$tempVolume = [PSCustomObject]@{}
		    
		    		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Found attached volume ID $($attachVolume.id). Getting Volume properties."

					Try
					{

						$volume = Send-HPOVRequest $attachVolume.volumeUri -appliance $_Connection

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

		    		#Process shared volume
		    		if ($volume.shareable) 
					{
		    
		    			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding Shareable Volume."

		    			$tempVolume = $attachVolume | Select-Object id,volumeUri,lunType,lun,storagePaths
		    			$tempVolume.lun = $Null
		    			$tempVolume.storagePaths = ($attachVolume.storagePaths | % { $_ | select-object * -exclude status } )

		    		}

		    		#Process private volume
		    		else 
					{

		    			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding Private Volume."

		    			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Checking for unique volume name."

		    			#Get list of existing volumes from Index
		    			
						Try
						{
							
							$indexVolumes = Send-HPOVRequest ($indexUri + "?category=storage-volumes&count=-1&start=0&sort=name:asc") -appliance $_Connection

						}

						Catch
						{

							$PSCmdlet.ThrowTerminatingError($_)

						}

		    			$regex = " \((([0-9]|[1-9][0-9]|[1-9][0-9][0-9])+)\)"

		    			$tempVolumeName = $volume.name -replace $regex,""

		    			for ($i = 1; $i -le $volume.name.length; $i++) 
						{
		    			
		    				if (-not ($indexVolumes.members -contains ($tempVolumeName + " ($i)"))) 
							{
		    
		    					$attachVolumeName = $tempVolumeName + " ($i)"
		    					
		    					#verify the name is unique by searching the index.
								Try
								{
								
									$results = Send-HPOVRequest ($indexUri + "?category=storage-volumes&filter=name='$attachVolumeName'&count=-1&start=0&sort=name:asc") -appliance $_Connection
								
								}
		    					
								Catch
								{
								
									$PSCmdlet.ThrowTerminatingError($_)
								
								}

		    					if ($results.count -eq 0) 
								{	

		    						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Setting Volume Name to '$attachVolumeName'."
		    						break

		    					}

		    				}

		    			}

		    			$tempVolume | Add-Member -NotePropertyName id -NotePropertyValue $attachVolume.id
		    			$tempVolume | Add-Member -NotePropertyName volumeName -NotePropertyValue $attachVolumeName
		    			$tempVolume | Add-Member -NotePropertyName volumeUri -NotePropertyValue $Null
		    			$tempVolume | Add-Member -NotePropertyName volumeStoragePoolUri -NotePropertyValue $attachVolume.volumeStoragePoolUri 
		    			$tempVolume | Add-Member -NotePropertyName volumeStorageSystemUri  -NotePropertyValue $attachVolume.volumeStorageSystemUri 
		    			$tempVolume | Add-Member -NotePropertyName volumeProvisionType  -NotePropertyValue $volume.provisionType
		    			$tempVolume | Add-Member -NotePropertyName volumeProvisionedCapacityBytes  -NotePropertyValue $volume.provisionedCapacity
		    			$tempVolume | Add-Member -NotePropertyName volumeShareable   -NotePropertyValue $False
		    			$tempVolume | Add-Member -NotePropertyName lunType   -NotePropertyValue $attachVolume.lunType
		    			
		    			if ($attachVolume.lunType -eq "Auto") { $tempVolume | Add-Member -NotePropertyName lun  -NotePropertyValue $Null }
		    			else { $tempVolume | Add-Member -NotePropertyName lun  -NotePropertyValue $attachVolume.lun }
		    			
		    			$tempVolume | Add-Member -NotePropertyName storagePaths  -NotePropertyValue ($attachVolume.storagePaths | % { $_ | select-object * -exclude status } )
		    			$tempVolume | Add-Member -NotePropertyName permanent -NotePropertyValue $volume.isPermanent

		    		}

		    		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Copied volume details: $($tempVolume | out-string)"

		    		$newVolumeAttachments += $tempVolume

		    	}

		    	$profile.sanStorage.volumeAttachments = $newVolumeAttachments
	
		    }

            #If DestinationName is provided, change to the profile name to value
            if ($DestinationName) 
			{

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] New Server Profile name provided $($DestinationName)"
                $profile.name = $destinationName
            
            }
            
            #If no DestinationName is provided, add "Copy Of " prefix.
            else 
			{

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No new Server Profile name provided. Setting to `"Copy of $($profile.name)`""
                $profile.name = "Copy of " + $profile.name

            }

            #If the server hardware device is present, add the property to the object
            if ($serverDevice) 
			{

                $profile | Add-Member @{ serverHardwareUri = $serverDevice.Uri }
            
            }

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] New Server Profile object: $($profile | out-string)"
            
            #Send request to create new copied profile
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request"
			
			Try
			{
			
				$resp = Send-HPOVRequest $script:ServerProfilesUri POST $profile -appliance $_Connection
			
			}
			
			Catch
			{
			
				$PSCmdlet.ThrowTerminatingError($_)
			
			}
            
            [void]$taskCollection.Add($resp)
        }

    }

    End 
	{
        
        return $taskCollection
    }

}

function Remove-HPOVServerProfile 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "default", SupportsShouldProcess = $True, ConfirmImpact = 'High')]
    Param 
    (

        [parameter (Mandatory = $true,ValueFromPipeline = $true, ParameterSetName = "default", HelpMessage = "Specify the profile(s) to remove.", Position = 0)]
        [ValidateNotNullOrEmpty()]
        [Alias('uri','name','profile')]
        [Object]$ServerProfile = $null,

        [parameter(Mandatory = $false)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions},

        [parameter (Mandatory = $false,ValueFromPipeline = $false, ParameterSetName = "default", HelpMessage = "Specify to force-remove the profile.")]
        [Switch]$force
    
    )

   Begin 
   {

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}
        
		if($ApplianceConnection.count -gt 1)
		{

			# Check for appliance specific URI parameters and error if more than one appliance connection supplied
			if (($ServerProfile -is [string]) -and ($ServerProfile.StartsWith($script:ServerProfilesUri))) 
			{
                    
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] SourceName is a Server Profile URI: $($ServerProfile)"
				$errorRecord = New-ErrorRecord ArgumentNullException ParametersNotSpecified InvalidArgument 'Remove-HPOVServerProfile' -Message "The input parameter 'profile' is a resource URI. For multiple appliance connections this is not supported."
				$PSCmdlet.ThrowTerminatingError($errorRecord)
			}

			if (($ServerProfile -is [array]) -and ($ServerProfile.getvalue(0).gettype() -is [string]) -and $ServerProfile -match '/rest/') 
			{
                
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Assign is a Server Profile URI: $($SourceName)"
				$errorRecord = New-ErrorRecord ArgumentNullException ParametersNotSpecified InvalidArgument 'Remove-HPOVServerProfile' -Message "The input parameter 'profile' is a resource URI. For multiple appliance connections this is not supported."
				$PSCmdlet.ThrowTerminatingError($errorRecord)
            
			}

		}

        $taskCollection = New-Object System.Collections.ArrayList
        $thisConnection = $ApplianceConnection.name

    }

    Process 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Profile input type:  $($ServerProfile.gettype())"

        foreach ($prof in $ServerProfile) 
		{

            $profileNameOrUri   = $null
            $profileDisplayName = $null

            if ($prof -is [String]) 
			{

                $profileNameOrUri   = $prof
                $profileDisplayName = $prof
        	}

            elseif ($prof -is [PSCustomObject] -and $prof.category -ieq 'server-profiles') 
			{
                
                $thisConnection     = $prof.ApplianceConnection.name
                $profileNameOrUri   = $prof.uri
                $profileDisplayName = $prof.name

            }

		    else 
			{

                $errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'Remove-HPOVServerProfile' -Message "Invalid profile parameter: $prof"
                $pscmdlet.ThrowTerminatingError($errorRecord)
            }

            if (!$profileNameOrUri) 
			{
                $errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'Remove-HPOVServerProfile' -Message "Invalid profile parameter: $prof"
                $pscmdlet.ThrowTerminatingError($errorRecord)

            }

            elseif ($pscmdlet.ShouldProcess($thisConnection,"Remove profile $profileDisplayName from appliance?"))
			{   
                
                if ([bool]$force) { Remove-HPOVResource -nameOrUri $profileNameOrUri -force -appliance $thisConnection}
                else { Remove-HPOVResource -nameOrUri $profileNameOrUri -appliance $thisConnection}

            }

	    }

    }

}

function Get-HPOVServerProfileConnectionList 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml
	
	[CmdLetBinding()]
    Param 
    (
        [parameter(Mandatory = $false)]
        [ValidateNotNullOrEmpty()]
        [string]$name=$null,

        [parameter(Mandatory = $false)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}
    )

    Begin 
    {

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0

        ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
            {
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
            {

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
            {

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

        $allConnections = New-Object System.Collections.ArrayList

    }

    Process 
	{
	    
        ForEach($_Connection in $ApplianceConnection)
		{

            $profiles = New-Object System.Collections.ArrayList
    
            #get profiles
            if ($name)
            {

				$uri = $ServerProfilesUri + "?filter=`"name='$name'`"";

				Try
				{

					$profile = (Send-HPOVRequest $uri -appliance $_Connection).members

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

				if (-not ($profile)) 
				{ 

					$errorRecord = New-ErrorRecord InvalidOperationException ProfileResourceNotFound ObjectNotFound 'Get-HPOVServerProfileConnectionList' - Message "Server Profile '$name' was not found."
					$pscmdlet.ThrowTerminatingError($errorRecord)
                
				}
            
				[void]$profiles.Add($profile)
    
			} 

		    else 
			{

				Try
				{

					$index = Send-HPOVRequest $profileIndexListUri -appliance $_Connection

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}
                

                if ($index.count -eq 0) 
				{

                    $errorRecord = New-ErrorRecord InvalidOperationException ProfileResourceNotFound ObjectNotFound 'Get-HPOVServerProfileConnectionList' -Message "No Server Profile resources found.  Use New-HPOVServerProfile to create one."
                    $pscmdlet.ThrowTerminatingError($errorRecord)            
                    
                }
    
                foreach ($entry in $index.members)
                {
					Try
					{

						$profile = Send-HPOVRequest $entry.uri -appliance $_Connection

					}

					Catch
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}
    
                    [void]$profiles.Add($profile)

                }     
				       
            }
    
            #get connections
            $conns = New-Object System.Collections.ArrayList

            foreach($p in $profiles)
            {
    
                foreach($c in $p.connections) 
                { 

                    $c | add-member -membertype noteproperty -name cid -value $c.id;
                    $c | add-member -membertype noteproperty -name serverProfile -value $p.name;
                    $c | add-member -membertype NoteProperty -name Network -value (Send-HPOVRequest $c.networkUri -appliance $_Connection).Name
                    $c | Add-Member -NotePropertyName Appliance -NotePropertyValue $_Connection.name

                    #if($c.wwpn) { $c.wwpn = $c.wwpn.Replace(":",""); } else {$c.wwpn = "-" }
					#
                    #if($c.wwnn) { $c.wwnn = $c.wwnn.Replace(":",""); } else {$c.wwnn = "-" } 

                    if($c.boot.targets) 
                    {

                        $c | add-member -membertype noteproperty -name arrayTarget -value $c.boot.targets[0].arrayWwpn
                        $c | add-member -membertype noteproperty -name lun -value $c.boot.targets[0].lun

                    }
    
                    if($c.portId) 
					{ 

		    		    $c.portId = $c.portId.Replace("Flexible", "")

		    		} 

		    		else 
					{
						 
		    		    $name = "Dev:" + $c.deviceNumber + '-' + $c.physicalPortNumber

                        $c | add-member -membertype noteproperty -name portId -value $name

                    }
    
                   if($c.boot) { $c.boot = $c.boot.priority; }

                   if($c.boot -eq "NotBootable") { $c.boot = "-"; }      
                   
                   [void]$conns.Add($c)

                }

            }

            #output
            [void]$allConnections.Add($conns)
        
        }   

    }
    
    End 
	{

        $allConnections | Sort-Object serverProfile, cid | format-table -Property serverProfile, cid, portId, functionType, Network, mac, wwpn, boot, arrayTarget, lun, Appliance  -AutoSize

    } 

}

function New-HPOVServerProfileConnection 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml
	
	[CmdLetBinding(DefaultParameterSetName = "Ethernet")]
    Param 
    (

        [parameter(Position = 0, Mandatory = $true, ParameterSetName = "Ethernet")]
		[parameter(Position = 0, Mandatory = $true, ParameterSetName = "FC")]
		[parameter(Position = 0, Mandatory = $true, ParameterSetName = "UserDefinedEthernet")]
		[parameter(Position = 0, Mandatory = $true, ParameterSetName = "UserDefinedFC")]
		[parameter(Position = 0, Mandatory = $true, ParameterSetName = "bootEthernet")]
		[parameter(Position = 0, Mandatory = $true, ParameterSetName = "bootFC")]
		[parameter(Position = 0, Mandatory = $true, ParameterSetName = "bootUserDefinedEthernet")]
		[parameter(Position = 0, Mandatory = $true, ParameterSetName = "bootUserDefinedFC")]
		[ValidateNotNullOrEmpty()]
		[Alias('id')]
        [int]$ConnectionID = 1,

        [parameter(Position = 1, Mandatory = $true, ParameterSetName = "Ethernet")]
		[parameter(Position = 1, Mandatory = $true, ParameterSetName = "FC")]
		[parameter(Position = 1, Mandatory = $true, ParameterSetName = "UserDefinedEthernet")]
		[parameter(Position = 1, Mandatory = $true, ParameterSetName = "UserDefinedFC")]
		[parameter(Position = 1, Mandatory = $true, ParameterSetName = "bootEthernet")]
		[parameter(Position = 1, Mandatory = $true, ParameterSetName = "bootFC")]
		[parameter(Position = 1, Mandatory = $true, ParameterSetName = "bootUserDefinedEthernet")]
		[parameter(Position = 1, Mandatory = $true, ParameterSetName = "bootUserDefinedFC")]
		[ValidateNotNullOrEmpty()]
	    [ValidateSet("Ethernet", "FibreChannel","Eth","FC", IgnoreCase=$true)]
		[Alias('type')]
		[string]$ConnectionType = "Ethernet",

        [parameter(Position = 2, Mandatory = $true, ValueFromPipeline = $True, ParameterSetName = "Ethernet")]
	    [parameter(Position = 2, Mandatory = $true, ValueFromPipeline = $True, ParameterSetName = "FC")]
        [parameter(Position = 2, Mandatory = $true, ValueFromPipeline = $True, ParameterSetName = "UserDefinedEthernet")]
		[parameter(Position = 2, Mandatory = $true, ValueFromPipeline = $True, ParameterSetName = "UserDefinedFC")]
	    [parameter(Position = 2, Mandatory = $true, ValueFromPipeline = $True, ParameterSetName = "bootEthernet")]
		[parameter(Position = 2, Mandatory = $true, ValueFromPipeline = $True, ParameterSetName = "bootFC")]
		[parameter(Position = 2, Mandatory = $true, ValueFromPipeline = $True, ParameterSetName = "bootUserDefinedEthernet")]
		[parameter(Position = 2, Mandatory = $true, ValueFromPipeline = $True, ParameterSetName = "bootUserDefinedFC")]
		[ValidateNotNullOrEmpty()]
        [object]$Network,

        [parameter(Position = 3, Mandatory = $false, ParameterSetName = "Ethernet")]
		[parameter(Position = 3, Mandatory = $false, ParameterSetName = "FC")]
        [parameter(Position = 3, Mandatory = $false, ParameterSetName = "UserDefinedEthernet")]
		[parameter(Position = 3, Mandatory = $false, ParameterSetName = "UserDefinedFC")]
		[parameter(Position = 3, Mandatory = $false, ParameterSetName = "bootEthernet")]
		[parameter(Position = 3, Mandatory = $false, ParameterSetName = "bootFC")]
		[parameter(Position = 3, Mandatory = $false, ParameterSetName = "bootUserDefinedEthernet")]
		[parameter(Position = 3, Mandatory = $false, ParameterSetName = "bootUserDefinedFC")]
		[ValidateNotNullOrEmpty()]
        [string]$PortId = "Auto",

        [parameter(Position = 4, Mandatory = $false, ParameterSetName = "Ethernet")]
		[parameter(Position = 4, Mandatory = $false, ParameterSetName = "FC")]
        [parameter(Position = 4, Mandatory = $false, ParameterSetName = "UserDefinedEthernet")]
		[parameter(Position = 4, Mandatory = $false, ParameterSetName = "UserDefinedFC")]
		[parameter(Position = 4, Mandatory = $false, ParameterSetName = "bootEthernet")]
		[parameter(Position = 4, Mandatory = $false, ParameterSetName = "bootFC")]
		[parameter(Position = 4, Mandatory = $false, ParameterSetName = "bootUserDefinedEthernet")]
		[parameter(Position = 4, Mandatory = $false, ParameterSetName = "bootUserDefinedFC")]
		[ValidateNotNullOrEmpty()]
        [string]$Name = $Null,

	    [parameter(Mandatory = $false, ParameterSetName = "Ethernet")]
		[parameter(Mandatory = $false, ParameterSetName = "FC")]
        [parameter(Mandatory = $false, ParameterSetName = "UserDefinedEthernet")]
		[parameter(Mandatory = $false, ParameterSetName = "UserDefinedFC")]
		[parameter(Mandatory = $false, ParameterSetName = "bootEthernet")]
		[parameter(Mandatory = $false, ParameterSetName = "bootFC")]
		[parameter(Mandatory = $false, ParameterSetName = "bootUserDefinedEthernet")]
		[parameter(Mandatory = $false, ParameterSetName = "bootUserDefinedFC")]
		[ValidateNotNullOrEmpty()]
		[ValidateRange(100,10000)]
        [int]$RequestedBW = 2500,
	
		[parameter(Mandatory = $true, ParameterSetName = "UserDefinedEthernet")]
		[parameter(Mandatory = $true, ParameterSetName = "UserDefinedFC")]
		[parameter(Mandatory = $true, ParameterSetName = "bootUserDefinedEthernet")]
		[parameter(Mandatory = $true, ParameterSetName = "bootUserDefinedFC")]
        [ValidateNotNullOrEmpty()]
        [switch]$UserDefined,

        [parameter(Mandatory = $true, ParameterSetName = "UserDefinedEthernet")]
		[parameter(Mandatory = $true, ParameterSetName = "UserDefinedFC")]
		[parameter(Mandatory = $true, ParameterSetName = "bootUserDefinedEthernet")]
		[parameter(Mandatory = $true, ParameterSetName = "bootUserDefinedFC")]
        [ValidateScript({$_ -match $script:macAddressPattern})]
        [string]$MAC = $Null,
	
		[parameter(Mandatory = $true, ParameterSetName = "UserDefinedFC")]
		[parameter(Mandatory = $true, ParameterSetName = "bootUserDefinedFC")]
        [ValidateScript({$_ -match $script:wwnAddressPattern})]
        [string]$WWNN = $Null,
		
		[parameter(Mandatory = $true, ParameterSetName = "UserDefinedFC")]
		[parameter(Mandatory = $true, ParameterSetName = "bootUserDefinedFC")]
        [ValidateScript({$_ -match $script:wwnAddressPattern})]
        [string]$WWPN = $Null,
	
	    [parameter(Mandatory = $true, ParameterSetName = "bootEthernet")]
		[parameter(Mandatory = $true, ParameterSetName = "bootFC")]
		[parameter(Mandatory = $true, ParameterSetName = "bootUserDefinedEthernet")]
		[parameter(Mandatory = $true, ParameterSetName = "bootUserDefinedFC")]
        [ValidateNotNullOrEmpty()]
        [switch]$Bootable,
	
		[parameter(Mandatory = $true, ParameterSetName = "bootEthernet")]
		[parameter(Mandatory = $true, ParameterSetName = "bootFC")]
		[parameter(Mandatory = $true, ParameterSetName = "bootUserDefinedEthernet")]
		[parameter(Mandatory = $true, ParameterSetName = "bootUserDefinedFC")]
		[ValidateNotNullOrEmpty()]
	    [ValidateSet("UseBIOS", "Primary","Secondary", IgnoreCase=$true)]
		[string]$Priority = "NotBootable",
	
		[parameter(Mandatory = $true, ParameterSetName = "bootFC")]
		[parameter(Mandatory = $true, ParameterSetName = "bootUserDefinedFC")]
		[ValidateScript({$_ -match $script:wwnAddressPattern})]
		[string]$ArrayWwpn = $null,
	
		[parameter(Mandatory = $true, ParameterSetName = "bootFC")]
		[parameter(Mandatory = $true, ParameterSetName = "bootUserDefinedFC")]
		[ValidateRange(0,254)]
		[int]$LUN = 0,

        [parameter(Mandatory = $false)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}
	
	)
	
	Begin 
    {

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0

        ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
            {
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
            {

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
            {

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] ParameterSet: + $($PsCmdLet.ParameterSetName)"
				
        #Init object collection
        $_Connections = New-Object System.Collections.ArrayList

	}

	Process 
    {


        ForEach ($_net in $network) 
		{

            $_conn = NewObject -ProfileConnection
                
            $_conn.id                  = [Int]$connectionId;
		    $_conn.functionType        = [String]$connectionType;
            $_conn.name                = [String]$name;
		    $_conn.portId              = [String]$portId; 
		    $_conn.networkUri          = [String]$null; 
		    $_conn.requestedMbps       = [Int]$requestedBW; 
		    $_conn.boot.priority       = $priority
            $_conn.ApplianceConnection = $_net.ApplianceConnection

            switch ($_net.Gettype().Name) 
            {

				"PSCustomObject" 
				{

					if ("fcoe-networks", "fc-networks", "ethernet-networks", "network-sets" -contains $_net.category ) 
					{
                
						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Network resource provided via parameter"
						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Network Name:  $($_net.name)"
						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Network Category:  $($_net.category)"
						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User specified '$($connectionType)' ConnectionType"

						$_conn.networkUri = $_net.uri

						"[$($MyInvocation.InvocationName.ToString().ToUpper())] Setting Connection 'functionType' to {0}" -f $ServerProfileConnectionTypeEnum[$_net.category] | Write-Verbose 

						$_conn.functionType = $ServerProfileConnectionTypeEnum[$_net.category]
                
					}

					#Generate Error due to incorrect cagtegory
					else 
					{

						$errorRecord = New-ErrorRecord HPOneView.ServerProfileConnectionException InvalidNetworkCategory InvalidArgument 'New-HPOVServerProfileConnection' -Message "The -Network value category '$($_net.category)' is not 'ethernet-networks', 'fc-networks' or 'network-sets'.  Please check the value and try again."
		    			$PSCmdlet.ThrowTerminatingError($errorRecord)

					}

				}

				default 
				{

					$errorRecord = New-ErrorRecord HPOneView.ServerProfileConnectionException InvalidNetworkCategory InvalidArgument 'New-HPOVServerProfileConnection' -Message "The -Network paramter is an invalid type. Please supply a network object or object collection."
		    		$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

			}
	
		    #write an error and break if the network category does not match the connection type requested
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Network Type: $($_conn.functionType)"

		    If ($_conn.functionType -ne $connectionType)
            {

                $errorRecord = New-ErrorRecord InvalidOperationException NetworkTypeMismatch InvalidOperation 'ConnectionType' -Message "The Connection type '$($_conn.functionType)' is a mismatch to the requested connection type $connectionType. Please provide a valid connection type that matches the network."
		    	$PSCmdlet.ThrowTerminatingError($errorRecord)

		    }
		    
		    #Set conneciton boot settings
            if ($PSboundParameters['bootable']) 
            {

                $_conn.boot.priority = $priority

                if ($connectionType -eq 'fibrechannel') 
                {

					If(-not ($arrayWwpn))
					{
				
						$errorRecord = New-ErrorRecord HPOneView.ServerProfileConnectionException InvalidFcBootTargetParameters InvalidArgument 'New-HPOVServerProfileConnection' -Message "FC Boot specified, and no array target WWPN is provided."
						$PSCmdlet.ThrowTerminatingError($errorRecord)

					}

					$bootTarget = NewObject -ProfileConnectionFcBootTarget
					
					$bootTarget.arrayWwpn = $arrayWwpn
					$bootTarget.lun       = $lun.ToString()

					[void]$_conn.boot.targets.Add($bootTarget)

				}

            }

		    if ($PSboundParameters['userDefined'])
            {

				if ($connectionType -eq "Ethernet")
				{

    				$_conn.macType = "UserDefined"
					$_conn.mac     = $mac

				}

				if ($connectionType -eq "FibreChannel")
				{

					$_conn.macType  = "UserDefined" 
					$_conn.mac      = $mac 
					$_conn.wwpnType = "UserDefined" 
					$_conn.wwnn     = $wwnn
					$_conn.wwpn     = $wwpn 

				}


			}

		    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Connection object: $($_conn | ConvertTo-Json)"

            [void]$_Connections.Add($_conn)

        }
        
    }

    End 
	{

		return $_Connections

	}

}

function New-HPOVServerProfileLogicalDisk 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml
	
	[CmdLetBinding(DefaultParameterSetName = "Default")]
    Param 
    (

		[parameter(Position = 0, Mandatory, ParameterSetName = "Default")]
		[ValidateNotNullOrEmpty()]
        [string]$Name = $Null,

        [parameter(Position = 1, Mandatory = $false, ParameterSetName = "Default")]
		[ValidateSet('RAID0','RAID1')]
        [string]$RAID = 'RAID1',

        [parameter(Position = 2, Mandatory = $false , ParameterSetName = "Default")]
		[ValidateRange(1,2)]
		[int]$NumberofDrives = 2,

        [parameter(Position = 3, Mandatory = $false, ParameterSetName = "Default")]
		[ValidateSet('SAS','SATA','SASSSD','SATASSD','Auto')]
        [string]$DriveType = 'Auto',

        [parameter(Position = 4, Mandatory = $false, ParameterSetName = "Default")]
		[ValidateNotNullOrEmpty()]
        [bool]$Bootable = $False

	)
	
	Begin 
    {

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Helper cmdlet does not require authentication."
				
        #Init object collection
        $_LogicalDiskCol = New-Object System.Collections.ArrayList

	}

	Process 
    {

        $_LogicalDisk = NewObject -ServerProfileLocalStorageLogicalDrive

		$_LogicalDisk.driveName         = $Name
		$_LogicalDisk.bootable          = [bool]$Bootable
		$_LogicalDisk.raidLevel         = $RAID.ToUpper()
		$_LogicalDisk.numPhysicalDrives = $NumberofDrives
		$_LogicalDisk.driveTechnology   = $LogicalDiskTypeEnum[$DriveType]

		"[$($MyInvocation.InvocationName.ToString().ToUpper())] Created Logical Disk object: {0}" -f ($DriveType | fl *) | Write-Verbose

		[void]$_LogicalDiskCol.Add($_LogicalDisk)
        
    }

    End 
	{

		"[$($MyInvocation.InvocationName.ToString().ToUpper())] Returning collection: {0}" -f $_LogicalDiskCol.count | Write-Verbose

		return $_LogicalDiskCol

	}

}

function New-HPOVServerProfileAttachVolume 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml
	
	[CmdLetBinding(DefaultParameterSetName = "Default")]
    Param 
    (

		[parameter(Mandatory, ParameterSetName = "ServerProfileObject")]
		[parameter(Mandatory, ParameterSetName = "ServerProfileObjectEphmeralVol")]
		[ValidateNotNullOrEmpty()]
		[Object]$ServerProfile,
		
		[parameter(Mandatory = $False, ParameterSetName = "ServerProfileObject")]
		[parameter(Mandatory = $False, ParameterSetName = "ServerProfileObjectEphmeralVol")]
        [parameter(Mandatory = $False, ParameterSetName = "Default")]
        [parameter(Mandatory = $False, ParameterSetName = "ManualLunIdType")]
        [parameter(Mandatory = $False, ParameterSetName = "DynamicVolAttachAuto")]
        [parameter(Mandatory = $False, ParameterSetName = "DynamicVolAttachManual")]
		[ValidateNotNullOrEmpty()]
		[Alias('id')]
        [int]$VolumeID = 1,

		[parameter(Mandatory, ParameterSetName = "ServerProfileObject")]
        [parameter(Mandatory, ValueFromPipeline, ParameterSetName = "Default")]
        [parameter(Mandatory, ValueFromPipeline, ParameterSetName = "ManualLunIdType")]
		[ValidateNotNullOrEmpty()]
        [Object]$Volume,

		[parameter(Mandatory, ParameterSetName = "ServerProfileObjectEphmeralVol")]
        [parameter(Mandatory, ParameterSetName = "DynamicVolAttachAuto")]
        [parameter(Mandatory, ParameterSetName = "DynamicVolAttachManual")]
		[ValidateNotNullOrEmpty()]
        [object]$Name,

		[parameter(Mandatory, ParameterSetName = "ServerProfileObjectEphmeralVol")]
        [parameter(Mandatory, ValueFromPipeline = $True, ParameterSetName = "DynamicVolAttachAuto")]
        [parameter(Mandatory, ValueFromPipeline = $True, ParameterSetName = "DynamicVolAttachManual")]
		[ValidateNotNullOrEmpty()]
        [object]$StoragePool,

		[parameter(Mandatory = $False, ParameterSetName = "ServerProfileObjectEphmeralVol")]
        [parameter(Mandatory = $False, ParameterSetName = "DynamicVolAttachAuto")]
        [parameter(Mandatory = $False, ParameterSetName = "DynamicVolAttachManual")]
		[ValidateNotNullOrEmpty()]
        [object]$StorageSystem,

		[parameter(Mandatory = $False, ParameterSetName = "ServerProfileObjectEphmeralVol")]
        [parameter(Mandatory = $False, ParameterSetName = "DynamicVolAttachAuto")]
        [parameter(Mandatory = $False, ParameterSetName = "DynamicVolAttachManual")]
		[ValidateNotNullOrEmpty()]
        [int64]$Capacity,

		[parameter(Mandatory = $False, ParameterSetName = "ServerProfileObjectEphmeralVol")]
        [parameter(Mandatory = $False, ParameterSetName = "DynamicVolAttachAuto", HelpMessage = "Create Thick provisioned volume.")]
        [parameter(Mandatory = $False, ParameterSetName = "DynamicVolAttachManual", HelpMessage = "Create Thick provisioned volume.")]
        [switch]$Full,

		[parameter(Mandatory = $False, ParameterSetName = "ServerProfileObjectEphmeralVol")]
        [parameter(Mandatory = $False, ParameterSetName = "DynamicVolAttachAuto")]
        [parameter(Mandatory = $False, ParameterSetName = "DynamicVolAttachManual")]
        [switch]$Permanent,

		[parameter(Mandatory = $False, ParameterSetName = "ServerProfileObject")]
		[parameter(Mandatory = $False, ParameterSetName = "ServerProfileObjectEphmeralVol")]
        [parameter(Mandatory = $False, ParameterSetName = "Default")]
        [parameter(Mandatory = $True, ParameterSetName = "ManualLunIdType")]
        [parameter(Mandatory = $False, ParameterSetName = "DynamicVolAttachAuto")]
        [parameter(Mandatory = $True, ParameterSetName = "DynamicVolAttachManual")]
	    [ValidateSet("Auto","Manual", IgnoreCase=$true)]
		[Alias('type')]
        [string]$LunIdType = "Auto",

		[parameter(Mandatory = $False, ParameterSetName = "ServerProfileObject")]
		[parameter(Mandatory = $False, ParameterSetName = "ServerProfileObjectEphmeralVol")]
        [parameter(Mandatory, ParameterSetName = "ManualLunIdType")]
        [parameter(Mandatory, ParameterSetName = "DynamicVolAttachManual")]		
        [ValidateRange(0,254)]
        [int]$LunID,

		[parameter(Mandatory = $false, ParameterSetName = "ServerProfileObject")]
		[parameter(Mandatory = $false, ParameterSetName = "ServerProfileObjectEphmeralVol")]
        [parameter(Mandatory = $false, ParameterSetName = "Default")]
        [parameter(Mandatory = $false, ParameterSetName = "ManualLunIdType")]
        [parameter(Mandatory = $false, ParameterSetName = "DynamicVolAttachAuto")]
        [parameter(Mandatory = $false, ParameterSetName = "DynamicVolAttachManual")]
		[ValidateRange(1,32)]
        [int]$ProfileConnectionID,

		[parameter(Mandatory = $false, ParameterSetName = "ServerProfileObject")]
		[parameter(Mandatory = $false, ParameterSetName = "ServerProfileObjectEphmeralVol")]
		[ValidateSet('CitrixXen','AIX','IBMVIO','RHEL4','RHEL3','RHEL','RHEV','VMware','Win2k3','Win2k8','Win2k12','OpenVMS','Egenera','Exanet','Solaris9','Solaris10','Solaris11','ONTAP','OEL','HPUX11iv1','HPUX11iv2','HPUX11iv3','SUSE','SUSE9','Inform')]
        [Alias('OS')]
        [string]$HostOStype,

        [parameter(Mandatory = $false, ValueFromPipelineByPropertyName)]
		[ValidateNotNullOrEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

	)
	
	Begin 
    {

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		If (-not($ServerProfile) -and -not($Volume))
		{

			$PipelineInput = $True

		}

		else
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
			$c = 0

			ForEach ($_Connection in $ApplianceConnection) 
			{

				Try 
				{
			
					$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

				}

				Catch [HPOneview.Appliance.AuthSessionException] 
				{

					$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				Catch 
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

				$c++

			}

		}        
		
		#Write-Verbose -message ("ParameterSet: " + $PsCmdLet.ParameterSetName)

        if ($LunIdType -eq "Manual" -and (-not($PSBoundParameters.ContainsKey("LunId"))))
        { 
        
            $errorRecord = New-ErrorRecord ArgumentNullException ParametersNotSpecified InvalidArgument 'New-HPOVServerProfileAttachVolume' -Message "'Manual' LunIdType was specified, but no LUN ID value was provided.  Please include the -LunId parameter or a value in the parameters position and try again."
            $PSCmdlet.ThrowTerminatingError($errorRecord)

        }

        if ($LunIdType -eq "Auto" -and $PSBoundParameters.ContainsKey("LunId")) 
        { 
        
            $errorRecord = New-ErrorRecord ArgumentException ParametersSpecifiedCollision InvalidArgument 'New-HPOVServerProfileAttachVolume' -Message "'Auto' LunIdType was specified and a specific LUN ID were provided.  Please either specify -LunIdType 'Manual' or omit the -LunId parameter and try again."
            $PSCmdlet.ThrowTerminatingError($errorRecord)

        }

        #If volume parameter is passed as URI validate that only one appliance connection is present
        if ($PSBoundParameters['volume']) 
        {

            if (($volume -is [String] -and $volume.StartsWith($script:storageVolumeUri)) -or ($volume -is [String] -and $volume.StartsWith("/rest"))) 
            {

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Volume URI was provided."

                if($ApplianceConnection.Count -ne 1)
                {

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Multiple appliance connections identified with volume URI parameter."
                    $errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'New-HPOVServerProfileAttachVolume' -Message "The Volume URI parameter is invalid with multiple appliance connections."
                    $PSCmdlet.ThrowTerminatingError($errorRecord)

                }

            }

        }

        #If StoragePool parameter is present and passed as URI validate only one appliance connection is present
        if ($PSBoundParameters['StoragePool']) 
        {
            
            if (($StoragePool -is [string] -and $StoragePool.StartsWith($script:storagePoolUri)) -or ($StoragePool -is [string] -and $StoragePool.StartsWith("/rest"))) 
            {

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Storage Pool URI provided: $StoragePool"

                if($ApplianceConnection.Count -ne 1)
                {

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Multiple appliance connections identified with storage pool URI parameter."
                    $errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'New-HPOVServerProfileAttachVolume' -Message "The StoragePool URI parameter is invalid with multiple appliance connections."
                    $PSCmdlet.ThrowTerminatingError($errorRecord)
                }

            }

        }

		if ($PSBoundParameters['ServerProfile'])
		{

			if ($ServerProfile.GetType().Name -ne 'PSCustomObject')
			{

				$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException UnsupportedServerHardwareResource InvalidArgument 'ServerProfile' -TargetType $ServerProfile.GetType().Name -Message ("The provided Server Profile {0} is not an Object.  Please provide a Server Profile object." -f $ServerProfile)
		    	$pscmdlet.ThrowTerminatingError($errorRecord)  

			}

		}

        #Initialize collection to hold multiple volume attachments objects
        $_volumeAttachments = New-Object System.Collections.ArrayList

    }

	Process 
    {

        ForEach ($_Connection in $ApplianceConnection) 
        {

            $volumeAttachment = NewObject -ServerProfileStorageVolume

            if ($PSBoundParameters['volume']) 
            {

                if ($volume -is [String] -and (-not($volume.StartsWith($script:storageVolumeUri)))) 
                {
                    
                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Volume Name was provided."

                    $tmpVolumeName = $volume

                    Try
                    {
                    
                        $volume = Get-HPOVStorageVolume $volume -appliance $_Connection

                    }

                    Catch
                    {

                        $PSCmdlet.ThrowTerminatingError($_)

                    }

                    if (-not($volume))
                    {

                        $errorRecord = New-ErrorRecord InvalidOperationException StorageVolumeResourceNotFound ObjectNotFound 'volume' -Message "Storage Volume name '$tmpVolumeName' was not found. Check the name and try again."
                        $PSCmdlet.ThrowTerminatingError($errorRecord)

                    }
                    		
                }

                elseif ($volume -is [String] -and $volume.StartsWith($script:storageVolumeUri)) 
                {

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Volume URI was provided."
                    
                    $tmpVolumeUri = $volume
                    
                    Try 
                    {

                        $volume = Send-HPOVRequest $volume -appliance $ApplianceConnection

                    }

                    catch
                    {

                        $PSCmdlet.ThrowTerminatingError($_)

                    }

                    if ($volume.errorCode -and [int]$volume.statusCode -eq 404) 
                    {

                        $errorRecord = New-ErrorRecord InvalidOperationException StorageVolumeResourceNotFound ObjectNotFound 'New-HPOVServerProfileAttachVolume' -Message "Storage Volume URI '$tmpVolumeUri' was not found. Check the value and try again."
                        $PSCmdlet.ThrowTerminatingError($errorRecord)

                    }

                    elseif ($volume.errorCode) 
                    {

                        $errorRecord = New-ErrorRecord InvalidOperationException $volume.errorCode InvalidResult 'New-HPOVServerProfileAttachVolume' -Message $volume.message
                        $PSCmdlet.ThrowTerminatingError($errorRecord)

                    }

                }

                elseif ($volume -is [String]) 
                {

                    #Volume parameter value is not valid, generate error.
                    $errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'New-HPOVServerProfileAttachVolume' -Message "The Volume parameter contains an invalid value.  Please check it and try again."
                    $PSCmdlet.ThrowTerminatingError($errorRecord)
            
                }

                $volumeAttachment.volumeUri              = $volume.uri
                $volumeAttachment.volumeStoragePoolUri   = $volume.storagePoolUri
                $volumeAttachment.volumeStorageSystemUri = $volume.storageSystemUri

                #Needs to be part of the
                if ($LunIdType -eq "Manual") 
                { 
        
                    #$volumeAttachment | Add-Member -type NoteProperty -Name "lun" -value $LunID 
                    $volumeAttachment.lun = $LunID 
            
                }

            }

            #Ephmeral Volume Support
            elseif ($PSBoundParameters['StoragePool']) 
            {

                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Creating dynamic volume attach object."
                
                $volumeAttachment = NewObject -EphemeralStorageVolume
                $volumeAttachment.volumeStoragePoolUri           = $sp.uri
                $volumeAttachment.volumeStorageSystemUri         = $sp.storageSystemUri
                $volumeAttachment.volumeName                     = $Name
                $volumeAttachment.volumeProvisionType            = if ($PSBoundParameters['full']) { "Thick" } else { "Thin" }
                $volumeAttachment.volumeProvisionedCapacityBytes = if ($PSBoundParameters['Capacity']) { [string]([int64]$Capacity * 1GB) } else { $volumeAttachment.volumeProvisionedCapacityBytes }

                switch ($StoragePool.GetType().Name) 
                {

                    "String" 
                    { 
                    
                        if ($StoragePool.StartsWith($script:storagePoolUri)) 
                        {
                        
                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Storage Pool URI provided: $StoragePool"

                            Try
                            {
                                
                                $sp = Send-HPOVRequest $StoragePool -appliance $ApplianceConnection

                            }

                            Catch
                            {

                                $PSCmdlet.ThrowTerminatingError($_)

                            }
                        
                         }

                         elseif ($StoragePool.StartsWith("/rest/")) 
                         {
                         
                            #Invalid URI, so error
                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Invalid StoragePool URI provided: $StoragePool"

                            $errorRecord = New-ErrorRecord ArgumentException InvalidStoragePoolURI InvalidArgument 'New-HPOVServerProfileAttachVolume' -Message "The provided URI value for the -StoragePool parameter '$StroagePool' is invalid.  The StoragePool URI must begin with /rest/storage-pools.  Please check the value and try again."
                            $PSCmdlet.ThrowTerminatingError($errorRecord)

                         }

                         else 
                         {
                         
                            if ($StorageSystem) 
                            {
                                
                                #If both storagepool and storagesystem were provided, look that up first

                                Try
                                {
                                
                                    $sp = Get-HPOVStoragePool -poolName $StoragePool -storageSystem $StorageSystem -appliance $ApplianceConnection

                                }

                                Catch
                                {

                                    $PSCmdlet.ThrowTerminatingError($_)

                                }
                            
                            }

                            else 
                            {

                                Try
                                {

                                    #If both storagepool and storagesystem were provided, look that up first
                                    $sp = Get-HPOVStoragePool -poolName $StoragePool -appliance $ApplianceConnection

                                }

                                Catch
                                {

                                    $PSCmdlet.ThrowTerminatingError($_)

                                }

                                if ($sp -and $sp.count -gt 1) 
								{

                                    #Generate Error that StoragePool name is not unique and must supply the StorageSystem as well.
                                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] {$($sp.count)} StoragePool resource found"

                                    $errorRecord = New-ErrorRecord HPOneView.StorageVolumeResourceException MultipleStoragePoolsFound InvalidResult 'New-HPOVServerProfileAttachVolume' -Message "Multiple StoragePool resources found with the name '$StoragePool'.  Please use the -StorageSystem parameter to specify the Storage System the Storage Pool is to be used."
                                    $PSCmdlet.ThrowTerminatingError($errorRecord)

                                }

                            }
                        
                        }
                    
                    }

                    "PSCustomObject" 
                    { 
                    
                        #Validate the object
                        if ($StoragePool.category -eq 'storage-pools') 
						{ 
							
							$sp = $StoragePool 
						
						}

                        else 
                        {

                            $errorRecord = New-ErrorRecord HPOneView.StorageVolumeResourceException InvalidStoragePoolCategory InvalidArgument 'New-HPOVServerProfileAttachVolume' -Message "Invalid -StoragePool parameter value.  Expected Resource Category 'storage-pools', received '$($VolumeTemplate.category)'."
                            $PSCmdlet.ThrowTerminatingError($errorRecord)

                        }              
                    
                    }

                }

                $volumeAttachment.volumeStoragePoolUri   = $sp.uri
                $volumeAttachment.volumeStorageSystemUri = $sp.storageSystemUri           
                
		    	if($shared.IsPresent -and (-not($permanent.IsPresent))) 
                {
		    
		    		$errorRecord = New-ErrorRecord HPOneView.StorageVolumeResourceException InvalidVolumePermanentAndShareState InvalidArgument 'shared' -Message "Unable to create a shared epehemeral storage volume.  Please either remove the -shared switch, or include the -permanent switch to properly create a volume."
                    $PSCmdlet.ThrowTerminatingError($errorRecord)

		    	}

                $volumeAttachment.permanent = [bool]$PSBoundParameters['permanent']

            }

			if (-not($PSBoundParameters['VolumeID']))
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No VolumeID value provided.  Getting next volume id value."

				$id = 1

				$Found = $false

				While (-not($Found))
				{

					if ($ServerProfile.sanStorage.volumeAttachments.volumeId -notcontains $id)
					{

						$VolumeID = $id

						$Found = $true

					}

					$id++

				}

			}

			$volumeAttachment.id = $VolumeID

            if ($LunIdType -ne 'Auto')
			{

				$volumeAttachment.lunType = $LunIdType
				$volumeAttachment.lun     = $LunID

			}

            $volumeAttachment.ApplianceConnection = $_Connection
            
            [void]$_volumeAttachments.Add($volumeAttachment)
        
        }

	}

    End 
    {

		if ($PSBoundParameters['ServerProfile'])
		{

			#Validate Server Profile and Server Hardware resource supports StRM operations
			Try
			{

				$_ServerResource = Send-HPOVRequest $ServerProfile.serverHardwareUri -Hostname $ServerProfile.ApplianceConnection.Name

				if (-not($_ServerResource.model -match 'BL'))
				{
					
					$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException UnsupportedServerHardwareResource InvalidArgument 'ServerProfile' -TargetType 'PSObject' -Message ("The provided Server Profile {0} is not assigned to a supported Server Hardware Resource, {1}.  Only BL Gen 8 or newer are supported." -f $ServerProfile.name, $_ServerResource.model)
		    		$pscmdlet.ThrowTerminatingError($errorRecord)  

				}

				#Validate Server Profile has SanStorage already set.
				if (-not($ServerProfile.sanStorage.manageSanStorage))
				{

					#Generate Error that HostOSType is required
					if (-not($PSBoundParameters['HostOsType']))
					{

						$errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException MissingHostOSTypeParameterValue InvalidArgument -Message "The -HostOSType parmater is required when the Server Profile is not already configured for managing SAN Storage.  Please specify the HostOSType parameter in your call."
		    			$pscmdlet.ThrowTerminatingError($errorRecord)  

					}

					$ServerProfile.sanStorage = [PSCustomObject]@{
                        
						hostOSType        = $ProfileSanManageOSType.($HostOsType);
						manageSanStorage  = $true;
						volumeAttachments = New-Object System.Collections.ArrayList
                    
					}

				}

				#Rebuild VolumeAttachments property to be an ArrayList
				elseif ($ServerProfile.sanStorage.manageSanStorage -and $ServerProfile.sanStorage.volumeAttachments)
				{

					$_ExistingVols = $ServerProfile.sanStorage.volumeAttachments.Clone()
					
					$ServerProfile.sanStorage.volumeAttachments = New-Object System.Collections.ArrayList

					$_ExistingVols | % {

						[void]$ServerProfile.sanStorage.volumeAttachments.Add($_)

					}

				}

				else
				{

					$ServerProfile.sanStorage.volumeAttachments = New-Object System.Collections.ArrayList

				}

				$_EnclosureGroup = Send-HPOVRequest $ServerProfile.enclosureGroupUri -Hostname $ServerProfile.ApplianceConnection.Name

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting list of available storage systems"

            #Get list of available storage system targets and the associated Volumes based on the EG and SHT provided
			Try
			{

				$_AvailStorageSystems = (Send-HPOVRequest ($ProfileAvailStorageSystemsUri + "?enclosureGroupUri=$($serverProfile.enclosureGroupUri)&serverHardwareTypeUri=$($_ServerResource.serverHardwareTypeuri)") -Hostname $ServerProfile.ApplianceConnection.Name).members

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

            "[$($MyInvocation.InvocationName.ToString().ToUpper())] Available Storage Systems: {0}" -f ($_AvailStorageSystems | fl | out-string) | Write-Verbose

            #Error on no available storage systems
            if (-not ($_AvailStorageSystems)) 
			{

                $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException NoAvailableStorageSystems ObjectNotFound 'SANStorage' -Message ("No available storage systems found for '{0}' Server Hardware and '{1}' Enclosure Group.  Please verify an available Storage System exists, and has connectivity to the destination server or Enclosure Group." -f $_ServerResource.name, ((Send-HPOVRequest $ServerProfile.enclosureGroupUri -Hostname $ServerProfile.ApplianceConnection.Name).name))
		    	$pscmdlet.ThrowTerminatingError($errorRecord)  

            }
                    
            "[$($MyInvocation.InvocationName.ToString().ToUpper())] Volumes to process {0}" -f ($_volumeAttachments | fl | out-string) | Write-Verbose 
                    
            $i = 0
                    
            #Process volumes being passed
            foreach ($_volume in $_volumeAttachments) 
			{  

                #If the storage paths array is null, process connections to add mapping
                if (-not ($_volume.storagePaths)) 
				{

                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Storage Paths value is Null. Building connection mapping."

                    #Static Volume, must have volumeUri attribute present to be valid
                    if ($_volume.volumeUri) 
					{

                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting list of attachable volumes"

                        #Get list of attachable Volumes (i.e. they are not assigned private or are shareable volumes)
						Try
						{

							$_AttachableVolumes = (Send-HPOVRequest $AttachableVolumesUri -appliance $ServerProfile.ApplianceConnection.Name).members

							#Get storage volume name for reporting purposes
							$_VolumeName = (send-hpovrequest $_volume.volumeUri -appliance $ServerProfile.ApplianceConnection.Name).name

						}

						Catch
						{

							$PSCmdlet.ThrowTerminatingError($_)

						}

                        "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Volume ID: {0}" -f $_volume.id  | Write-Verbose 
                        "[$($MyInvocation.InvocationName.ToString().ToUpper())] Looking to see if volume '{0} ({1})' is attachable" -f $_volume.volumeUri,$_VolumeName |Write-Verbose 
                    						   
                        #validate volume is attachable
                        $_AttachableVolFound = $_AttachableVolumes | ? uri -eq $_volume.volumeUri

                        #If it is available, continue processing
                        if ($_AttachableVolFound) 
						{
                    
                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] '$($_AttachableVolFound.uri) ($($_AttachableVolFound.name))' volume is attachable"
                    
                            #validate the volume that is available, is also avialable to the server hardware type and enclosure group
                            $_VolumeToStorageSystem = $_AvailStorageSystems | ? storageSystemUri -eq $_AttachableVolFound.storageSystemUri
                    
                            #If available, process the volume networks
                            if ($_VolumeToStorageSystem) 
							{ 
                                    
                                #Check to make sure profile connections exist.
                                if ($ServerProfile.connections -and $ServerProfile.connections.functionType -contains "FibreChannel") 
								{

                                    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Profile has connections"
                                        
                                    #loop through profile connections
                                    $found = 0

                                    foreach ($_volConnection in $_AttachableVolFound.availableNetworks) 
									{

                                        #write-verbose "Looking for $volConnection"
                                        $profileConnection = $ServerProfile.connections | ? networkUri -eq $_volConnection

                                        if ($profileConnection) 
										{

                                            #Keep track of the connections found for error reporting later
                                            $found++

                                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Mapping connection ID '$($profileConnection.id)' -> volume ID '$($_volumeAttachments[$i].id)'"
                                                
                                            $_StoragePath = NewObject -StoragePath

											$_StoragePath.connectionId = $profileConnection.id
											$_StoragePath.isEnabled = $True

											[void]$_volume.storagePaths.Add($_StoragePath)

                                        }

                                    }

                                    if (-not ($found)) 
									{

                                        #Generate non-terminating error and continue
                                        $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException NoProfileConnectionsMapToVolume ObjectNotFound 'New-HPOVServerProfile' -Message "Unable to find a Profile Connection that will map to '$($volumeName)'. Creating server profile resource without Volume Connection Mapping." 
 
                                        $PSCmdlet.WriteError($errorRecord)

                                    }
                                        
                                }

                                #Else, generate an error that at least one FC connection must exist in the profile in order to attach volumes.
                                else 
								{

                                    $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException NoProfileConnections ObjectNotFound 'New-HPOVServerProfile' -Message "The profile does not contain any Network Connections.  The Profile must contain at least 1 FC Connection to attach Storage Volumes.  Use the New-HPOVServerProfileConnection helper cmdlet to create 1 or more connections and try again." 
                                    $PSCmdlet.ThrowTerminatingError($errorRecord)

                                }
                    
                            }
                    
                            #If not, then error
                            elseif (-not($_VolumeToStorageSystem)) 
							{ 
                                
                                $errorRecord = New-ErrorRecord InvalidOperationException StorageVolumeDoesNotExistOnStorageArray ObjectNotFound 'ServerProfile' -TargetType 'PSObject' -Message ("'{0}' Volume is not available on the '{1}' storage system." -f $_VolumeName, $_VolumeToStorageSystem.storageSystemName)
                                $PSCmdlet.ThrowTerminatingError($errorRecord)                      
                                
                            }
                    
                        }
                    
                        elseif (-not ($_AttachableVolFound)) 
						{ 
                            
                            $errorRecord = New-ErrorRecord InvalidOperationException StorageVolumeUnavailableForAttach ResourceUnavailable 'ServerProfile' -TargetType 'PSObject'  -Message ("'{0}' Volume is not available to be attached to the profile. Please check the volume and try again." -f $_VolumeName)
                            $PSCmdlet.ThrowTerminatingError($errorRecord)

                        }

                    }

                    #Ephemeral volume support
                    elseif (-not ($_volume.volumeUri) -and $_volume.volumeStoragePoolUri -and $_volume.volumeStorageSystemUri) 
					{

                        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No volumeUri, ephemeral volume request."

                        #Check to make sure profile connections exist.
                        if ($ServerProfile.connections -and $ServerProfile.connections.functionType -contains "FibreChannel") 
						{

                            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Profile has connections"

                            #Process available storage system and available FC networks
                            $_StorageSystemVolCreate = $_AvailStorageSystems | ? storageSystemUri -eq $_volume.volumeStorageSystemUri

                            if ($_StorageSystemVolCreate) 
							{
                                        
								"[$($MyInvocation.InvocationName.ToString().ToUpper())] Available Storage System targets: {0}" -f ($storageSystemVolCreate.storageSystemUri -join ", ") | Write-Verbose 
                                        
								#loop through profile connections
                                $found = 0

                                foreach ($_storageSystemNetworks in $_StorageSystemVolCreate.availableNetworks) 
								{

                                    $_ProfileConnection = $ServerProfile.connections | ? networkUri -eq $_storageSystemNetworks.uri

                                    if ($_ProfileConnection) 
									{

                                        #Keep track of the connections found for error reporting later
                                        $found++

                                        "[$($MyInvocation.InvocationName.ToString().ToUpper())] Mapping connection ID '{0}' -> volume ID '{1}'" -f $_ProfileConnection.id, $_volumeAttachments[$i].id | Write-Verbose
                                                
										$_StoragePath = NewObject -StoragePath

										$_StoragePath.connectionId = $_ProfileConnection.id
										$_StoragePath.isEnabled    = $True

                                        [void]$_volume.storagePaths.Add($_StoragePath)

                                    }

                                }

                                if (-not($found))
								{

                                    #Generate non-terminating error and continue
                                    $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException NoProfileConnectionsMapToVolume ObjectNotFound 'New-HPOVServerProfile' -Message "Unable to find a Profile Connection that will map to '$($_volume.id)'. Creating server profile resource without Volume Connection Mapping." 

                                    $PSCmdlet.WriteError($errorRecord)

                                    
                                }

                            }

                            else 
							{

                                $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException StorageSystemNotFound ObjectNotFound 'Volume' -TargetType 'PSObject' -Message "The provided Storage System URI '$($_volume.volumeStorageSystemUri)' for the ephemeral volume '$($_volume.name)' was not found as an available storage system." 
                                $PSCmdlet.ThrowTerminatingError($errorRecord)

                            }
                                        
                        }

                        #Else, generate an error that at least one FC connection must exist in the profile in order to attach volumes.
                        else 
						{

                            $errorRecord = New-ErrorRecord HPOneView.ServerProfileResourceException NoProfileConnections ObjectNotFound 'ServerProfile' -TargetType 'PSObject' -Message "The profile does not contain any Network Connections.  The Profile must contain at least 1 FC Connection to attach Storage Volumes.  Use the New-HPOVServerProfileConnection helper cmdlet to create 1 or more connections and try again." 
                            $PSCmdlet.ThrowTerminatingError($errorRecord)

                        }

                    }
 
                }
                        
				$_volume = $_volume | Select-Object * -ExcludeProperty ApplianceConnection

				[void]$ServerProfile.sanStorage.volumeAttachments.Add($_volume)

                $i++

            }

			"[$($MyInvocation.InvocationName.ToString().ToUpper())] Updating Server Profile with new Storage Volume Attachments: {0}" -f $ServerProfile.name | Write-Verbose 

			Try
			{

				$_Task = Send-HPOVRequest $ServerProfile.uri PUT $ServerProfile -Hostname $ServerProfile.ApplianceConnection

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}
			
			Return $_Task

        }
		
		else
		{

			return $_volumeAttachments

		}

    }

}

#######################################################
# Index: 
#

function Search-HPOVIndex  
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding()]
    Param 
	(

		[parameter (Mandatory = $false)]
		[ValidateNotNullorEmpty()]
		[string]$search = $null,

		[parameter (Mandatory = $false)]
		[ValidateNotNullorEmpty()]
		[string]$category = $null,

		[parameter (Mandatory = $false)]
		[ValidateNotNullorEmpty()]
		[int]$count = 50,

		[parameter (Mandatory = $false)]
		[ValidateNotNullorEmpty()]
		[int]$start = 0,

		[parameter(Mandatory = $false)]
		[ValidateNotNullOrEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

	)
	
	Begin 
    {

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

        #Initialize collection to hold multiple volume attachments objects
        $_IndexSearchResults = New-Object System.Collections.ArrayList

    }

    Process 
	{

        ForEach ($_connection in $ApplianceConnection)
		{

			"[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Appliance Connection '{0}' (of {1})" -f $_connection.Name, $ApplianceConnection.count | Write-Verbose

			$uri = $indexuri + '?start=' + $start.ToString() + '&count=' + $count.ToString()
        
			if ($search) 
			{ 
				
				$uri = $uri + "&userQuery=" + $search 
			
			}
			
			if ($category) 
			{ 
				
				$uri = $uri + "&category=" + $category 
			
			}
			
			$uri = $uri.Replace(" ", "%20")

			Try
			{

				$r = Send-HPOVRequest $uri -Hostname $_connection

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}		
			
			if ($r.count -eq 0 -and $PSBoundParameters['Search']) 
			{

			    $errorRecord = New-ErrorRecord InvalidOperationException NoIndexResults ObjectNotFound 'Search' -Message ("No Index results found for '{0}' on '{1}." -f $Search, $_connection.Name)
			    $pscmdlet.WriteError($errorRecord)
			}

			else 
			{
			    
			    $r.members | % {

					$_.PSObject.TypeNames.Insert(0,'HPOneView.Appliance.IndexResource')

					[void]$_IndexSearchResults.Add($_)

				}

			}

		}

    }

	End
	{

		"Done. {0} index resource(s) found." -f $_IndexSearchResults.count | write-verbose

		Return $_IndexSearchResults

	}

}

function Search-HPOVAssociations 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding()]
    Param 
	(

		[parameter (Mandatory = $false, Position = 0)]
		[ValidateNotNullorEmpty()]
		[string]$AssociationName,

		[parameter (Mandatory = $false, ValueFromPipeline, Position = 1)]
		[ValidateNotNullorEmpty()]
		[object]$Parent,

		[parameter (Mandatory = $false, Position = 2)]
		[ValidateNotNullorEmpty()]
		[object]$Child,

		[parameter (Mandatory = $false, Position = 3)]
		[ValidateNotNullorEmpty()]
		[int]$Count = 50,

		[parameter (Mandatory = $false, Position = 4)]
		[ValidateNotNullorEmpty()]
		[int]$Start = 0,

		[parameter(Mandatory, ValueFromPipelineByPropertyName)]
		[ValidateNotNullOrEmpty()]
		[Alias('Appliance')]
		[Object]$ApplianceConnection

    )    

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if ($PSBoundParameters['Parent'])
		{

			if (-not($Parent -is [PSCustomObject]))
			{

				$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'Parent' -Message "The provided -Parent parameter value is not an Object.  Please correct the value."
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			$ApplianceConnection = $Parent.ApplianceConnection

		}

		elseif ($PSBoundParameters['Child'])
		{

			if (-not($Child -is [PSCustomObject]))
			{

				$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'Chuld' -Message "The provided -Child parameter value is not an Object.  Please correct the value."
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			$ApplianceConnection = $Child.ApplianceConnection

		}

		if ($PSBoundParameters['ApplianceConnection'])
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
			Try 
			{
			
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}

        #Initialize collection to hold multiple volume attachments objects
        $_IndexSearchResults = New-Object System.Collections.ArrayList

    }

    Process 
	{

        $uri = $associationsUri + '?start=' + $start.ToString() + '&count=' + $count.ToString()

        if ($PSBoundParameters['AssociationName']) 
		{ 

			$uri = $uri + "&name=" + $associationName 
		
		}
        
        if ($Parent) 
		{

			"[$($MyInvocation.InvocationName.ToString().ToUpper())] Parent resource: {0}" -f ($Parent | Out-String) | Write-Verbose 

			if (-not($Parent -is [PSCustomObject]))
			{

				$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'Parent' -Message "The provided -Parent parameter value is not an Object.  Please correct the value."
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}
					
			$uri = $uri + "&parentUri=" + $Parent.uri
		
		}
        
        if ($PSBoundParameters['Child']) 
		{

			"[$($MyInvocation.InvocationName.ToString().ToUpper())] Child resource: {0}" -f ($Child | Out-String) | Write-Verbose 

			if (-not($Child -is [PSCustomObject]))
			{

				$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'Child' -Message "The provided -Child parameter value is not an Object.  Please correct the value."
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			$uri = $uri + "&childUri=" + $Child.uri
		
		}
        
        $uri = $uri.Replace(" ", "%20")

		Try
		{

			$r = Send-HPOVRequest $uri -Hostname $ApplianceConnection.Name

		}

		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

        $r.members | % {

			[void]$_IndexSearchResults.Add($_)

		}

    }
	
	end
	{

		Return $_IndexSearchResults

	}

}

#######################################################
# Tasks:
#

function Get-HPOVTask 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding(DefaultParameterSetName = "Default")]
	Param 
	(

		[parameter(Mandatory = $false, HelpMessage = "Enter the name of the Task", ParameterSetName = "Default")]
        [parameter(Mandatory = $false, HelpMessage = "Enter the name of the Task", ParameterSetName = "ResourceCategory")]
		[ValidateNotNullorEmpty()]
        [Alias("name")]
		[string]$TaskName = $Null,

        [parameter(Mandatory = $false, ValueFromPipeline = $true, HelpMessage = "Enter the resource you want to find tasks associated with.", ParameterSetName = "Default")]
        [ValidateNotNullorEmpty()]
		[Object]$Resource = $Null,

        [parameter(Mandatory = $false, HelpMessage = "Please specify the Resource Category the task (i.e. 'ethernet-networks', 'fc-networks', 'server-profiles', etc..)", ParameterSetName = "ResourceCategory")]
        [ValidateNotNullorEmpty()]
		[Alias("Category")]
        [String]$ResourceCategory = $Null,

        [parameter(Mandatory = $false, HelpMessage = "Please specify the State of the task (i.e. Completed.)", ParameterSetName = "Default")]
        [parameter(Mandatory = $false, HelpMessage = "Please specify the State of the task (i.e. Completed.)", ParameterSetName = "ResourceCategory")]
        [ValidateNotNullorEmpty()]
		[ValidateSet("Unknown","New","Running","Suspended","Terminated","Killed","Completed","Error","Warning")]
        [string]$State = $Null,

        [parameter(Mandatory = $false, HelpMessage = "Please specify the amount of task objects to return.", ParameterSetName = "Default")]
        [parameter(Mandatory = $false, HelpMessage = "Please specify the amount of task objects to return.", ParameterSetName = "ResourceCategory")]
        [ValidateScript({ if ([int]$_ -gt -1) {$true} else {Throw "The Count Parameter value '$_' is invalid."}})]
        [Int]$Count = 0,

        [parameter(Mandatory = $false, ValueFromPipelineByPropertyName)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

	)
	
	Begin 
    {

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0

        ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
            {
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
            {

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
            {

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_TaskCollection = New-Object System.Collections.ArrayList

    }
	
    Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{

			$uri = $allNonHiddenTaskUri

			if ($PSBoundParameters['TaskName']) 
			{ 
        
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Name parameter value: $($TaskName)"

				$Uri += "?filter=name='$TaskName'" 
        
			}

			if ($PSBoundParameters['State']) 
			{ 
        
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] State parameter value: $($State)"

				if ($Uri) 
				{ 
					
					$Uri += "&filter=taskState='$State'" 
				
				}

				else 
				{
					
					$Uri = "?filter=taskState='$State'" 
				
				}
			
			}

			if ($PSBoundParameters['Count']) 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Count parameter value: $($Count)"

				if ($Uri) 
				{ 
					
					$Uri += "&count=$Count&sort=created:descending" 
				
				}

				else 
				{ 
					
					$Uri = "?count=$Count&sort=created:descending"
					
				} 

			}


			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Parameter Set Name resolved to: $($PSCmdlet.ParameterSetName)"

			switch ($PSCmdlet.ParameterSetName) 
			{

			    "Default" 
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Resource value:  $Resource"
			        
					if ($PSBoundParameters['Resource']) 
					{

			            #If the Resource value is a Name
			            if (($Resource -is [string]) -and (-not($Resource.StartsWith("/rest/"))))
						{

			                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Resource parameter Name: $($Resource)"

			                if ($Uri) 
							{ 
								
								$Uri += "&filter=associatedResource.resourceName='$Resource'" 
							
							}

			                else 
							{ 
								
								$Uri = "?filter=associatedResource.resourceName='$Resource'" 
							
							}

			            }

			            #Checking if the input is System.String and IS a URI
			            elseif (($Resource -is [string]) -and ($Resource.StartsWith("/rest/"))) 
						{
			    
			                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Resource parameter URI: $($Resource)"

			                if ($Uri) 
							{ 
								
								$Uri += "&filter=associatedResource.resourceUri='$Resource'" 
							
							}
			                
							else 
							{ 
								
								$Uri = "?filter=associatedResource.resourceUri='$Resource'" 
							
							}
			
			            }

			            #Checking if the input is PSCustomObject, and the category type is not null, which would be passed via pipeline input
			            elseif (($Resource -is [PSCustomObject]) -and ($Resource.category)) 
						{

			                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Resource is an object: '$($Resource.name)' of type '$($Resource.Category)'"

			                Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Using URI value ($($Resource.Uri)) from input object."

			                if ($Uri) 
							{ 
								
								$Uri += "&filter=associatedResource.resourceUri='$($Resource.Uri)'" 
							
							}

			                else 
							{ 
								
								$Uri = "?filter=associatedResource.resourceUri='$($Resource.Uri)'" 
							
							}
			            
						}

						else 
						{
							 
			                $errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'Get-HPOVTask' -Message "The Resource input parameter was not recognized as a valid type or format."
			                $pscmdlet.ThrowTerminatingError($errorRecord)
							
						}
						
			        }

			    } #End Default
			    
			    "ResourceCategory" 
				{ 
			    
			        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Resource Category was specified:  $($ResourceCategory)"

			        if ($Uri) 
					{
						
						 $Uri += "&filter=associatedResource.resourceCategory='$($ResourceCategory)'" 
					}

			        else 
					{
						
						$Uri = "?filter=associatedResource.resourceCategory='$($ResourceCategory)'" 
					
					}

			    } #End ResourceCategory

			} #End switch

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] URI: $($Uri)"

			if ($Count -gt 0 ) 
			{ 
			
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting $($Count) task objects." 
		
			}

			else 
			{ 
			
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] ($($Count)) Returning all available task objects." 
		
			}


			try 
			{
        
				$_tasks = Send-HPOVRequest $Uri -Hostname $_Connection

				if ($_tasks.count -eq 0) 
				{ 
                
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No tasks found on Appliance '$($_Connection.Name)'."
                    
				}

				else 
				{ 
                
					$_tasks.members | % { 
							
						$_.PSObject.TypeNames.Insert(0,"HPOneView.Appliance.TaskResource") 
						
						[void]$_TaskCollection.Add($_)
						
					}
 
				}

			}

			catch 
			{

				$pscmdlet.ThrowTerminatingError($_)
			
			}

		}

    }    

    End
	{

		"[$($MyInvocation.InvocationName.ToString().ToUpper())] Done. {0} task resource(s) found." -f $_TaskCollection.count | write-verbose

		Return $_TaskCollection

    }

}

function Wait-HPOVTaskStart  
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding()]
	Param 
	(

		[parameter(Mandatory, ValueFromPipeline, HelpMessage = "Enter the task URI or task object")]
		[Alias('taskuri')]
        [object]$task,

        [parameter(Mandatory = $false,HelpMessage = "Provide the resource name the task is for, which is displayed in the Write-Progress output.")]
        [string]$resourceName,

        [parameter(Mandatory = $false,HelpMessage = "Enter the new value for the global parameter")]
        [timespan]$timeout = $script:defaultTimeout,

		[parameter(ValueFromPipelineByPropertyName, ValueFromPipeline = $False, Mandatory = $false, HelpMessage = "Enter the Appliance Name or Object")]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

	) 

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not $PSBoundParameters['task']) { $PipelineInput = $True }

		if ($Task -is [String] -and ($ApplianceConnection.Count -gt 1) -and (-not($PipelineInput)))
		{
		
			$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'Task' -Message "The -Task parameter requires an Appliance to be specified.  Please provide the Appliance Connection object or name by using the -ApplianceConnection parameter."
			$PSCmdLet.ThrowTerminatingError($errorRecord)

		}

		elseif (-not($PipelineInput))
		{


			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

			$c = 0

			Try 
			{
	
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}
		
		$TaskCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{

        if ($PipelineInput) 
		{ 
			
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Task resource passed via pipeline input." 
		
		}

        #Validate the task object
        if (($task -is [String]) -and ($task.StartsWith($script:taskUri))) 
		{
            
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Task is System.String $($task)"
        
		}

        elseif (($task -is [PSCustomObject] -or $task -is [HPOneView.Appliance.TaskResource]) -and ($task.category -ieq 'tasks')) 
		{
        
		    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Task is $($task.GetType()). Task URI: $($task.uri)"

            $ApplianceConnection = $task.ApplianceConnection

			$task = $task.uri
        
		}

        else 
		{

            $errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'Wait-HPOVTaskStart' -Message "Invalid task.  Please verify the task object you are passing and try again."
            $PSCmdLet.ThrowTerminatingError($errorRecord)

        }

        $sw = [diagnostics.stopwatch]::StartNew()

		Try
		{

			$taskObj = Send-HPOVRequest $task -HostName $ApplianceConnection.name

		}
        
		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}
        
		$i = 0

        if ($resourceName) 
		{ 
			
			$taskname = "Waiting for '$($taskObj.name) $resourceName' task to start"
		
		}

        else 
		{ 
			
			$taskName = "Waiting for '$($taskObj.name)' task to start" 
		
		}

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Waiting for $taskName to start..."

        while ($taskObj.taskState -and ($taskObj.taskState -ieq "Adding" -or $taskObj.taskState -ieq "New" -or $taskObj.taskState -ieq "Starting")) 
		{

			Try
			{

				$taskObj = Send-HPOVRequest $task -Hostname $taskObj.ApplianceConnection.Name

			}

			Catch
			{
			
				$PSCmdlet.ThrowTerminatingError($_)
			
			}
            
            if ($sw.Elapsed -gt $timeout) 
			{
                
                $errorRecord = New-ErrorRecord InvalidOperationException TaskWaitExceededTimeout OperationTimeout  'Wait-HPOVTaskStart' -Message "The time-out period expired before waiting for task '$taskName' to start." #-verbos
                $PsCmdlet.ThrowTerminatingError($errorRecord)

            }

            #Display Progress Bar

			#Display the task status
			if ($taskObject.taskStatus)
			{

				$progressStatus = $taskObject.taskStatus

			}
						
			elseif ($taskObject.taskState)
			{

				$progressStatus = $taskObject.taskState

			}

			else
			{

				$progressStatus = "Waiting $($taskObject.Name)"

			}

			if ($taskObj.expectedDuration) 
			{

				$percentComplete = ($i / $taskObj.expectedDuration * 100)

			}

			else
			{

				$percentComplete = $taskObj.percentComplete 

			}
            
            #Handle the call from -Verbose so Write-Progress does not get borked on display.
            if ($PSBoundParameters['Verbose'] -or $VerbosePreference -eq 'Continue') 
			{ 
				
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Skipping Write-Progress display."
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Task Status: '$taskName' {$progressStatus} $($percentComplete)% Complete"

			}
             
			else 
			{

				Write-Progress -activity $taskName -status $progressStatus -percentComplete $percentComplete
                
            }

            Start-Sleep 1

            $i++

        }

		Write-Progress -activity $taskName -Completed

		[void]$TaskCollection.Add($taskObj)

    }

    End 
	{
    
		Return $TaskCollection

    }

}

function Wait-HPOVTaskComplete 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding()]
	Param
	(

		[parameter(Position = 0, ValueFromPipeline, Mandatory, HelpMessage = "Enter the task URI or task object")]
		[Alias('TaskUri')]
        [Object]$Task,

        [parameter(Position = 1, Mandatory = $false, HelpMessage = "Enter the new value for the global parameter")]
        [timespan]$timeout = $script:defaultTimeout,

		[parameter(ValueFromPipelineByPropertyName, Mandatory = $false, HelpMessage = "Enter the Appliance Name or Object")]
		[Alias('Appliance')]
		[Object]$ApplianceConnection = $null

	)

    Begin 
    {
        
        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSBoundParameters['Task'])) 
		{ 
			
			$PipelineInput = $True 
		
		}
		
		#Task isn't provided by pipeline, but check for ApplianceConnection property
		else
		{

			if ((-not($task.ApplianceConnection)) -and ($task.ApplianceConnection -is [PSCustomObject]))
			{

				$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'Task' -TargetType 'PSObject' -Message "The -Task parameter object does not contain the required property 'ApplianceConnection'.  Please provide the Appliance Connection object or name by using the -ApplianceConnection parameter, or validate the input object contains a valid 'ApplianceConnection' property value."
				$PSCmdLet.ThrowTerminatingError($errorRecord)

			}

			elseif ($task -is [PSCustomObject])
			{

				$ApplianceConnection = $task.ApplianceConnection

			}

			elseif ($Task -is [String] -and (-not($ApplianceConnection)))
			{
		
				$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument 'Task' -Message "The -Task parameter requires an Appliance to be specified.  Please provide the Appliance Connection object or name by using the -ApplianceConnection parameter."
				$PSCmdLet.ThrowTerminatingError($errorRecord)

			}

		}

		if (-not($PipelineInput))
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

			Try 
			{
	
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}

		$TaskCollection          = New-Object System.Collections.ArrayList
		$FinishedTasksCollection = New-Object System.Collections.ArrayList

		$i = 1

    }

    Process 
	{

        if ($PipelineInput) 
		{ 
			
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Task resource passed via pipeline input." 
		
		}

		#Validate the task object 
		ForEach ($_task in $Task)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing task resources." 

			if (($_task -is [String]) -and ($_task.StartsWith($script:taskUri))) 
			{

			    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Task is System.String $($_task)"

				#Use to track -ID in Write-Progress
				[void]$TaskCollection.Add(([PSCustomObject]@{id = $i; uri = $_task; taskState = $Null; ApplianceConnection = $ApplianceConnection }))

			}

			elseif ($_task -is [PSCustomObject] -and $_task.category -ieq 'tasks')
			{

			    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Task is $($_task.GetType()). Task URI: $($_task.uri)"
				
				#Use to track -ID in Write-Progress
				$_task | Add-Member -NotePropertyName id -NotePropertyValue $i -force

				[void]$TaskCollection.Add($_task)

			}

			else 
			{

			    $errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument $_task -Message "Invalid task object provided.  Please verify the task object you are passing and try again."
			    $PSCmdLet.ThrowTerminatingError($errorRecord)

			}

			$i++
			
		}

	}

	End
	{

		$_taskCollection = $TaskCollection.Clone()

		#Start Stopwatch
		$sw = [diagnostics.stopwatch]::StartNew()

		while ($_taskCollection.Count -gt 0 -and $sw.Elapsed -lt $timeout)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing taskcollection."

			if ($sw.Elapsed -gt $timeout) 
			{
                #Tear down Write-Progress
				1..$_taskCollection.count | % { Write-Progress -id $_ -Completed }

				#Return 'finished' collection to caller then display error
				$FinishedTasksCollection

				#UPDATE ERROR MESSAGE to state timeout waiting for tasks to complete
                $errorRecord = New-ErrorRecord HPOneView.Appliance.TaskResourceException TaskWaitExceededTimeout OperationTimeout  'Wait-HPOVTaskComplete' -Message "The time-out period expired before waiting for task '$taskName' to start." #-verbos
                $PsCmdlet.ThrowTerminatingError($errorRecord)

            }

			ForEach ($_task in $_taskCollection)
			{

				#Get task object from API
				Try
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting task object from API."  

					$_taskObj = Send-HPOVRequest $_task.uri -Hostname $_task.ApplianceConnection.Name

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}
			
				#Task is in a finished state
				if ($script:taskFinishedStates -contains $_taskObj.taskState)
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Task is finished, removing from collection."
					  
					"[$($MyInvocation.InvocationName.ToString().ToUpper())] Task Collection size: {0}" -f $TaskCollection.count | Write-Verbose

					#Remove task object from base arraylist
					#$ndx = [array]::IndexOf($_taskCollection, $_task)

					[void]$TaskCollection.Remove($_task)

					"[$($MyInvocation.InvocationName.ToString().ToUpper())] Updated Task Collection size: {0}" -f $TaskCollection.count | Write-Verbose

					#Add Task Object from API to return back to caller
					[void]$FinishedTasksCollection.Add($_taskObj)

					if ($PSBoundParameters['Verbose'] -or $VerbosePreference -eq 'Continue') 
					{
						
						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $($_taskObj.name) [$($_taskObj.ApplianceConnection.Name)$($_taskObj.uri)] Task finished. "  
					
					}

					else 
					{
					
						Write-Progress -id $_task.id -activity "$($_taskObj.name) ($($_taskObj.associatedResource.resourceName))" -Completed
					
					}

					#Break out of ForEach loop to re-enumerate taskcollection
					break

				}

				#Display Progress Bar
            
				#Handle the call from -Verbose so Write-Progress does not get borked on display.
				if ($PSBoundParameters['Verbose'] -or $VerbosePreference -eq 'Continue') 
				{ 
					
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Skipping Write-Progress display."  
					
					"[$($MyInvocation.InvocationName.ToString().ToUpper())] CMDLET Task Track ID: {0}`nTask Object Name: {1}`nAssociated Resource Name: {2}`nPrecent Complete: {3}" -f $_task.id, $_taskObj.name,$_taskObj.associatedResource.resourceName,$_taskObj.percentComplete | Write-Verbose
				
					If ($_taskObj.progressUpdates[-1].statusUpdate)
					{

						"[$($MyInvocation.InvocationName.ToString().ToUpper())] Child tasks - Child task: {0} ParentId: {1} {2} [{3}]" -f ($_task.id + 100), $_task.id, $_taskObj.progressUpdates[-1].statusUpdate, $_taskObj.taskStatus | Write-Verbose

					}

				}
				 
				else 
				{

					# // Need to re-write this logic.  Need to figure out progressUpdates versus taskStatus versus taskState, and display -status correctly
					# // Done?

				    #Display the task status, and associated child tasks
				    if ($_taskObj.progressUpdates) 
					{ 

				        #Child task is executing, display reported status
				        If ($_taskObj.progressUpdates[-1].statusUpdate) 
						{

				            Write-Progress -id ($_task.id + 100) -ParentId $_task.id -activity "$($_taskObj.name) ($($_taskObj.associatedResource.resourceName))" -status $_taskObj.progressUpdates[-1].statusUpdate -percentComplete $_taskObj.computedPercentComplete
				        
						}

				        #There is a child task, but it's statusUpdate value is NULL, so just display the parent task status
				        else 
						{
				         
				            if ($_taskObj.taskStatus)
							{

								$progressStatus = $_taskObj.taskStatus

							}
							
							else
							{

								$progressStatus = $_taskObj.taskState

							}

							Write-Progress -activity "$($_taskObj.name) ($($_taskObj.associatedResource.resourceName))" -status $progressStatus -percentComplete $_taskObj.percentComplete
				        
						}

				    }

				    #Just display the task status, as it has no child tasks
				    elseif ($_taskObj.taskStatus) 
					{
						
						Write-Progress -activity $_taskObj.name -status $_taskObj.taskStatus -percentComplete $_taskObj.percentComplete 
					
					}
				    
					else 
					{
						
						Write-Progress -activity $_taskObj.name -status $_taskObj.taskState -percentComplete $_taskObj.percentComplete 
					
					}

				}

				#Start-Sleep -Seconds 2

			}

			#Reclone $_taskCollection object to update array with current task ArrayList
			$_taskCollection = $TaskCollection.Clone()

		}

		Return $FinishedTasksCollection

    }

}

#######################################################
# Securty and LDAP Functions
#

function Get-HPOVUser 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdLetBinding()]
    Param 
	(

        [Parameter(Mandatory = $false)]
		[ValidateNotNullorEmpty()]
        [string]$Name = $null,
		
		[parameter(Mandatory = $false)]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

    )
	
    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if  (($ApplianceConnection | Measure-Object).Count -eq 0)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError 'ApplianceConnection' -Message 'This CMDLET requires athentication.  Please log into a valid appliance using Connect-HPOVMgmt, and then try the call again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		else
		{

			$c = 0
		
			ForEach ($_Connection in $ApplianceConnection) 
			{
		
				Try 
				{
			
					$ApplianceConnection[$c] = Test-HPOVAuth $_Connection
		
				}
		
				Catch [HPOneview.Appliance.AuthSessionException] 
				{
		
					$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
					$PSCmdlet.ThrowTerminatingError($errorRecord)
		
				}
		
				Catch 
				{
		
					$PSCmdlet.ThrowTerminatingError($_)
		
				}
		
				$c++
		
			}

		}
		
		$_UserCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_Connection.Name)' Appliance (of $($ApplianceConnection.Count))"

			Try
			{

				$_users = Send-HPOVRequest ($usersUri+"?sort=username:asc") -Hostname $_Connection.Name 

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Found $($_users.count) user resources on '$($_Connection.Name)' appliance."

			ForEach ($u in $_users.members) 
			{

				$u.PSObject.TypeNames.Insert(0,'HPOneView.Appliance.User')

				[void]$_UserCollection.Add($u)

            }

        }

	}

	End 
	{

        if ($Name) 
		{

            $_UserCollection = $_UserCollection | ? userName -like $Name

        }

        if ($_UserCollection.count -eq 0 -and $Name) 
		{
				
            $errorRecord = New-ErrorRecord HPOneView.Appliance.UserResourceException UserNotFound ObjectNotFound "Name" -Message "Username `'$Name`' was not found. Please check the spelling, or create the user and try again."
			$pscmdlet.ThrowTerminatingError($errorRecord)

		}

		"Done. {0} user(s) found." -f $_UserCollection.count | write-verbose 
		
	    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] returning account resource objects."  
		
		Return $_UserCollection    

    }

}

function New-HPOVUser 
{
	 
    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding()]
	Param 
	(

        [parameter(Mandatory = $true)]
        [string]$UserName, 

        [parameter(Mandatory = $true)]
        [string]$Password, 

        [parameter(Mandatory = $false)]
        [string]$FullName, 

        [parameter(Mandatory = $true)]
        [Array]$Roles = @(),

        [parameter(Mandatory = $false)]
        [validatescript({$_ -as [Net.Mail.MailAddress]})]
        [string]$EmailAddress = $null,

        [parameter(Mandatory = $false)] 
        [string]$officePhone = $null,
     
        [parameter(Mandatory = $false)]
        [string]$mobilePhone = $null,
     
        [parameter(Mandatory = $false)]
        [switch]$enabled,

		[parameter(Mandatory = $false, HelpMessage = "Enter the Appliance Name or Object")]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

	)

    Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}
		
		$_UserStatus = New-Object System.Collections.ArrayList

    }

    Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_Connection.Name)' Appliance (of $($ApplianceConnection.Count))"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Validating requested role values"
			
			$_unsupportedRoles = New-Object System.Collections.ArrayList
			$_NewUserRoles     = New-Object System.Collections.ArrayList

			#Validate roles provided are allowed.
			foreach ($_role in $Roles) 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing role: $_role"

				if (-not ((${Global:ConnectedSessions} | ? Name -EQ $_Connection.Name).ApplianceSecurityRoles -contains $_role)) 
				{ 
				
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Invalid or unsupported"

					[void]$_unsupportedRoles.Add($_role)
			
				}

				else
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Supported"

					[void]$_NewUserRoles.Add($_role)

				}

			}

			if ($_unsupportedRoles.count -ge 1) 
			{ 
        
				$errorRecord = New-ErrorRecord ArgumentException UnsupportedRolesFound InvalidArgument $($MyInvocation.InvocationName.ToString().ToUpper()) -Message "The '$($_unsupportedRoles -join ", ")' role(s) is/are not supported or the correct names.  Please validate the -roles parameter contains one or more valid roles.  Allowed roles are: $((${Global:ConnectedSessions} | ? Name -EQ $_Connection.Name).ApplianceSecurityRoles -join ", ")"
				$PSCmdlet.ThrowTerminatingError($errorRecord)            
            
			}

			$_user = NewObject -UserAccount

			$_user.userName     = $userName
			$_user.fullName     = $fullName
			$_user.password     = $password
			$_user.emailAddress = $emailAddress
			$_user.officePhone  = $officePhone 
			$_user.mobilePhone  = $mobilePhone
			$_user.enabled      = $enabled.IsPresent
			$_user.roles        = $_NewUserRoles

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User requested to create:  $($_user | out-string )"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request to create $($_user.userName) user"
			
			Try
			{

				$_resp = Send-HPOVRequest $usersUri POST $_user -Hostname $_Connection.Name

			}
			
			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$_resp.PSObject.TypeNames.Insert(0,'HPOneView.Appliance.User')

			[void]$_UserStatus.Add($_resp)

		}

    }

	End
	{
		
		Return $_UserStatus

    }

}

function Set-HPOVUser 
{
	 
    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding(DefaultParameterSetName = 'default')]
	Param 
	(

		[parameter(Position = 0, Mandatory, ValueFromPipeline, ParameterSetName = 'Pipeline')]
		[ValidateNotNullorEmpty()]
		[Object]$UserObject,

        [parameter(Position = 0, Mandatory = $true, ParameterSetName = 'default')]
		[ValidateNotNullorEmpty()]
        [string]$UserName, 

        [parameter(Position = 1, Mandatory = $false, ParameterSetName = 'default')]
		[parameter(Position = 1, Mandatory = $false, ParameterSetName = 'Pipeline')]
        [ValidateNotNullorEmpty()]
		[string]$Password, 

		[parameter(Position = 2, Mandatory = $false, ParameterSetName = 'default')]
        [parameter(Position = 2, Mandatory = $false, ParameterSetName = 'Pipeline')]
        [ValidateNotNullorEmpty()]
		[string]$FullName, 

		[parameter(Position = 3, Mandatory = $false, ParameterSetName = 'default')]
        [parameter(Position = 3, Mandatory = $false, ParameterSetName = 'Pipeline')]
        [ValidateNotNullorEmpty()]
		[Array]$Roles,

		[parameter(Position = 4, Mandatory = $false, ParameterSetName = 'default')]
        [parameter(Position = 4, Mandatory = $false, ParameterSetName = 'Pipeline')]
        [validatescript({$_ -as [Net.Mail.MailAddress]})]
        [string]$EmailAddress,

		[parameter(Position = 5, Mandatory = $false, ParameterSetName = 'default')]
        [parameter(Position = 5, Mandatory = $false, ParameterSetName = 'Pipeline')] 
        [ValidateNotNullorEmpty()]
		[string]$OfficePhone,
     
		[parameter(Position = 6, Mandatory = $false, ParameterSetName = 'default')]
        [parameter(Position = 6, Mandatory = $false, ParameterSetName = 'Pipeline')]
        [ValidateNotNullorEmpty()]
		[string]$MobilePhone,
     
		[parameter(Position = 7, Mandatory = $false, ParameterSetName = 'default')]
        [parameter(Position = 7, Mandatory = $false, ParameterSetName = 'Pipeline')]
        [alias('enable')]
		[ValidateNotNullorEmpty()]
        [switch]$Enabled,

		[parameter(Position = 8, Mandatory = $false, ParameterSetName = 'default')]
        [parameter(Position = 8, Mandatory = $false, ParameterSetName = 'Pipeline')]
        [alias('disable')]
		[ValidateNotNullorEmpty()]
        [switch]$Disabled,

		[parameter(Mandatory = $false, ValueFromPipelineByPropertyName, HelpMessage = "Enter the Appliance Name or Object")]
		[Alias('Appliance')]
		[ValidateNotNullorEmpty()]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

	)

    Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		#No need to validate ApplianceConnection, as object is passed via pipeline.
		if ($PSCmdlet.ParameterSetName -eq 'Pipeline')
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Pipeline input."
			
			$PipelineInput = $True

		}

		else
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

			$c = 0

			ForEach ($_Connection in $ApplianceConnection) 
			{

				Try 
				{
	
					$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

				}

				Catch [HPOneview.Appliance.AuthSessionException] 
				{

					$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				Catch 
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

				$c++

			}
						
		}

		$_UsersToUpdate = New-Object System.Collections.ArrayList
		$_UserStatus    = New-Object System.Collections.ArrayList

    }

    Process 
	{

		if ($PipelineInput)
		{

			#Validate pipeline input is user object
			if (-not($UserObject -is [PSCustomObject]) -and -not($UserObject.category -eq 'users'))
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Invalid UserObject provided: $($UserObject | FL * | Out-String)"

				$errorRecord = New-ErrorRecord HPOneView.Appliance.UserResourceException InvalidUserObject InvalidArgument "UserObject" -TargetType 'PSObject' -Message "The UserObject parameter value is not a valid User object resource.  Object category provided '$($UserObject.category)', allowed object category value 'users'.  Please verify the input object and try again."
				$pscmdlet.ThrowTerminatingError($errorRecord)

			}

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding UserObject to process collection: $($UserObject | FL * | Out-String)"

			[void]$_UsersToUpdate.Add($UserObject)

		}

		else
		{

			ForEach ($_Connection in $ApplianceConnection)
			{

				try 
				{ 
					
					$_UserObject = Get-HPOVUser $userName -ApplianceConnection $_Connection
				
				}
        
				#If not found, throw error
				catch [HPOneView.Appliance.UserResourceException]
				{
				
				    #Generate terminating error
				    $errorRecord = New-ErrorRecord HPOneView.Appliance.UserResourceException UserNotFound ObjectNotFound 'UserName' -Message "Username `'$userName`' was not found. Please check the spelling, or create the user and try again."
				    $pscmdlet.ThrowTerminatingError($errorRecord)
				
				}

				Catch
				{

					$pscmdlet.ThrowTerminatingError($_)

				}

				[void]$_UsersToUpdate.Add($_UserObject)

			}

		}

	}

	End
	{

		ForEach ($_User in $_UsersToUpdate)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing User: $($_User.userName)"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Original User object: $($_User | FL * | Out-String)"

			$_User | Add-Member -NotePropertyName type -NotePropertyValue 'UserAndRoles'

			switch ($PSBoundParameters.keys) 
			{

				"Password" 
				{ 

					if ($_User.userName -eq (${Global:ConnectedSessions} | ? Name -eq $_User.ApplianceConnection.Name).UserName) 
					{

					    write-warning "This CMDLET will not modify the password for your account.  Please use the Set-HPOVUserPassword CMDLET to update your user account password.  Password update will not be processed."

					}  
						          
					else 
					{ 
						
						$_User | Add-Member -NotePropertyName password -NotePropertyValue $Password -force
						
					} 
                
				}

				"fullName" 
				{ 
					
					$_User.fullName = $FullName
				
				}

				"roles" 
				{

					if ($_User.userName -eq (${Global:ConnectedSessions} | ? Name -eq $_User.ApplianceConnection.Name).UserName) 
					{

					    write-warning "Unable to modify roles for your account, as you must be authenticated to the appliance with a different administrator account.  Roles will not be processed."

					}

					else 
					{
					
					    $_User | add-member -NotePropertyName replaceRoles -NotePropertyValue $True -force

					    #Validate roles provided are allowed.
					    $_unsupportedRoles = New-OBject System.Collections.ArrayList

					    #Validate roles provided are allowed.
						foreach ($_role in $Roles) 
						{

							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing role: $_role"

							if (-not ((${Global:ConnectedSessions} | ? Name -EQ $_Connection.Name).ApplianceSecurityRoles -contains $_role)) 
							{ 
							
								Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Invalid or unsupported"

								[void]$_unsupportedRoles.Add($_role)
						
							}

							else
							{

								Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Supported"

								[void]$_NewUserRoles.Add($_role)

							}

						}

						if ($_unsupportedRoles.count -ge 1) 
						{ 
        
							$errorRecord = New-ErrorRecord ArgumentException UnsupportedRolesFound InvalidArgument $($MyInvocation.InvocationName.ToString().ToUpper()) -Message "The '$($_unsupportedRoles -join ", ")' role(s) is/are not supported or the correct names.  Please validate the -roles parameter contains one or more valid roles.  Allowed roles are: $((${Global:ConnectedSessions} | ? Name -EQ $_Connection.Name).ApplianceSecurityRoles -join ", ")"
							$PSCmdlet.ThrowTerminatingError($errorRecord)            
						
						}

					    #Need to make sure role name is first letter capitalized only.
					    $i = 0

					    foreach ($_role in $_NewUserRoles) 
						{

					        $_NewUserRoles[$i] = $_role.substring(0,1).ToUpper()+$_role.substring(1).tolower()

					        $i++

					    }

						$_User.roles = $_NewUserRoles

					}

				}

				"emailAddress" 
				{ 
					
					$_User.emailAddress = $EmailAddress
				
				}

				"officePhone" 
				{ 
					
					$_User.officePhone = $OfficePhone
				
				}

				"mobilePhone" 
				{ 
					
					$_User.mobilePhone = $MobilePhone
				
				}

				"enabled" 
				{ 
                
				    if ($_User.userName -eq (${Global:ConnectedSessions} | ? Name -eq $_User.ApplianceConnection.Name).UserName) 
					{

				        write-warning "This CMDLET will not modify the state for your account.  Please authenticate to the appliance with a different administrator account.  Account state will not be processed."

				    }

				    else 
					{ 
						
						$_User.enabled = $true
					
					}

				}

				"disabled" 
				{ 

				    if ($_User.userName -eq (${Global:ConnectedSessions} | ? Name -eq $_User.ApplianceConnection.Name).UserName) 
					{

				        write-warning "This CMDLET will not modify the state for your account.  Please authenticate to the appliance with a different administrator account.  Account state will not be processed."

				    }

				    else 
					{ 
						
						$_User.enabled = $false

					}

				}

			}

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Updated User object: $($_User | FL * | Out-String)"

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request to update `'$($_User.userName)`' user at '$usersUri'"

			Try
			{

				$_resp = Send-HPOVRequest $usersUri PUT $updateUser -Hostname $_User.ApplianceConnection.Name

			}
            
			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$_resp.PSObject.TypeNames.Insert(0,'HPOneView.Appliance.User')

			[void]$_UserStatus.Add($_resp)

		}
        
		Return $_UserStatus

	}

}

function Set-HPOVUserPassword 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding()]
	Param 
	(

        [parameter(Position = 0, Mandatory = $false, ValueFromPipeline = $false)]
		[ValidateNotNullorEmpty()]
		[Alias('CurrentPassword')]
        [String]$Current,

        [parameter(Position = 1, Mandatory = $false, ValueFromPipeline = $False)]
        [ValidateNotNullorEmpty()]
		[Alias('NewPassword')]
		[String]$New,

		[parameter(Mandatory = $false, HelpMessage = "Enter the Appliance Name or Object")]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

	)

    Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"


		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		

		#Prompt user for current password if not provided
        if (-not ($Current)) 
		{ 
        
            $Current                  = Read-Host -AsSecureString "Current"
            $_decryptCurrentPassword = [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($currentPassword))

        }

        else 
		{ 
			
			$_decryptCurrentPassword = $Current 
		
		}

        #Prompt user for new password if not provided
        if (-not($New)) 
		{ 
        
            Do 
			{

                $New                 = Read-Host -AsSecureString "New"
                $_CompareNewPassword = Read-Host -AsSecureString "Re-type New"
                
                #Compare provided password matches
                $_decryptNewPassword        = [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($New))
                $_decryptcompareNewPassword = [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($_CompareNewPassword))

                if (-not ($_decryptNewPassword -eq $_decryptcompareNewPassword))
				{

                    $errorRecord = New-ErrorRecord HPOneview.Appliance.PasswordMismatchException NewPasswordsDoNotMatch InvalidResult 'New' -Message "The new password values do not match. Please check the value and try again."
                    $PSCmdlet.WriteError($errorRecord)

                }

                if (-not ($_decryptNewPassword.length -ge 8) -or -not ($_decryptcompareNewPassword -ge 8)) 
				{
                
                    $errorRecord = New-ErrorRecord HPOneview.Appliance.PasswordMismatchException NewPasswordLengthTooShort InvalidResult 'New' -Message "The new password value do not meet the minimum character length of 8 characters. Please try again."
                    $PSCmdlet.WriteError($errorRecord)

                }

            } Until ($_decryptNewPassword -eq $_decryptcompareNewPassword -and $_decryptNewPassword.length -ge 8)

        }

        else 
		{

            $_decryptNewPassword = $New

        }


		$_UserStatus = New-Object System.Collections.ArrayList

    }

    Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_Connection.Name)' Appliance (of $($ApplianceConnection.Count))"

			#Get current user object
			Try
			{

				$_CurrentUserObj = Get-HPOVUser $_Connection.UserName -ApplianceConnection $_Connection

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}
			
			$_CurrentUserObj | add-member -notepropertyname currentPassword -NotePropertyValue $decryptCurrentPassword
			$_CurrentUserObj | add-member -notepropertyname password -NotePropertyValue $decryptNewPassword
			$_CurrentUserObj | add-member -notepropertyname replaceRoles -NotePropertyValue $false
			$_CurrentUserObj | add-member -notepropertyname type -NotePropertyValue UserAndRoles

			Try
			{

				$_resp = Send-HPOVRequest $usersUri PUT $_CurrentUserObj -Hostname $_Connection

			}
			
			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			if ($_resp.category -eq 'users')
			{

				$_resp.PSObject.TypeNames.Insert(0,'HPOneView.Appliance.User')

			}

			[void]$_UserStatus.Add($_resp)

		}     

    }

    End 
	{

        Return $_UserStatus

    }

}

function Remove-HPOVUser 
{
	 
    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding(DefaultParameterSetName = "default", SupportsShouldProcess = $True, ConfirmImpact = 'High')]
	param
	(

		[parameter(Mandatory, ValueFromPipeline, HelpMessage = "Enter the User Account Name to delete from the appliance", Position = 0, ParameterSetName = "default")]
		[ValidateNotNullOrEmpty()]
		[alias("u","user",'UserName')]
		[Object]$Name,
	
		[parameter(Mandatory = $False, ValueFromPipelineByPropertyName, ParameterSetName = "ApplianceRequired", position = 1)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = $Null

    )

    Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] {

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		if (-not($PSBoundParameters['Name'])) { $PipelineInput = $True }

		$_TaskCollection = New-Object System.Collections.ArrayList
		$_UserCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{

		if ($PipelineInput) 
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Pipeline input"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User Object provided: $($Name | FL * | Out-String)"

			If ('users' -contains $Name.category)
			{

				If (-not($Name.ApplianceConnection))
				{

					$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument "User:$($Name.Name)" -TargetType PSObject -Message "The User object resource provided is missing the source ApplianceConnection property.  Please check the object provided and try again."
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				[void]$_UserCollection.Add($Name)

			}

			else
			{

				$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument "User:$($Name.Name)" -TargetType PSObject -Message "The User object resource is not an expected category type [$($Name.category)].  The allowed resource category type is 'users'.  Please check the object provided and try again."
                $PSCmdlet.ThrowTerminatingError($errorRecord)

			}

		}

		else 
		{

			ForEach ($_Connection in $ApplianceConnection)
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Appliance $($_Connection.Name) (of $($ApplianceConnection.Count))"

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing User Name $($Name)"

				Try
				{

					$_User = Get-HPOVUser $Name -ApplianceConnection $_Connection

					$_User | % {

						[void]$_UserCollection.Add($_)

					}

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}				

			}

		}

	}

	End
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing $($_UserCollection.count) User object resources to remove."

		#Process User Resources
		ForEach ($_user in $_UserCollection)
		{

			if ($pscmdlet.ShouldProcess($_user.ApplianceConnection.Name,"Remove User '$($_user.userName)' from appliance")) 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Removing User '$($_user.userName)' from appliance '$($_user.ApplianceConnection.Name)'."

				Try
				{

					$_resp = Send-HPOVRequest $_user.Uri DELETE -Hostname $_user.ApplianceConnection.Name

					$_resp | Add-Member -NotePropertyName userName -NotePropertyValue $_user.userName

					[void]$_TaskCollection.Add($_resp)

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

			}

			elseif ($PSBoundParameters['WhatIf'])
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] WhatIf parameter was passed."

			}

		}

		Return $_TaskCollection

    }

}

function Show-HPOVUserSession 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "default")]
    Param ()

    Begin 
	{
    
        Write-Warning "This CMDLET has been deprecated. Please use the $ConnectedSessions Global variable for appliance session information."
    
    }

    Process { }

    End { }

}

function Get-HPOVRole 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "default")]
    Param()
	
    Begin 
	{

        Write-Warning "This CMDLET is now deprecated. Please use the Get-HPOVUser CMDLET to retrieve the user account and associated Roles."

    }

}

function Set-HPOVUserRole 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding()]
    Param 
	(

        [parameter (Mandatory, ValueFromPipeline)]
        [ValidateNotNullOrEmpty()]
        [Alias("user",'userName')]
        [Object]$Name = $null,

        [parameter (Mandatory)]
        [ValidateNotNullOrEmpty()]
        [alias('roleName')]
        [Array]$Roles,

		[parameter(ValueFromPipelineByPropertyName, ValueFromPipeline = $False, Mandatory = $false, HelpMessage = "Enter the Appliance Name or Object")]
		[Alias('Appliance')]
		[Object]$ApplianceConnection = ${Global:ConnectedSessions}

	)

    Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		

		if (-not($PSBoundParameters['Name']))
		{ 
		
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Validating requested role values"
				
			$PipelineInput = $True 
		
		}

		else
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

			$c = 0

			ForEach ($_Connection in $ApplianceConnection) 
			{

				Try 
				{
	
					$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

				}

				Catch [HPOneview.Appliance.AuthSessionException] 
				{

					$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				Catch 
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

				$c++

			}

		}

		#elseif (-not($PipelineInput))
		#{
		#
		#	Try 
		#	{
		#
		#		$ApplianceConnection = Test-HPOVAuth $ApplianceConnection
		#
		#	}
		#
		#	Catch [HPOneview.Appliance.AuthSessionException] 
		#	{
		#
		#		$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
		#		$PSCmdlet.ThrowTerminatingError($errorRecord)
		#
		#	}
		#
		#	Catch 
		#	{
		#
		#		$PSCmdlet.ThrowTerminatingError($_)
		#
		#	}
		#
		#}

        #Need to make sure role name is first letter capitalized only.
        $i = 0

        foreach ($role in $roles) 
		{

            $roles[$i] = $role.substring(0,1).ToUpper()+$role.substring(1).tolower()

            $i++

        }

		$_UserRoleUpdateStatus = New-Object System.Collections.ArrayList

    }

    Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_Connection.Name)' Appliance (of $($ApplianceConnection.Count))"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Validating requested role values"
			
			$_unsupportedRoles = New-Object System.Collections.ArrayList
			$_NewUserRoles     = New-Object System.Collections.ArrayList

			#Validate roles provided are allowed.
			foreach ($_role in $Roles) 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing role: $_role"

				if (-not ((${Global:ConnectedSessions} | ? Name -EQ $_Connection.Name).ApplianceSecurityRoles -contains $_role)) 
				{ 
				
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Invalid or unsupported"

					[void]$_unsupportedRoles.Add($_role)
			
				}

				else
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Supported"

					$_roleObject = [PsCustomObject]@{
					    roleName = $_role;
					    type = "RoleNameDtoV2"
					}

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding to role collection: $($_roleObject | fl * | out-string)"

					[void]$_NewUserRoles.Add($_roleObject)

				}

			}

			if ($_unsupportedRoles.count -ge 1) 
			{ 
        
				$errorRecord = New-ErrorRecord ArgumentException UnsupportedRolesFound InvalidArgument $($MyInvocation.InvocationName.ToString().ToUpper()) -Message "The '$($_unsupportedRoles -join ", ")' role(s) is/are not supported or the correct names.  Please validate the -roles parameter contains one or more valid roles.  Allowed roles are: $((${Global:ConnectedSessions} | ? Name -EQ $_Connection.Name).ApplianceSecurityRoles -join ", ")"
				$PSCmdlet.ThrowTerminatingError($errorRecord)            
            
			}

			if ($Name -is [PSCustomObject] -and $Name.category -eq 'users')
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Name parameter value is a User object"

				$_Name = $Name.userName

			}

			elseif ($Name -is [PSCustomObject] -and $Name.category -ne 'users')
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Name parameter value is NOT a valid User object"

				$errorRecord = New-ErrorRecord HPOneView.Appliance.UserResourceException InvalidUserObject InvalidArgument "Name" -TargetType 'PSObject' -Message "The object provided via the pipeline for the Name parameter is not a valid user object. Please check the value and try again."
				$pscmdlet.ThrowTerminatingError($errorRecord)

			}

			else
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Name parameter value is string"

				$_Name = $Name

			}

			$_setUserRolesUri = "/rest/users/" + $_Name + "/roles?multiResource=true"

			Try
			{

				$_resp = Send-HPOVRequest $_setUserRolesUri PUT $_NewUserRoles -Hostname $_Connection.Name

			}
		
    
			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			[void]$_UserRoleUpdateStatus.Add($_resp)

		}

    }

    End 
	{

        Return $_UserRoleUpdateStatus

    }

}

function Set-HPOVInitialPassword  
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = 'Default')]
    Param 
	(

        [parameter (Position = 0, Mandatory, HelpMessage = "User account.", ParameterSetName = 'Default')]
        [ValidateNotNullOrEmpty()]
        [Alias("user")]
        [String]$UserName = "Administrator",

        [parameter (Position = 1, Mandatory, HelpMessage = "Original password", ParameterSetName = 'Default')]
        [ValidateNotNullOrEmpty()]
        [string]$OldPassword,

        [parameter (Position = 2, Mandatory, HelpMessage = "New Password", ParameterSetName = 'Default')]
        [ValidateNotNullOrEmpty()]
        [string]$NewPassword,

		[parameter(Position = 3, Mandatory, HelpMessage = "Provide the IP Address or FQDN of the Appliance to connect to.", ParameterSetName = 'Default')]
        [ValidateNotNullOrEmpty()]
		[Object]$Appliance = $null

	)

	Begin 
	{ 

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		#Check to see if a connection to the appliance exists
        if (-not(${Global:ConnectedSessions}.Name -contains $Appliance) -and (-not(${Global:ConnectedSessions} | ? Name -eq $Appliance).SessionID))
        {

			write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Appliance Session not found. Running FTS sequence?"

            write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Creating temporary Session object"

            [HPOneView.Appliance.Connection]$_ApplianceConnection = New-Object HPOneView.Appliance.Connection

			$_ApplianceConnection.ConnectionId = 99
			$_ApplianceConnection.Name         = $Appliance
			$_ApplianceConnection.SessionID    = 'TemporaryConnection'
			$_ApplianceConnection.SslChecked   = $true

            [void]${Global:ConnectedSessions}.Add($_ApplianceConnection)

			write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $($_ApplianceConnection | out-string)"
            
        }

		else
		{

			$_ApplianceConnection = ${Global:ConnectedSessions} | ? Name -eq $Appliance

		}
    
    }

    Process 
	{
        
        $body = [PSCustomObject]@{
			
			userName    = $userName; 
			oldPassword = $oldPassword; 
			newPassword = $newPassword;
		
		}

        $uri  = $usersUri + "/changePassword"

        Try
		{

			$resp = Send-HPOVRequest $uri POST $body -Hostname $_ApplianceConnection.Name

		}

		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

		if ((${Global:ConnectedSessions} | ? Name -eq $_ApplianceConnection.Name).SessionID -eq 'TemporaryConnection')
		{

			write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Removing temporary Session object"

			[void]${Global:ConnectedSessions}.Remove($_ApplianceConnection)

		}

    }

    End 
	{

        return $resp

    }

}

function Get-HPOVLdap 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding(DefaultParameterSetName='Default')]
	param 
	(

        [Parameter(Mandatory, ParameterSetName = 'Export')]
        [Alias('x')]
        [switch]$Export,

        [Parameter(Position = 1, Mandatory, ParameterSetName = 'Export')]
        [Alias('location')]
        [ValidateScript({split-path $_ | Test-Path})]
        [string]$Save,
		
		[parameter(Mandatory = $false, ParameterSetName = 'Default')]
		[parameter(Mandatory = $false, ParameterSetName = 'Export')]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}
    
	)

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_GlobalAuthDirectorySettings = New-Object System.Collections.ArrayList
        
	}
	
	Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_Connection.Name)' Appliance (of $($ApplianceConnection.Count))"

			Try
			{

				$_AuthDirectoryGlobalSettings = Send-HPOVRequest $authnSettingsUri -Hostname $_Connection.Name
				
				$_AuthDirectoryGlobalSettings | % { $_.psobject.typenames.Insert(0,”HPOneView.Appliance.AuthGlobalDirectoryConfiguration") }

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			[void]$_GlobalAuthDirectorySettings.Add($_AuthDirectoryGlobalSettings)

		}
		
	}

	end 
	{

        if ($PSBoundParameters['export'])
		{

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Exporting Global Directory configuration."

			ForEach ($_Directory in $_GlobalAuthDirectorySettings)
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Saving to: $($save)\$($_Directory.ApplianceConnection.Name)_globalSettings.json"

				ConvertTo-Json $_Directory > $save\$($_Directory.ApplianceConnection.Name)_globalSettings.json

			}		

        }

        else
		{
 			
			Return $_GlobalAuthDirectorySettings 

        }

	}

}

function Get-HPOVLdapDirectory 
{

	# .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding(DefaultParameterSetName = 'Default')]
	param 
	(

		[Parameter(Position = 0, Mandatory = $false, ParameterSetName='Default')]
        [Alias('directory','domain')]
		[String]$Name,

        [Parameter(Mandatory = $true, ParameterSetName = 'Export')]
        [Alias('x')]
		[ValidateScript({split-path $_ | Test-Path})]
        [string]$Export,

		[parameter(Mandatory = $false, ParameterSetName = 'Default')]
		[parameter(Mandatory = $false, ParameterSetName = 'Export')]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}
    
	)

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_AuthDirectorySettings = New-Object System.Collections.ArrayList
        
	}
	
	Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{
		
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_Connection.Name)' Appliance (of $($ApplianceConnection.Count))"

			Try
			{

				$_AuthDirectories = Send-HPOVRequest $authnProvidersUri -Hostname $_Connection.Name
			
				$_AuthDirectories | % { 
					
					Try
					{

						$_AuthDirectory = Send-HPOVRequest $_.uri -Hostname $_AuthDirectories.ApplianceConnection.Name

					}
					
					Catch 
					{

						PSCmdlet.ThrowTerminatingError($_)

					}

					$_AuthDirectory.PSObject.TypeNames.Insert(0,”HPOneView.Appliance.AuthDirectory") 
				
					[void]$_AuthDirectorySettings.Add($_AuthDirectory)

				}

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}

	}

	End 
	{

		If ($Name) 
		{

			$_AuthDirectorySettings = $_AuthDirectorySettings | ? name -like $name

			if ($_AuthDirectorySettings.Count -eq 0)
			{
				
				$errorRecord = New-ErrorRecord HPOneView.Appliance.LdapDirectoryException AuthDirectoryResourceNotFound ObjectNotFound "Name" -Message "The specified '$name' Authentication Directory resource not found.  Please check the name and try again."
                
                $PSCmdlet.ThrowTerminatingError($errorRecord)

            }

        }
    
	    #Export directory settings (raw JSON) to file
        if ($PSboundParameters['export'])
		{

            #Loop through each directory and get all configured settings
            ForEach ($_directory in $_AuthDirectorySettings)
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Exporting Directory $($_directory.name) configuration."

				$_SaveLocation = $Export + "\" + $_directory.ApplianceConnection.Name + "_" + $_directory.name + ".json"

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Saving to: $_SaveLocation"
                
				$_directory                  | Select-Object * -ExcludeProperty credential,created,modified,eTag 			
				$_directory.directoryServers | Select-Object * -ExcludeProperty directoryServerCertificateStatus,serverStatus,created,modified,eTag
				$_directory                  | convertto-json > $_SaveLocation
            
			}
        
		}
        
        else
		{
            
            Return $_AuthDirectorySettings

        }

	}

}

function New-HPOVLdapDirectory 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding(DefaultParameterSetName='AD')]
	param
	(

		[Parameter(Position=0, Mandatory = $true, ParameterSetName = "AD")]
        [Parameter(Position=0, Mandatory = $true, ParameterSetName = "LDAP")]
        [ValidateNotNullOrEmpty()]
		[String]$Name,

		[Parameter(Mandatory = $true, ParameterSetName = "AD")]
		[Switch]$AD,

		[Parameter(Mandatory = $true, ParameterSetName = "LDAP")]
		[Alias('LDAP')]
		[Switch]$OpenLDAP,

		[Parameter(Position = 2, Mandatory = $true, ParameterSetName = "AD")]
        [Parameter(Position = 2, Mandatory = $true, ParameterSetName = "LDAP")]
		[ValidateNotNullOrEmpty()]
		[Alias('root','rootdn')]
        [String]$BaseDN,

		[Parameter(Position = 3, Mandatory = $true, ParameterSetName = "LDAP")]
        [ValidateSet('UID','CN')]
		[String]$UserAttribute,

        [Parameter(Position = 4, Mandatory = $true, ParameterSetName = "LDAP")]
        [ValidateNotNullOrEmpty()]
		[Array]$OrganizationalUnits,

        [Parameter(Position = 3, Mandatory = $true, ParameterSetName = "AD")]
        [Parameter(Position = 5, Mandatory = $true, ParameterSetName = "LDAP")]
        [ValidateNotNullOrEmpty()]
		[Array]$Servers,

        [Parameter(Position = 4, Mandatory = $true, ParameterSetName = "AD")]
        [Parameter(Position = 6, Mandatory = $true, ParameterSetName = "LDAP")]
        [ValidateNotNullOrEmpty()]
		[Alias('u','user')]
        [String]$Username,

        [Parameter(Position = 5, ValueFromPipeline = $true, Mandatory = $true, ParameterSetName = "AD")]
        [Parameter(Position = 7, ValueFromPipeline = $true, Mandatory = $true, ParameterSetName = "LDAP")]
        [ValidateNotNullOrEmpty()]
		[Alias('p','pass')]
        [SecureString]$Password,

		[parameter(Mandatory = $false, ParameterSetName = 'Default')]
		[parameter(Mandatory = $false, ParameterSetName = 'Export')]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}
    
	)

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_AuthDirectorySettings = New-Object System.Collections.ArrayList
        
	}
	
	Process 
	{

		$_decryptPassword = [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($Password))

		ForEach ($_Connection in $ApplianceConnection)
		{
		
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_Connection.Name)' Appliance (of $($ApplianceConnection.Count))"

			$_NewAuthDirectoryObj = NewObject -AuthDirectory
		
			$_NewAuthDirectoryObj.name                = $Name
			$_NewAuthDirectoryObj.baseDN              = $BaseDN
			$_NewAuthDirectoryObj.credential.userName = $Username
			$_NewAuthDirectoryObj.credential.password = $_decryptPassword
        
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Validating Server object values"

			ForEach ($_Server in $Servers)
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Type: $($_Server.GetType().Name)"

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Type: $($_Server | fl * | Out-String)"

				if ($_Server -is [PSCustomObject] -and $_Server.type -eq 'LoginDomainDirectoryServerInfoDto')
				{

					[void]$_NewAuthDirectoryObj.directoryServers.Add($_Server)

				}

				else
				{

					$errorRecord = New-ErrorRecord HPOneView.Appliance.LdapDirectoryException InvalidDirectoryServer InvalidArgument 'Servers' -TargetType ($_Server.GetType().Name) -Message "The Servers parameter contains an invalid Server object: $($_Server | fl * | Out-String).  Please correct this value and try again."
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

			}

			if ($PSBoundParameters['OpenLDAP'])
			{

				$_NewAuthDirectoryObj.authProtocol = 'LDAP'

				ForEach ($_ou in $OrganizationalUnits)
				{

					if ($_ou.type -match $OrganizationalUnitPattern)
					{

						[void]$_NewAuthDirectoryObj.orgUnits.Add($Server)

					}

					else
					{

						$errorRecord = New-ErrorRecord HPOneView.Appliance.LdapDirectoryException InvalidDirectoryServer InvalidArgument 'OrganizationalUnits' -Message "The OrganizationalUnits parameter contains an invalid OU value: '$_ou'.  Please correct this value and try again."
						$PSCmdlet.ThrowTerminatingError($errorRecord)

					}

				}

			}

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] New Authentication Directory Object: $($_NewAuthDirectoryObj | fl * | Out-String)"

			Try
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Validating authentication directory setting is valid"

				$_validateresp = Send-HPOVRequest $authnProviderValidatorUri POST $_NewAuthDirectoryObj -Hostname $_Connection

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Submitting request to create new authentication directory"

				$_resp = Send-HPOVRequest $authnProvidersUri POST $_NewAuthDirectoryObj -Hostname $_Connection

				$_resp.PSObject.TypeNames.Insert(0,”HPOneView.Appliance.AuthDirectory")

				[void]$_AuthDirectorySettings.Add($_resp)

			}

			Catch
			{

				foreach ($NestedError in (${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.nestedErrors) 
				{

					if ($NestedError.errorCode -eq "AUTHN_LOGINDOMAIN_SERVER_AUTHENTICATION_ERROR" ) 
					{ 
						
						$ErrorCategory = 'AuthenticationError' 

					}

					elseif ($NestedError.errorCode -eq "AUTHN_LOGINDOMAIN_DUPLICATE_NAME" ) 
					{ 
						
						$ErrorCategory = 'ResourceExists' 

					}

					else 
					{ 
						
						$ErrorCategory = 'InvalidOperation' 
					
					}

					$errorRecord = New-ErrorRecord HPOneView.Appliance.LdapDirectoryException $NestedError.errorCode $ErrorCategory $NestedError.errorSource -Message "$($NestedError.message) $($NestedError.details)"
					$PSCmdlet.WriteError($errorRecord)

				}

				$errorRecord = New-ErrorRecord HPOneView.Appliance.LdapDirectoryException (${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.errorCode InvalidOperation 'New-HPOVLdap' -Message "$((${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.message) $((${Global:ResponseErrorObject} | ? Name -eq $ApplianceHost.Name).ErrorResponse.details)"
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

		}

    }

    End 
	{

		Return $_AuthDirectorySettings
       
	}

}

function Remove-HPOVLdapDirectory 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding(DefaultParameterSetName = "default", SupportsShouldProcess = $True, ConfirmImpact = 'High')]
	param
	(

		[parameter(Mandatory, ValueFromPipeline, HelpMessage = "Enter the Directory name", Position = 0, ParameterSetName = "default")]
		[parameter(Mandatory, ParameterSetName = "ApplianceRequired", position = 0)]
		[ValidateNotNullOrEmpty()]
		[alias("d")]
		[Object]$Directory,
	
		[parameter(Mandatory = $False, ValueFromPipelineByPropertyName, ParameterSetName = "ApplianceRequired", position = 1)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = $Null,

		[switch]$Force

    )

    Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		if (-not($PSBoundParameters['Directory'])) { $PipelineInput = $True }

		$_TaskCollection    = New-Object System.Collections.ArrayList
		$_DirectoryCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{

		if ($PipelineInput) 
		{ 

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Pipeline input"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Directory Object provided: $($Directory | FL * | Out-String)"

			If ($Resource.category -eq 'users')
			{

				If (-not($Directory.ApplianceConnection))
				{

					$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument "Directory:$($Directory.Name)" -TargetType PSObject -Message "The Directory resource provided is missing the source ApplianceConnection property.  Please check the object provided and try again."
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				[void]$_DirectoryCollection.Add($Directory)

			}

			else
			{

				$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument "Directory:$($Directory.Name)" -TargetType PSObject -Message "The Directory resource is not an expected category type [$($Directory.category)].  Allowed resource category type is 'users'.  Please check the object provided and try again."
                $PSCmdlet.ThrowTerminatingError($errorRecord)

			}
        
		}

		else 
		{

			ForEach ($_Connection in $ApplianceConnection)
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Appliance $($_Connection.Name) (of $($ApplianceConnection.Count))"

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Directory Name $($Directory)"

				Try
				{

					$_directory = Get-HPOVLdapDirectory $Directory -ApplianceConnection $_Connection

					$_directory | % {

						[void]$_DirectoryCollection.Add($_)

					}

				}

				Catch
				{

					if ($_.FullyQualifiedErrorId -match 'AuthDirectoryResourceNotFound')
					{

						$errorRecord = New-ErrorRecord HPOneView.Appliance.LdapDirectoryException AuthDirectoryResourceNotFound ObjectNotFound 'Directory' -Message "The Directory '$Directory' was not found on Appliance '$($_Connection.Name)'."
						$PSCmdlet.WriteError($errorRecord)

					}

					else
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

				}				

			}

		}
        
    }

	End
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing $($_DirectoryCollection.count) Authentication Directory resources to remove."

		#Process Directory Resources
		ForEach ($_Directory in $_DirectoryCollection)
		{

			if ($pscmdlet.ShouldProcess($_Directory.ApplianceConnection.Name,"remove directory '$($_Directory.name)'")) 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Removing Directory '$($_Directory.name)' from appliance '$($_Directory.ApplianceConnection.Name)'."

				Try
				{
					
					$_resp = Send-HPOVRequest $_Directory.Uri DELETE -Hostname $_Directory.ApplianceConnection.Name

					$_resp | Add-Member -NotePropertyName name -NotePropertyValue $_Directory.name

					[void]$_TaskCollection.Add($_resp)

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

			}

			elseif ($PSBoundParameters['WhatIf'])
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] WhatIf parameter was passed."

			}

			Return $_TaskCollection

		}

	}

}

Function Set-HPOVLdapDefaultDirectory 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml
    
	[CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'High')]
	param
	(

		[Parameter(Position = 0, Mandatory, ValueFromPipeline, HelpMessage = "Please provide the LDAP/AD Directory Name or Object.")]
		[ValidateNotNullOrEmpty()]
		[Object]$Directory = $Null,

		[Switch]$DisableLocalLogin,
	
		[parameter(Mandatory = $False, ValueFromPipelineByPropertyName, position = 1)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = $Null
	
	)

	Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSBoundParameters['Directory'])) 
		{ 
			
			$PipelineInput = $True 
	
		}

		else
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

			$c = 0

			ForEach ($_Connection in $ApplianceConnection) 
			{

				Try 
				{
	
					$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

				}

				Catch [HPOneview.Appliance.AuthSessionException] 
				{

					$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				Catch 
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

				$c++

			}

		}

		$_TaskCollection      = New-Object System.Collections.ArrayList
		$_DirectoryCollection = New-Object System.Collections.ArrayList
	
	}

	#Build collection of objects to process
	Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Appliance $($_Connection.Name) (of $($ApplianceConnection.Count)"

			#Create default Directory configuration object
			$_DefaultDirectoryConfig = [PSCustomObject]@{
			
				allowLocalLogin     = (-not($DisableLocalLogin.IsPresent));
				defaultLoginDomain  = $Null;
				ApplianceConnection = $_Connection

			}

			switch ($Directory.Gettype().Name) 
			{

				"String" 
				{

					if ($Directory -ne "Local") 
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Authentication Directory Name provided: $Directory"

						$_Directory = Get-HPOVLdapDirectory $Directory -Hostname $_Connection.Name

					}

					elseif ($Directory -eq "Local") 
					{

						$_Directory = [PSCustomObject] @{

							type                = 'LoginDomainConfigInfoDto';
							name                = "LOCAL";
							uri                 = "";
							loginDomain         = "0";

						}

					}

				}

				"PSCustomObject" 
				{

					if ($Directory.type -eq 'LoginDomainConfigVersion2Dto') 
					{

						Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Authentication Directory Object provided: $($Directory | out-string)"

					}

					else 
					{

						$errorRecord = New-ErrorRecord HPOneView.Appliance.LdapDirectoryException InvalidAuthDirectoryObject InvalidArgument "Directory" -TargetType "PSObject" -Message "The authentication directory object type '$($Directory.type)' provided is not correct.  The type must be 'LoginDomainConfigVersion2Dto'.  Please correct the value and try again."

						$PSCmdlet.ThrowTerminatingError($errorRecord)

					}

				}

			}

			$_DefaultDirectoryConfig.defaultLoginDomain = ($_Directory | Select-Object type,loginDomain,name,eTag,uri)

			[void]$_DirectoryCollection.Add($_DefaultDirectoryConfig)

		}

	}

	#Process objects here
	End 
	{

		ForEach ($_DirectoryToProcess in $_DirectoryCollection)
		{

			if ($pscmdlet.ShouldProcess($_DirectoryToProcess.ApplianceConnection.Name,"Set appliance authentication directory $($_DirectoryToProcess.defaultLoginDomain.name) as default domain")) 
			{
		
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Authentication Directory Object request: $($_DirectoryToProcess | out-string)"

				Try
				{

					$_resp = Send-HPOVRequest $authnSettingsUri POST $_DirectoryToProcess -Hostname $_DirectoryToProcess.ApplianceConnection.Name

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Setting PowerShell library AuthProvider registry value to '$$_DirectoryToProcess.defaultLoginDomain.name)'"

				Set-ItemProperty -Path HKCU:\Software\Hewlett-Packard\HPOneView -Name "AuthProvider#$($_DirectoryToProcess.ApplianceConnection.Name)" -Value $_DirectoryToProcess.defaultLoginDomain.name -Type STRING | write-verbose
				
			}

			elseif ($PSBoundParameters['WhatIf'])
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] WhatIf was passed."

				$_resp = $null

			}

			else
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] User likely selected 'No' to prompt."

				$_resp = $null

			}

			[void]$_TaskCollection.Add($_resp)

		}

		Return $Resp

	}

}

Function Enable-HPOVLdapLocalLogin 
{
		
    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'High')]
	param
	(

		[parameter(Mandatory = $False, position = 0)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}
	
	)

	Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_TaskCollection = New-Object System.Collections.ArrayList
	
	}

	Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Appliance $($_Connection.Name) (of $($ApplianceConnection.Count)"

			Try
			{
				
				#Get current auth directory configuration
				$_currentDirectoryConfig = Send-HPOVRequest $authnSettingsUri -Hostname $_Connection

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}
			
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Current global authentication settings: $($_currentDirectoryConfig | fl * | Out-String)"

			if ($pscmdlet.ShouldProcess($_Connection.Name,"enable local logins")) 
			{

				$_currentDirectoryConfig.allowLocalLogin = $True

				Try
				{
					
					#Update Configuration
					$_resp = Send-HPOVRequest $authnSettingsUri POST $_currentDirectoryConfig -Hostname $_Connection

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}
				
				[void]$_TaskCollection.Add($_resp)

			}

			elseif ($PSBoundParameters['Whatif'])
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] WhatIf parameter was passed."

			}

		}
		
	}

	End 
	{

		Return $_TaskCollection

	}

}

Function Disable-HPOVLdapLocalLogin 
{
		
    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'High')]
	param
	(

		[parameter(Mandatory = $False, position = 0)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}
	
	)

	Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_TaskCollection = New-Object System.Collections.ArrayList
	
	}

	Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Appliance $($_Connection.Name) (of $($ApplianceConnection.Count)"

			Try
			{
				
				#Get current auth directory configuration
				$_currentDirectoryConfig = Send-HPOVRequest $authnSettingsUri -Hostname $_Connection

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}
			
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Current global authentication settings: $($_currentDirectoryConfig | fl * | Out-String)"

			if ($pscmdlet.ShouldProcess($_Connection.Name,"disable local logins")) 
			{

				$_currentDirectoryConfig.allowLocalLogin = $false

				Try
				{
					
					#Update Configuration
					$_resp = Send-HPOVRequest $authnSettingsUri POST $_currentDirectoryConfig -Hostname $_Connection

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}
				
				[void]$_TaskCollection.Add($_resp)

			}

			elseif ($PSBoundParameters['Whatif'])
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] WhatIf parameter was passed."

			}

		}
		
	}

	End 
	{

		Return $_TaskCollection

	}

}

function New-HPOVLdapServer 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding(DefaultParameterSetName = "default")]
	param
	(
		
		[Parameter(Position = 0, Mandatory, ValueFromPipeline, ParameterSetName = "default")]
		[String]$Name = $Null,

		[Parameter(Position = 1, Mandatory = $false, ParameterSetName = "default")]
		[Alias('port')]
        [ValidateRange(1,65535)]
        [Int32]$SSLPort = 636,

        [Parameter(Position = 2, Mandatory = $false, ParameterSetName = "default")]
        [Alias('cert')]
        [Object]$Certificate = $null

	)

	begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"
        
		$_AuthDirectoryServer = New-Object System.Collections.ArrayList

    }

    Process 
	{

		if ($PSBoundParameters['Certificate'])
		{

			if (Test-Path $Certificate) 
			{ 

			    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Certificate file found."

			    $readfile = [System.IO.File]::OpenText($Certificate)
			    $certificate = $readfile.ReadToEnd()
			    $readfile.Close()
				$Base64Certificate = ($Certificate | Out-String) -join "`n"

			}

			else 
			{

			    $errorRecord = New-ErrorRecord System.IO.FileNotFoundException CertificateNotFound ObjectNotFound 'Certificate' -TargetType 'PSObject' -Message "Autehntication Directory Server SSL certiciate not found.  Please check the path of the public key, and try again."
			    $PSCmdlet.ThrowTerminatingError($errorRecord)

			}

		}

		else
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Attempting to retrieve Directory Server Secure LDAP Certificate"

			# // Support Getting LDAP Server Certificate    
			$uri = $Name + ":" + $Sslport

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] URI: $uri"
			   
			$WebRequest = [Net.WebRequest]::Create("https://$uri")

			try 
			{
				
				$Response = $WebRequest.GetResponse()
			
			}
			
			catch [Net.WebException] 
			{ 

			    if (-not($WebRequest.Connection) -and ([int]$Response.StatusCode -eq 0)) 
				{

			        Write-Error $_.Exception.Message -Category ObjectNotFound -ErrorAction Stop

			    } 

			}

			catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			#Close the response connection, as it is no longer needed, and will cause problems if left open.
			if ($response) 
			{ 
				
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Closing response connection"
			
				$Response.Close() 
			
			}

			if ($WebRequest.ServicePoint.Certificate -ne $null) 
			{
			    
				#Get certificate
				$Cert = New-Object Security.Cryptography.X509Certificates.X509Certificate2($WebRequest.ServicePoint.Certificate)

				$out = New-Object String[] -ArgumentList 3
				         
				$out[0] = "-----BEGIN CERTIFICATE-----"
				$out[1] = [System.Convert]::ToBase64String($Cert.RawData, "InsertLineBreaks")
				$out[2] = "-----END CERTIFICATE-----"

				$Base64Certificate = $out -join "`n"

			}

			# Error we couldn't get the certificate
			else
			{

				Write-Host "Unable to get cert."

			}

		}
        
        $_ldapServer = NewObject -AuthDirectoryServer

        $_ldapServer.directoryServerIpAddress             = $Name
        $_ldapServer.directoryServerCertificateBase64Data = $Base64Certificate

		if ($PSBoundParameters['Sslport'])
		{

			$_ldapServer.directoryServerSSLPortNumber = [string]$sslport 

		}
        

		$_ldapServer.PSObject.TypeNames.Insert(0,'HPOneView.Appliance.AuthDirectoryServer')

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] New Auth Directory Server Object: $($_ldapServer | fl * | Out-String)"

        [void]$_AuthDirectoryServer.Add($_ldapServer)

	}

    End 
	{

        Return $_AuthDirectoryServer

    }

}

function Show-HPOVLdapGroups 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding()]
	param
	(

         [parameter(Mandatory = $true,HelpMessage = "Enter the user name",Position=0)]
         [ValidateNotNullOrEmpty()]
         [alias("u")]
         [string]$UserName,

         [parameter(Mandatory = $true,ValueFromPipeline = $true,HelpMessage = "Enter the password",Position=1)]
         [alias("p")]
         [ValidateNotNullOrEmpty()]
         [SecureString]$Password,

         [parameter(Mandatory = $true,HelpMessage = "Enter the Directory name",Position=2)]
         [ValidateNotNullOrEmpty()]
         [alias("d","domain","directory")]
         [string]$AuthProvider
    
	)

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

        if (-not($global:cimgmtSessionId)) {
        
            $errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoAuthSession AuthenticationError $($MyInvocation.InvocationName.ToString().ToUpper()) -Message "No valid session ID found.  Please use Connect-HPOVMgmt to connect and authenticate to an appliance."
            $PSCmdlet.ThrowTerminatingError($errorRecord)

        }

    }


	process {
 
        $decryptPassword = [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($password))
        $body = @{userName=$username; password=$decryptPassword; authLoginDomain=$authProvider}

		$groups = Send-HPOVRequest $script:authnDirectoryGroups POST -body $body

        if ($groups.count -eq 0){ Write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No LDAP groups found."}
        else {

			Write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $($groups.count) LDAP groups found: $($groups)"

			$DirectoryGroups = [PSCustomObject]@{Name = @()}
                
			$groups | % { $_.psobject.typenames.Insert(0,”HPOneView.Appliance.AuthDirectoryGroup") }

        }

	}

    end {
    
        return $groups
    }

}

function Get-HPOVLdapGroup 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding(DefaultParameterSetName = 'Default')]
	param
	(

        [parameter(Position = 0, Mandatory = $false, HelpMessage = "Enter the Directroy Group Name", ParameterSetName = 'Default')]
		[ValidateNotNullorEmpty()]
        [alias("group","GroupName")]
        [string]$Name,

        [Parameter(Mandatory = $true, ParameterSetName = 'Export')]
        [Alias('x')]
		[ValidateScript({split-path $_ | Test-Path})]
        [string]$Export,
		
		[parameter(Mandatory = $false, ParameterSetName = 'Default')]
		[parameter(Mandatory = $false, ParameterSetName = 'Export')]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}
    
	)

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_DirectoryGroupsCollection = New-Object System.Collections.ArrayList
        
	}
	
	Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{
		
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_Connection.Name)' Appliance (of $($ApplianceConnection.Count))"

			Try
			{ 
				
				$_Groups = Send-HPOVRequest $authnEgroupRoleMappingUri -Hostname $_Connection.Name

				ForEach ($_Group in $_Groups.members)
				{

					$_Group.PSObject.TypeNames.Insert(0,”HPOneView.Appliance.AuthDirectoryGroupRoleMapping") 
				
					[void]$_DirectoryGroupsCollection.Add($_Group)

				}

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}      

	}

	End 
	{

        if ($PSBoundParameters['Name']) 
		{ 
			
			$_DirectoryGroupsCollection = $_DirectoryGroupsCollection | ? egroup -eq $Name

			if ($_DirectoryGroupsCollection.Count -eq 0)
			{
				
				$errorRecord = New-ErrorRecord HPOneView.Appliance.LdapDirectoryGroupException AuthDirectoryGroupResourceNotFound ObjectNotFound "Name" -Message "The specified '$name' Authentication Directory Group resource not found.  Please check the name and try again."
                
                $PSCmdlet.ThrowTerminatingError($errorRecord)

            }
		
		}

        if ($PSBoundParameters['Name'])
		{ 
			
			$_DirectoryGroupsCollection | convertto-json > $Export 
		
		}
 
        else 
		{

            Return $_DirectoryGroupsCollection

        }

	}

}

function New-HPOVLdapGroup 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding(DefaultParameterSetName = 'Default')]
	param
	(

		[parameter(Mandatory = $true,HelpMessage = "Enter the Directory name",Position=0, ParameterSetName = 'Default')]
		[ValidateNotNullOrEmpty()]
		[alias("d","domain","directory")]
		[string]$authProvider,

		[parameter(Mandatory = $true,HelpMessage = "Enter the Directroy Group name in Distinguished Name format (i.e. CN=Admin Group,OU=Admins,DC=Domain,DC=com",Position=1, ParameterSetName = 'Default')]
		[ValidateNotNullOrEmpty()]
		[alias("g","group","name")]
		[string]$GroupName,

		[parameter(Mandatory = $true,HelpMessage = "Enter the Directroy Group roles in System.Array format",Position=2, ParameterSetName = 'Default')]
		[ValidateNotNullOrEmpty()]
		[alias("r","role")]
		[Array]$Roles,

		[parameter(Mandatory = $true,HelpMessage = "Enter the user name",Position=3, ParameterSetName = 'Default')]
		[ValidateNotNullOrEmpty()]
		[alias("u")]
		[string]$UserName,

		[parameter(Mandatory = $true,ValueFromPipeline = $true,HelpMessage = "Enter the password",Position=4, ParameterSetName = 'Default')]
		[alias("p")]
		[ValidateNotNullOrEmpty()]
		[SecureString]$Password,
			
		[parameter(Mandatory = $false, ParameterSetName = 'Default')]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

	)

    Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"


		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		ForEach ($_Connection in $_tmpApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_DirectroyGroupStatus = New-Object System.Collections.ArrayList

		$_decryptPassword = [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($password))

	}

	Process
	{
		
		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_Connection.Name)' Appliance (of $($ApplianceConnection.Count))"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Validating requested role values"
			
			$_unsupportedRoles = New-Object System.Collections.ArrayList
			$_Roles            = New-Object System.Collections.ArrayList

			#Validate roles provided are allowed.
			foreach ($_role in $Roles) 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing role: $_role"

				if (-not ((${Global:ConnectedSessions} | ? Name -EQ $_Connection.Name).ApplianceSecurityRoles -contains $_role)) 
				{ 
				
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Invalid or unsupported"

					[void]$_unsupportedRoles.Add($_role)
			
				}

				else
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Supported"

					[void]$_NewUserRoles.Add($_Roles)

				}

			}

			if ($_unsupportedRoles.count -ge 1) 
			{ 
        
				$errorRecord = New-ErrorRecord ArgumentException UnsupportedRolesFound InvalidArgument $($MyInvocation.InvocationName.ToString().ToUpper()) -Message "The '$($_unsupportedRoles -join ", ")' role(s) is/are not supported or the correct names.  Please validate the -roles parameter contains one or more valid roles.  Allowed roles are: $((${Global:ConnectedSessions} | ? Name -EQ $_Connection.Name).ApplianceSecurityRoles -join ", ")"
				$PSCmdlet.ThrowTerminatingError($errorRecord)            
            
			}
		
			#Get new Directory Group object   
			$_NewGroup = NewObject -DirectoryGroup
			
			$_NewGroup.group2rolesPerGroup.loginDomain          = $authProvider
			$_NewGroup.group2rolesPerGroup.egroup               = $GroupName
			$_NewGroup.group2rolesPerGroup.roles                = $_Roles
			$_NewGroup.group2rolesPerGroup.credentials.userName = $UserName
			$_NewGroup.group2rolesPerGroup.credentials.password = $_decryptPassword
		
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Directory Group requested to create:  $($_NewGroup | out-string )"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request to create $($_NewGroup.egroup) Directory Group"
			
			Try
			{

				$_resp = Send-HPOVRequest $authnEgroupRoleMappingUri POST $_NewGroup -Hostname $_Connection

			}
			
			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$_resp.PSObject.TypeNames.Insert(0,'HPOneView.Appliance.AuthDirectoryGroup')

			[void]$_DirectroyGroupStatus.Add($_resp)
	       
		}

	}

	End
	{
		
		Return $_DirectroyGroupStatus

    }

}

function Set-HPOVLdapGroupRole 
{

	# .ExternalHelp HPOneView.200.psm1-help.xml
    
	[CmdletBinding(DefaultParameterSetName = 'Default')]
	param
	(

		[parameter(Position = 0, Mandatory, HelpMessage = "Enter the Directory name", ParameterSetName = 'Default')]
		[ValidateNotNullOrEmpty()]
		[alias("d","domain","directory")]
		[string]$authProvider,

		[parameter(Position = 1, Mandatory, ValueFromPipeline, HelpMessage = "Enter the Directroy Group name", ParameterSetName = 'Default')]
		[ValidateNotNullOrEmpty()]
		[alias("g","name",'GroupName')]
		[Object]$Group,

		[parameter(Position = 2, Mandatory, HelpMessage = "Enter the Directroy Group roles in System.Array format", ParameterSetName = 'Default')]
		[ValidateNotNullOrEmpty()]
		[alias("r","role")]
		[Array]$Roles,

		[parameter(Position = 3, Mandatory, HelpMessage = "Enter the user name", ParameterSetName = 'Default')]
		[ValidateNotNullOrEmpty()]
		[alias("u")]
		[string]$UserName,

		[parameter(Position = 4, Mandatory, HelpMessage = "Enter the password", ParameterSetName = 'Default')]
		[alias("p")]
		[ValidateNotNullOrEmpty()]
		[SecureString]$Password,
		
		[parameter(Mandatory = $false, ValueFromPipelineByPropertyName, ParameterSetName = 'ApplianceRequired')]
		[ValidateNotNullorEmpty()]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

    )

    Begin 
	{
		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		#No need to validate ApplianceConnection, as object is passed via pipeline.
		if (-not($PSboundParameters['Group']))
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Pipeline input."
			
			$PipelineInput = $True

		}

		else
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

			$c = 0

			ForEach ($_Connection in $ApplianceConnection) 
			{

				Try 
				{
	
					$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

				}

				Catch [HPOneview.Appliance.AuthSessionException] 
				{

					$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				Catch 
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

				$c++

			}
						
		}

		$_DirectoryGroupsToUpdate = New-Object System.Collections.ArrayList
		$_DirectoryGroupStatus    = New-Object System.Collections.ArrayList

		#Decrypt the password
		$_decryptPassword = [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($password))

    }

	Process 
	{
 
        if ($PipelineInput)
		{

			#Validate pipeline input is user object
			if (-not($Group -is [PSCustomObject]) -and -not($Group.category -eq 'users'))
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Invalid Group provided: $($Group | FL * | Out-String)"

				$errorRecord = New-ErrorRecord HPOneView.Appliance.LdapDirectoryGroupException InvalidDirectoryGroupObject InvalidArgument "Group" -TargetType 'PSObject' -Message "The Group parameter value is not a valid Directory Group object resource.  Object category provided '$($Group.category)', allowed object category value 'users'.  Please verify the input object and try again."
				$pscmdlet.ThrowTerminatingError($errorRecord)

			}

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Adding Group to process collection: $($Group | FL * | Out-String)"

			[void]$_DirectoryGroupsToUpdate.Add($Group)

		}

		else
		{

			ForEach ($_Connection in $ApplianceConnection)
			{

				try 
				{ 
					
					$_GroupObject = Get-HPOVUser $userName -ApplianceConnection $_Connection
				
				}
        
				#If not found, throw error
				catch [HPOneView.Appliance.LdapDirectoryGroupException]
				{
				
				    #Generate terminating error
				    $errorRecord = New-ErrorRecord HPOneView.Appliance.LdapDirectoryGroupException AuthDirectoryGroupResourceNotFound ObjectNotFound 'Group' -Message "Group `'$Group`' was not found. Please check the spelling, or create the user and try again."
				    $pscmdlet.ThrowTerminatingError($errorRecord)
				
				}

				Catch
				{

					$pscmdlet.ThrowTerminatingError($_)

				}

				[void]$_DirectoryGroupsToUpdate.Add($_GroupObject)

			}

		}

    }

	End
	{

		ForEach ($_Group in $_DirectoryGroupsToUpdate)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Group: $($_Group.egroup)"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Original Group object: $($_Group | FL * | Out-String)"

			#Validate roles provided are allowed.
			$_unsupportedRoles = New-OBject System.Collections.ArrayList
			$_NewGroupRoles    = New-Object System.Collections.ArrayList

			#Validate roles provided are allowed.
			foreach ($_role in $Roles) 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing role: $_role"

				if (-not ((${Global:ConnectedSessions} | ? Name -EQ $_Group.ApplianceConnection.Name).ApplianceSecurityRoles -contains $_role)) 
				{ 
							
					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Invalid or unsupported"

					[void]$_unsupportedRoles.Add($_role)
						
				}

				else
				{

					Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Supported"

					$_role.substring(0,1).ToUpper()+$_role.substring(1).tolower()

					[void]$_NewGroupRoles.Add($_role)

				}

			}

			if ($_unsupportedRoles.count -ge 1) 
			{ 
        
				$errorRecord = New-ErrorRecord ArgumentException UnsupportedRolesFound InvalidArgument $($MyInvocation.InvocationName.ToString().ToUpper()) -Message "The '$($_unsupportedRoles -join ", ")' role(s) is/are not supported or the correct names.  Please validate the -roles parameter contains one or more valid roles.  Allowed roles are: $((${Global:ConnectedSessions} | ? Name -EQ $_Connection.Name).ApplianceSecurityRoles -join ", ")"
				$PSCmdlet.ThrowTerminatingError($errorRecord)            
						
			}

			$_Group.roles = $_NewUserRoles

			$_UpdateDirectroyGroup = NewObject -DirectoryGroup
			$_UpdateDirectroyGroup.group2rolesPerGroup  = $_Group
			$_UpdateDirectroyGroup.credentials.userName = $UserName
			$_UpdateDirectroyGroup.credentials.password = $_decryptPassword
			
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Updated Group object: $($_UpdateDirectroyGroup | FL * | Out-String)"

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Sending request to update `'$($_Group.egroup)`' group at '$authnEgroupRoleMappingUri'"

			Try
			{

				$_resp = Send-HPOVRequest $authnEgroupRoleMappingUri PUT $updateUser -Hostname $_User.ApplianceConnection.Name

			}
            
			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$_resp.PSObject.TypeNames.Insert(0,'HPOneView.Appliance.User')

			[void]$_DirectoryGroupStatus.Add($_resp)

		}
        
		Return $_DirectoryGroupStatus

	}

}

function Remove-HPOVLdapGroup 
{

	# .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding(DefaultParameterSetName = "default", SupportsShouldProcess = $True, ConfirmImpact = 'High')]
	param 
	(

		[parameter(Mandatory, ValueFromPipeline, HelpMessage = "Enter the Directory Group name", Position = 0, ParameterSetName = "default")]
		[ValidateNotNullOrEmpty()]
		[alias('g','Group')]
		[Object]$Name,
	
		[parameter(Mandatory = $False, ValueFromPipelineByPropertyName, ParameterSetName = "ApplianceRequired", position = 1)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = $Null

	)

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $_tmpApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] {

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		if (-not($PSBoundParameters['Name'])) { $PipelineInput = $True }

		$_TaskCollection  = New-Object System.Collections.ArrayList
		$_GroupCollection = New-Object System.Collections.ArrayList

    }

	Process 
	{
 
		if ($PipelineInput) 
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Pipeline input"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Group Object provided: $($Name | FL * | Out-String)"

			If ('users' -contains $Name.category)
			{

				If (-not($Name.ApplianceConnection))
				{

					$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument "Group:$($Name.Name)" -TargetType PSObject -Message "The Group object resource provided is missing the source ApplianceConnection property.  Please check the object provided and try again."
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				[void]$_GroupCollection.Add($Name)

			}

			else
			{

				$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument "Name" -TargetType PSObject -Message "The Group object resource is not an expected category type [$($Name.category)].  The allowed resource category type is 'users'.  Please check the object provided and try again."
                $PSCmdlet.ThrowTerminatingError($errorRecord)

			}

		}

		else 
		{

			ForEach ($_Connection in $ApplianceConnection)
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Appliance $($_Connection.Name) (of $($ApplianceConnection.Count))"

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Group Name $($Name)"

				Try
				{

					$_Group = Get-HPOVLdapGroup $Name -ApplianceConnection $_Connection

					$_Group | % {

						[void]$_GroupCollection.Add($_)

					}

				}

				Catch
				{

					if ($_.FullyQualifiedErrorId -match 'AuthDirectoryGroupResourceNotFound')
					{

						$errorRecord = New-ErrorRecord HPOneView.Appliance.LdapDirectoryGroupException AuthDirectoryGroupResourceNotFound ObjectNotFound 'Name' -Message "The Directory Group '$Name' was not found on Appliance '$($_Connection.Name)'."
						$PSCmdlet.WriteError($errorRecord)

					}

					else
					{

						$PSCmdlet.ThrowTerminatingError($_)

					}

				}				

			}

		}

	}

	End
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing $($_GroupCollection.count) Directory Group resources to remove."

		#Process Network Resources
		ForEach ($_Group in $_GroupCollection)
		{

			if ($PSCmdlet.ShouldProcess($_Group.ApplianceConnection.Name,"remove directory group '$($_Group.egroup)'")) 
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Removing Directory Group '$($_Group.egroup)' from appliance '$($_Group.ApplianceConnection.Name)'."

				Try
				{
					
					$_resp = Send-HPOVRequest $_Group.Uri DELETE -Hostname $_Group.ApplianceConnection.Name

					$_resp | Add-Member -NotePropertyName name -NotePropertyValue $_Group.egroup

					[void]$_TaskCollection.Add($_resp)

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

			}

			elseif ($PSBoundParameters['WhatIf'])
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] WhatIf parameter was passed."

			}

			Return $_TaskCollection

		}

	}

}

Function Get-HPOVAuditLog 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "default")]
    Param 
	(

		[parameter(Mandatory = $false, ParameterSetName = 'default')]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}
    
	)

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_AllAudiLogs = New-Object System.Collections.ArrayList
        
	}
	
	Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_Connection.Name)' Appliance (of $($ApplianceConnection.Count))"

			Try
			{
				
				#Send the request
				$_AuditLogs = Send-HPOVRequest $applAuditLogsUri -Hostname $_Connection

				$_AuditLogs | % {

					$_.PSObject.TypeNames.Insert(0,'HPOneView.Appliance.AuditLogEntry')

					[void]$_AllAudiLogs.Add($_)

				}

			}

			Catch [System.Net.WebException]
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}

    }

	End
	{

		Return $_AllAudiLogs

	}

}

Function Download-HPOVAuditLog 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = "default")]
    Param 
	(

        [parameter(Position = 0, Mandatory = $false, ValueFromPipeline = $false, ParameterSetName = "default", HelpMessage = "Specify the folder location to save the audit log file.")]
		[ValidateNotNullofEmpty()]
        [Alias("save")]
        [string]$Location = (get-location).Path,
		
		[parameter(Mandatory = $false, ParameterSetName = 'Export')]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}
    
	)

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_GlobalAuthDirectorySettings = New-Object System.Collections.ArrayList

		#Validate the path exists.  If not, create it.
		if (!(Test-Path $Location)){ 
            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Directory does not exist.  Creating directory..."
            New-Item $Location -itemtype directory
        }
        
	}
	
	Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_Connection.Name)' Appliance (of $($ApplianceConnection.Count))"

			Try
			{
				#Send the request
				#Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Please wait while the appliance backup is generated.  This can take a few minutes..."
	
				#Now that the Support Dump has been requested, download the file
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Downloading audit log to $($Location)"

				Download-File $applAuditLogDownloadUri $_Connection $Location

			}

			Catch [System.Net.WebException]
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}

    }

}

#######################################################
# Alerts & Events: 
#

function Get-HPOVAlert 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml
	
	[CmdletBinding(DefaultParameterSetName = "Default")]

    Param
	(

		[parameter(Position = 0, Mandatory = $false, ValueFromPipeline, HelpMessage = "Resource URI or Object (i.e. Get-HPOV*)", ParameterSetName = "ServerProfile")]
		[parameter(Position = 0, Mandatory = $false, ValueFromPipeline, HelpMessage = "Resource URI or Object (i.e. Get-HPOV*)", ParameterSetName = "Default")]
		[ValidateNotNullOrEmpty()]
		[alias('resourceUri')]
		[Object]$Resource = $null,

		[parameter(Position = 1, Mandatory = $false, HelpMessage = "Alert Severity 'OK','Critical','Disabled','Warning', or 'Unknown'.", ParameterSetName = "ServerProfile")]
		[parameter(Position = 1, Mandatory = $false, HelpMessage = "Alert Severity 'OK','Critical','Disabled','Warning', or 'Unknown'.", ParameterSetName = "Default")]
		[ValidateNotNullOrEmpty()]
		[ValidateSet('OK','Critical','Disabled','Warning','Unknown')]
		[string]$Severity = $null,

		[parameter(Position = 2, Mandatory = $false, HelpMessage = "Alert/Health Category", ParameterSetName = "Default")]
		[ValidateNotNullOrEmpty()]
		[ValidateSet('Appliance', 'DeviceBay', 'Enclosure', 'Fan', 'Firmware', 'Host', 'Instance', 'InterconnectBay', 'LogicalSwitch', 'Logs', 'ManagementProcessor', 'Memory', 'Network', 'Operational', 'Power', 'Processor', 'RemoteSupport', 'Storage', 'Thermal', 'Unknown')]
		[string]$HealthCategory = $null,

		[parameter(Mandatory = $false, HelpMessage = "Filter by User",Position=3, ParameterSetName = "Default")]
		[ValidateNotNullOrEmpty()]
		[String]$AssignedToUser = $null,

		[parameter(Mandatory = $false,  HelpMessage = "Alert state",Position=4, ParameterSetName = "Default")]
		[ValidateNotNullOrEmpty()]
		[String]$AlertState = $null,
		
		[parameter(Mandatory = $false)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}
    
	)

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_AlertResources = New-Object System.Collections.ArrayList

		if (-not $PSBoundParameters['resource']) { $Pipelineinput = $True }
        
	}
	
	Process 
	{

		If ($Pipelineinput -and $Resource -ne $null)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Resource provided via pipeline."

			$uri = $alertsUri + "?start=0&count=-1"

			#Generate Error, unsupported pipeline input
			if ($resource -is [String]) 
			{ 
					
				$PSCmdlet.ThrowTerminatingError($ErrorRecord)
				
			}

			elseif ($resource -is [PsCustomObject]) 
			{ 
					
				$uri += "&filter=resourceUri=`'$($resource.uri)`'" 
				
			}
            
			if ($severity) 
			{ 
					
				$uri += "&filter=severity='$severity'" 
				
			}
            
			if ($healthCategory) 
			{
					
					$uri += "&filter=healthCategory='$healthCategory'" 
				
			}
            
			if ($AssignedToUser) 
			{ 
					
				$uri += "&filter=assignedTOuter='$AssignedToUser'" 
				
			}
            
			if ($alertState) 
			{ 
					
				$alertState = $alertState.ToLower(); 

				$alertState = $alertState.substring(0,1).ToUpper()+$alertState.substring(1).tolower(); 

				$uri += "&filter=alertState=`'$alertState`'" 
				
			}

			Try
			{

				$_ResourceAlerts = Send-HPOVRequest $uri -Hostname $Resource.ApplianceConnection.Name

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}
        
			$_ResourceAlerts.members | % { 
					
				$_.PSObject.TypeNames.Insert(0,”HPOneView.Alert")

				[void]$_AlertResources.Add($_)
				
				
			}

		}

		#Process
		Else
		{

			ForEach ($_Connection in $ApplianceConnection)
			{

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_Connection.Name)' Appliance (of $($ApplianceConnection.Count))"

				$uri = $alertsUri

				if ($resource -is [String]) 
				{ 
					
					$_AppendUri += "&filter=resourceName='$resource'" 
				
				}

				elseif ($resource -is [PsCustomObject]) 
				{ 
					
					$_AppendUri += "&filter=resourceUri=`'$($resource.uri)`'" 
				
				}
            
				if ($PSBoundParameters['severity']) 
				{ 
					
					$_AppendUri += "&filter=severity='$severity'" 
				
				}
            
				if ($PSBoundParameters['healthCategory']) 
				{
					
					 $_AppendUri += "&filter=healthCategory='$healthCategory'" 
				
				}
            
				if ($PSBoundParameters['AssignedToUser']) 
				{ 
					
					$_AppendUri += "&filter=assignedToUser'$AssignedToUser'" 
				
				}
            
				if ($PSBoundParameters['alertState']) 
				{ 
					
					$alertState = $alertState.ToLower(); 

					$alertState = $alertState.substring(0,1).ToUpper()+$alertState.substring(1).tolower(); 

					$_AppendUri += "&filter=alertState=`'$alertState`'" 
				
				}

				if ($_AppendUri)
				{

					$uri += "?" + $_AppendUri.SubString(1)

				}

				Try
				{

					$_ResourceAlerts = Send-HPOVRequest $uri -Hostname $_Connection

				}

				Catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}
        
				$_ResourceAlerts.members | % { 
					
					$_.PSObject.TypeNames.Insert(0,”HPOneView.Alert")

					[void]$_AlertResources.Add($_)
				
				}

			}

		}

    }

    End 
	{

        Return $_AlertResources

    }

}

function Set-HPOVAlertAssignToUser 
{
    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding()]
    Param
	()

	Write-Warning 'This CMDLET is deprecated. Please use Set-HPOVAlert.'

}

function Set-HPOVAlert
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding(DefaultParameterSetName = 'Default')]
    Param
	(

        [parameter (Position = 0, Mandatory, ValueFromPipeline, ParameterSetName = 'Default')]
		[parameter (Position = 0, Mandatory, ValueFromPipeline, ParameterSetName = 'Cleared')]
		[parameter (Position = 0, Mandatory, ValueFromPipeline, ParameterSetName = 'Active')]
        [ValidateNotNullOrEmpty()]
		[alias('alertUri')]
        [Object]$Alert,

        [parameter (Position = 1, Mandatory = $false, ParameterSetName = 'Default')]
        [string]$AssignToUser,

        [parameter (Position = 2, Mandatory = $false, ParameterSetName = 'Default')]
        [ValidateNotNullOrEmpty()]
        [String]$Notes,

        [parameter (Mandatory = $true, ParameterSetName = 'Cleared')]
        [switch]$Cleared,

        [parameter (Mandatory = $true, ParameterSetName = 'Active')]
        [switch]$Active,

		[parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Default')]
		[parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Cleared')]
		[parameter(Mandatory, ValueFromPipelineByPropertyName, ParameterSetName = 'Active')]
		[Alias('Appliance')]
		[Object]$ApplianceConnection = $Null

	)

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		if (-not($PSBoundParameters['alert'])) 
		{ 
			
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Alert Object via pipeline"

			$Pipelineinput = $True 
		
		}

		else
		{

			if (-not($Alert -is [PSCustomObject]) -and $Alert.category -ne 'alerts')
			{

				$errorRecord = New-ErrorRecord InvalidOperationException InvalidAlertObject InvalidArgument 'Alert' -TargetType $Alert.GetType().Name -Message 'The Alert parameter value is not a PSCustomObject or contains a valid resource category.  Please check the value and try again.'
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

			Try 
			{
			
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}

		$_AlertResources = New-Object System.Collections.ArrayList

    }

    Process 
	{

		$_AlertUpdateObject = NewObject -UpdateAlert

		if (-not($PSBoundParameters['Notes']))
		{

			$_AlertUpdateObject.notes = 'Updated alert with: {0}' -f (($PSBoundParameters.Keys | ? { 'Cleared','Active','AssignToUser' -contains $_ } | % { "{0} ({1})" -f $_,$PSBoundParameters[$_] } )-Join ", ")

		}

		switch ($PSBoundParameters.keys)
		{

			'Cleared'
			{

				$_AlertUpdateObject.alertState = 'Cleared'

			}

			'Active'
			{

				$_AlertUpdateObject.alertState = 'Active'

			}

			'AssignToUser'
			{

				$_AlertUpdateObject.assignedToUser = $AssignToUser

			}

			'Notes'
			{
			
				$_AlertUpdateObject.notes = $Notes
			
			}

		}

		if (-not($PSboundParameters['Cleared']) -and -not($PSboundParameters['Active']))
		{

			$_AlertUpdateObject.alertState = $Alert.alertState

		}

		#Validate input object is correct
		if ($Alert.category -ne 'alerts')
		{

			$errorRecord = New-ErrorRecord InvalidOperationException InvalidAlertObject InvalidArgument 'Alert' -TargetType $Alert.GetType().Name -Message 'The Alert parameter value is not a PSCustomObject or contains a valid resource category.  Please check the value and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}
			
		if (-not($Alert.ApplianceConnection.Name) -and -not($ApplianceConnection))
		{

			$errorRecord = New-ErrorRecord InvalidOperationException InvalidAlertObject InvalidArgument 'Alert' -TargetType $Alert.GetType().Name -Message 'The Alert parameter value does not contain a valid ApplianceConnection property.  Please check the value and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		if ($Pipeline)
		{

			$ApplianceConnection = $Alert.ApplianceConnection.Name

		}
			
		Try
		{

			if ($Alert.eTag)
			{

				$_AlertUpdateObject.eTag = $Alert.eTag

			}

			$_resp = Send-HPOVRequest $Alert.uri PUT $_AlertUpdateObject -Hostname $ApplianceConnection.Name
		
			$_resp.PSObject.TypeNames.Insert(0,"HPOneView.Alert")

		}

		Catch
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}
        

		[void]$_AlertResources.Add($_resp)

	}

	End
	{        

        return $_AlertResources

    }

}

function Clear-HPOVAlert  
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdLetBinding()]
    Param
	()

	Write-Warning 'This CMDLET is deprecated. Please use Set-HPOVAlert.'

}
    
function Get-HPOVLicense 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml
    
    [CmdletBinding(DefaultParameterSetName = "Default")]
    param
	(

        [Parameter(Position = 0, Mandatory = $False, ParameterSetName = "Default", HelpMessage = "Please specify the type of license you wish to generate a report for. Accepted values are `"OneView`", `"OneViewNoiLO`", or `"all`".")]
        [ValidateSet("OneViewAdvanced", "OneView", "OneViewAdvancedNoiLO", "OneViewNoiLO","all")]
        [String]$Type,
        
        [Parameter(Position = 1, Mandatory = $False, ParameterSetName = "Default", HelpMessage = "Please specify the license state you wish to generate a report for. Accepted values are `"Unlicensed`" or `"Permanent`".")]
        [ValidateSet("Unlicensed", "Permanent",$null)]
        [String]$State,

		[Parameter(Mandatory = $false, ParameterSetName = "Default")]
		[Switch]$Report,
		
		[parameter(Mandatory = $false)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}
    
    )

    begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_LicenseResources = New-Object System.Collections.ArrayList

		[string]$filter = $null
		
        If ($PSboundParameters['Type'])
		{

            write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] License Type: $Type"

            switch ($Type)
			{

                #User wants the HP OneView License report
                {$_ -match "OneView","OneViewAdvanced"} 
				{

                    $filter += "?filter=`"product='HP OneView Advanced'`""

                }

                #User wants the HP OneView without iLO License Report
                {$_ -match "OneViewNoiLO","OneViewAdvancedNoiLO"} 
				{

                    $filter += "?filter=`"product='HP OneView Advanced w/o iLO'`""

                }

            }

        }

        If ($PSboundParameters['State'])
		{

            write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] License $State State"

			#Check to see if the license type/product was specified, as we would have an existing filter value
            If ($filter)
			{

				$filter += "&filter=`"licenseType='$State'`""

			}
			ElseIf (-not($filter))
			{

				$filter += "?filter=`"licenseType='$State'`""

			}

        }

		ElseIf (-not($PSboundParameters['State']))
		{

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] No license state provided ($State)"

        }
  
        If ($PSboundParameters['Report'])
		{
			
			write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Generating detailed report"

			$disSummary = $null
			
        }

        Elseif (-not($PSboundParameters['Report']))
		{

            Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Generating Summary Report"
			
			#Check to see if the license type/product was specified, as we would have an existing filter value
            If ($filter)
			{

				$disSummary = "&view=summary"

			}
			ElseIf (-not($filter))
			{

				$disSummary = "?view=summary"

			}

        }
    
    }

    process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_Connection.Name)' Appliance (of $($ApplianceConnection.Count))"
		
			#Display verbose data of what will be sent to Send-HPOVRequest
			write-verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] $(($script:licensesUri + $filter + $disSummary) + " GET")"
			
			Try
			{

				#Send the request	
				$ret = Send-HPOVRequest ($script:licensesUri + $filter + $disSummary) GET -Hostname $_Connection

			}
			
			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$ret.members | ForEach { 

				$_.PSObject.TypeNames.Insert(0,”HPOneView.Appliance.License")
					
				if ($_.nodes) 
				{ 
						
					$_.nodes | % { $_.PSObject.TypeNames.Insert(0,”HPOneView.Appliance.License.Node") } 
					
				} 

				[void]$_LicenseResources.Add($_)
				
			}

		}

	}

	end
	{

		if ($PSboundParameters['Report'])
		{

			ForEach ($_LicenseObject in $_LicenseResources)
			{

				$a = @{Expression={$_.Product};Label="License Name"},
					 @{Expression={$_.AvailableCapacity};Label="Available"},
					 @{Expression={$_.TotalCapacity};Label="Total"},
					 @{Expression={$licenseGroup.nodes.count};Label="Associated Nodes"}
			 
				$now = (Get-Date).ToShortDateString()

				ForEach ($licenseGroup in $_LicenseObject)
				{

				    $licenseGroup | Format-Table $a -autosize -wrap
				
				    $b = @{Expression={$_.nodeName};Label="Device"},
				         @{Expression={$licenseGroup.LicenseType};Label="License Type"},
				         @{Expression={
				        
							if ($licenseGroup.LicenseType -eq "Unlicensed") 
							{
								 
								$appliedDate = (Get-Date($_.appliedDate)).ToShortDateString()
								
								$daysToAdd = 60 
									
							}

							elseif ($licenseGroup.LicenseType -eq "Evaluation") 
							{  
								
								$appliedDate = (Get-Date($licenseGroup.created)).ToShortDateString()
								
								$daysToAdd = 365 

							}

							$expire = (Get-Date($appliedDate)).AddDays($daysToAdd)

							$warnDate = new-timespan -start $now -end $expire

							if ($warnDate.Days -eq 0 -or $warnDate.Days -lt 0) 
							 {

								$appliedDate = $appliedDate + " (EXPIRED)"

							}
							  
							elseif($warnDate.Days -le 30) 
							{
								
								$appliedDate = $appliedDate + " (Expires in $($warnDate.days) days)"

							}
							
				            $appliedDate

				        };Label="Applied Date"}

				    $licenseGroup.nodes | sort-object -property nodeName | Format-Table $b -autosize -wrap | Out-String | ForEach-Object {

				        $_.Split("`n") | ForEach-Object {

				            if($_ -match "EXPIRED") { Write-Host -ForegroundColor Red $_ }
				            elseif($_ -match "Expires in"){ Write-Host -ForegroundColor Yellow $_ }
				            else{ Write-Host $_ }
				       
				        }

				    } 
 
				}

			}

		}

        else 
		{

            Return $_LicenseResources

        }

    }

}

function New-HPOVLicense 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml
    
    [CmdletBinding(DefaultParameterSetName = "licenseKey")]
    param
	(

        [Parameter(Position=0, Mandatory = $true, ValueFromPipeline, ParameterSetName = "licenseKey",HelpMessage = "Please specify the license you wish to install")]
        [ValidateNotNullOrEmpty()]
        [String]$LicenseKey,
        
        [Parameter(Position=0, Mandatory = $true, ParameterSetName = "InputFile",HelpMessage = "Please specify the license file")]
        [ValidateScript({Test-Path $_})]
        [String]$File,
		
		[parameter(Mandatory = $false)]
		[Alias('Appliance')]
		[Object]$ApplianceConnection = $null

    )

	Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if ($ApplianceConnection.Count -eq 0)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoAuthSessionFound InvalidArgument 'ApplianceConnection' -Message 'No ApplianceConnections were found.  Please use Connect-HPOVMgmt to establish an appliance connection.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		if ($ApplianceConnection.Count -gt 1)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException MustSpecifyUniqueConnection InvalidArgument 'ApplianceConnection' -Message 'Multiple Appliance Connections were specified.  This cmdlet only supports a single appliance connection per request.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		Try 
		{
			
			$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

		}

		Catch [HPOneview.Appliance.AuthSessionException] 
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $ApplianceConnection -Message $_.Exception.Message -InnerException $_.Exception
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		Catch 
		{

			$PSCmdlet.ThrowTerminatingError($_)

		}

		$_LicenseResponseCollection = New-Object System.Collections.ArrayList

		if ($file)
		{

			[Array]$LicenseKey = Get-Content $file

		}

	}

    Process 
	{

		#Loop through all keys, and add one by one.
		foreach ($_lk in $LicenseKey)
		{

			"[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing LicenseKey: {0}" -f $_lk | write-verbose 

			$_key     = NewObject -LicenseKey
			$_key.key = @"
$_lk
"@
			Try 
			{
	    	
				$_ret = Send-HPOVRequest $licensesUri POST $_key -Hostname $ApplianceConnection

			}

			Catch 
			{

				Switch ($_.FullyQualifiedErrorId)
				{

					"LICENSE_ALREADY_EXISTS"
					{

						$errorRecord = New-ErrorRecord HPOneview.Appliance.LicenseKeyException LicenseKeyAlreadyExists ResourceExists 'LicenseKey' -Message "The license key provided already exists on the appliance.  Please correct the value, and try again."

					}

					"ADD_LICENSE_FAILED"
					{

						$errorRecord = New-ErrorRecord HPOneview.Appliance.LicenseKeyException InstallLicenseFailure InvalidResult 'LicenseKey' -Message $_.Message						

					}

					default
					{

						$errorRecord = New-ErrorRecord HPOneview.Appliance.LicenseKeyException $_.FullyQualifiedErrorId InvalidResult 'LicenseKey' -Message $_.Message	

					}

				}

				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			[void]$_LicenseResponseCollection.Add($_ret)
			
		}

	}

	End 
	{

		Return $_LicenseResponseCollection
	
	}

}

function Remove-HPOVLicense 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml
    
    [CmdletBinding(DefaultParameterSetName = "PipelineDefault", SupportsShouldProcess = $True, ConfirmImpact = 'High')]
    param
	(

		[parameter(Mandatory, ValueFromPipeline, ParameterSetName = "PipelineDefault", HelpMessage = "Specify the license to remove.", Position = 0)]
		[parameter(Mandatory, ParameterSetName = "ApplianceRequired", position = 0)]
        [ValidateNotNullOrEmpty()]
        [Alias('uri', 'name', 'license')]
        [System.Object]$Resource = $null,
    
		[parameter(Mandatory = $true, ValueFromPipelineByPropertyName, ParameterSetName = "ApplianceRequired", position = 1)]
		[parameter(Mandatory = $true, ValueFromPipelineByPropertyName, ParameterSetName = "PipelineDefault", position = 1)]
		[Alias('Appliance')]
		[Object]$ApplianceConnection = $Null

    )

    begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_.Exception)

			}

			$c++

		}

		if (-not($PSBoundParameters['Resource'])) { $PipelineInput = $True }

		$_ResponseCollection = New-Object System.Collections.ArrayList
		$_LicenseCollection = New-Object System.Collections.ArrayList

    }

    Process 
	{

		if ($PipelineInput -and $Resource -ne $null) 
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing Pipeline input"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] License Object provided: $($Resource | FL * | Out-String)"

			if ('licenses' -contains $Resource.category)
			{

				if (-not($Resource.ApplianceConnection))
				{

					$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument "License:$($Resource.uri)" -TargetType PSObject -Message "The License resource provided is missing the source ApplianceConnection property.  Please check the object provided and try again."
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				[void]$_LicenseCollection.Add($Resource)

			}

			else
			{

				$errorRecord = New-ErrorRecord InvalidOperationException InvalidArgumentValue InvalidArgument "License:$($Resource.uri)" -TargetType PSObject -Message "The License resource is not an expected category type [$($License.category)].  Allowed resource category types are 'licenses'.  Please check the object provided and try again."
                $PSCmdlet.ThrowTerminatingError($errorRecord)

			}

		}

		else 
		{

			foreach ($license in $Resource) 
			{

				switch ($license.GetType().name) 
				{

					"String" 
					{ 
                
						if ([System.Uri]::IsWellFormedUriString($license,'Relative') -and $license.StartsWith($script:licensesUri)) 
						{
                    
							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] License URI provided: $license"
							
							# // NEED APPLIANCE NAME HERE with If Condition
							try
							{

								$license = Send-HPOVRequest $license -ApplianceConnection $ApplianceConnection

							}
							
							catch
							{

								$PSCmdlet.ThrowTerminatingError($_)

							}
                    
						}

						elseif ($license.StartsWith("/rest/")) 
						{
                     
							#Invalid URI, so error
							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Invalid License URI provided: $license"

							$errorRecord = New-ErrorRecord ArgumentException InvalidLicenseURI InvalidArgument 'Remove-HPOVLicense' -Message "The provided URI value for the -License parameter '$license' is invalid.  The License URI must begin with /rest/licenses.  Please check the value and try again."
							$PSCmdlet.ThrowTerminatingError($errorRecord)

						}

						else 
						{

							#Invalid parameter, so error
							Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Invalid License URI provided: $license"

							$errorRecord = New-ErrorRecord ArgumentException InvalidLicenseValue InvalidArgument 'Remove-HPOVLicense' -Message "The provided value for the -License parameter '$license' is invalid.  Please check the value and try again."
							$PSCmdlet.ThrowTerminatingError($errorRecord)
                    
						}
                
					}

					"PSCustomObject" 
					{ 
                
						#Validate the object
						if (-not($license.category -eq "licenses"))
						{

							$errorRecord = New-ErrorRecord ArgumentException InvalidLicenseCategory InvalidArgument 'Remove-HPOVLicense' -Message "Invalid -License parameter value.  Expected Resource Category 'licenses', received '$($license.category)'."
							$PSCmdlet.ThrowTerminatingError($errorRecord)

						}              
                
					}

				}

				[void]$_LicenseCollection.Add($license)
			}

        }

    }

    End 
	{
		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing $($_LicenseCollection.count) License resources to remove."

		foreach ($license in $_LicenseCollection)
		{

			if ($pscmdlet.ShouldProcess($license.product,'remove license $($license.product) from appliance $($license.ApplianceConnection.Name)'))
			{    

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Removing License '$($license.product)' [$($license.productDescription)]."
				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] URI: '$($license.uri)'"

				try
				{

					# // NEED APPLIANCE NAME HERE with If Condition
					$_resp = Send-HPOVRequest $license.uri DELETE -Hostname $license.ApplianceConnection.Name

				}

				catch
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

			}

			elseif ($PSBoundParameters['whatif'].ispresent) 
			{ 
                           
				write-warning "-WhatIf was passed, would have proceeded with removing '$($license.product)'."
				$_resp = $null
            
			}
			else 
			{

				#If here, user chose "No", end processing
				write-host ""
				write-warning "Not removing license, $($license.product)."
				write-host ""
                    
				$_resp = $null

			}

			$_ResponseCollection.Add($_resp)

		}

		return $_ResponseCollection

    }

}

function Set-HPOVSMTPConfig 
{

	# .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding(DefaultParameterSetName = "Default")]
	param
	(
	
		[parameter(Position = 0, Mandatory = $true, ValueFromPipeline = $false, HelpMessage = "Sender E-Mail address to assign to the appliance.", ParameterSetName = "Disabled")]
        [parameter(Position = 0, Mandatory = $true, ValueFromPipeline = $false, HelpMessage = "Sender E-Mail address to assign to the appliance.", ParameterSetName = "Default")]
		[ValidateNotNullOrEmpty()]
        [validatescript({if ($_ -as [Net.Mail.MailAddress]) {$true} else { Throw "The parameter value is not an email address. Please correct the value and try again." }})]
		[System.String]$SenderEmailAddress,

		[parameter(Position = 0, Mandatory = $false, ValueFromPipeline = $True, HelpMessage = "Provide SMTP Server name if ", ParameterSetName = "Disabled")]
        [parameter(Position = 0, Mandatory = $false, ValueFromPipeline = $True, HelpMessage = "Help Message", ParameterSetName = "Default")]
        [Alias('server')]		
        [ValidateNotNullOrEmpty()]
		[System.String]$SmtpServer,

        [parameter(Position = 1, Mandatory = $false, ValueFromPipeline = $false, HelpMessage = "Help Message", ParameterSetName = "Disabled")]
		[parameter(Position = 1, Mandatory = $false, ValueFromPipeline = $false, HelpMessage = "Help Message", ParameterSetName = "Default")]
		[Alias('port')]
		[ValidateNotNull()]
		[System.Int32]$SmtpPort = 25,

		[parameter(Position = 2, Mandatory = $false, ValueFromPipeline = $True, HelpMessage = "Help Message", ParameterSetName = "Disabled")]
        [parameter(Position = 2, Mandatory = $false, ValueFromPipeline = $True, HelpMessage = "Help Message", ParameterSetName = "Default")]
		[ValidateNotNullOrEmpty()]
		[System.String]$Password,

		[parameter(Mandatory = $false, HelpMessage = "Help Message", ParameterSetName = "Disabled")]
		[Switch]$alertEmailDisabled,

		[parameter(Mandatory = $false, HelpMessage = "Help Message", ParameterSetName = "Default")]
		[Switch]$alertEmailEnabled,
    
		[parameter(Mandatory = $False, ValueFromPipelineByPropertyName, ParameterSetName = "ApplianceRequired", position = 1)]
		[Alias('Appliance')]
		[Object]$ApplianceConnection = ${Global:ConnectedSessions}
		
	)
	
	Begin 
	{
	
		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_.Exception)

			}

			$c++

		}

		if (-not($PSBoundParameters['Resource'])) { $PipelineInput = $True }

		$_ResponseCollection = New-Object System.Collections.ArrayList

        $smtpConfig = NewObject -SmtpConfig
		
		[PSCustomObject]@{
        
            type               = "EmailNotification";
            senderEmailAddress = if ($alertEmailEnabled.IsPresent -and -not $senderEmailAddress) { Throw "error" }
                                 else { $senderEmailAddress };
            password           = $password;
            smtpServer         = $SmtpServer;
            smtpPort           = $Port;
            alertEmailDisabled = if ($alertEmailDisabled.IsPresent) { $True }
                                 elseif ($alertEmailEnabled.IsPresent) { $False }
                                 else { $False }
        
        }

	}
	
	Process 
	{

		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_Connection.Name)' Appliance (of $($ApplianceConnection.Count))"

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing SMTP Configuration"
			
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] SMTP Configuration: $($smtpConfig | fl * -force | out-string)"

			Try
			{

				$_resp = Send-HPOVRequest $smtpNotificationConfig POST $smtpConfig -Hostname $_Connection

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			[void]$_ResponseCollection.Add($_resp)

		}

	}
	
	
	End 
	{

		Return $RespCollection
	
	}

}

function Get-HPOVSMTPConfig 
{

	# .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding()]
	param
	(	
	
		[parameter(Mandatory = $false)]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}
    
	)

    Begin 
	{

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"
		
		$c = 0
		
		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
			
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_SMTPConfigCollection = New-Object System.Collections.ArrayList

	}
	
	Process 
	{


		ForEach ($_Connection in $ApplianceConnection)
		{

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing '$($_Connection.Name)' Appliance (of $($ApplianceConnection.Count))"

			Try
			{

				$currentSmtpConfig = Send-HPOVRequest $smtpNotificationConfig -Hostname $_Connection

			}
	        
			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}
	
	        $currentSmtpConfig | % { 
				
				$_.PSObject.TypeNames.Insert(0,”HPOneView.Appliance.SmtpConfiguration") 
			
				[void]$_SMTPConfigCollection.Add($_)
			
			}	

		}

	}
	
	End 
	{

		Return $_SMTPConfigCollection
	
	}

}

function Add-HPOVSmtpAlertEmailFilter 
{

	# .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding(DefaultParameterSetName = "Default")]
	param
	(
	
		[parameter(Position = 0, Mandatory = $true, ValueFromPipeline = $false, HelpMessage = "Help Message", ParameterSetName = "Default")]
		[alias('query')]
		[ValidateNotNullOrEmpty()]
		[System.String]$filter,

        [parameter(Position = 0, Mandatory = $true, ValueFromPipeline = $True, HelpMessage = "Sender E-Mail address to assign to the appliance.", ParameterSetName = "Default")]
		[Alias('recipients')]
        [ValidateNotNullOrEmpty()]
        [validatescript({$_ | foreach { if ($_ -as [Net.Mail.MailAddress]) {$true} else { Throw "The parameter value '$_' is not an email address. Please correct the value and try again." }}})]
		[System.Array]$Emails,

		[parameter(Mandatory = $false, ParameterSetName = "Default")]
		[Alias('Appliance')]
		[Object]$ApplianceConnection = ${Global:ConnectedSessions}

    )

    Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		if ($ApplianceConnection -is [Array])
		{

			$_tmpApplianceConnection = $ApplianceConnection.Clone()

			ForEach ($_Connection in $_tmpApplianceConnection) 
			{

				Try 
				{
	
					$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

				}

				Catch [HPOneview.Appliance.AuthSessionException] 
				{

					$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				Catch 
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

				$c++

			}

		}

		$colStatus = New-Object System.Collections.ArrayList

    }
     
    Process 
	{

		ForEach ($_appliance in $ApplianceConnection)
		{

		    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting current SMTP Configuration from '$($_appliance.Name)'."

		    $_smtpFilterConfiguration = Send-HPOVRequest $smtpNotificationConfig -Hostname $_appliance.Name
		
		    #Create new alert filter object
		    $_alertFilter = NewObject -AlertFilter
		
			$_alertFilter.filter          = "($filter)"
			$_alertFilter.displayFilter   = $filter
			$_alertFilter.userQueryFilter = $filter
			$_alertFilter.emails          = $Emails

			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Processing SMTP Alert Configuration for '$($_appliance.Name)'."
			
			Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] SMTP Appliance Filter Configuration: $($_alertFilter | fl * -force | out-string)"

			[void]$smtpFilterConfiguration.alertEmailFilters.Add($alertFilter)

			Try
			{

				$resp = Send-HPOVRequest $smtpNotificationConfig POST $smtpFilterConfiguration -Hostname $_appliance.Name

			}

			Catch
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			[void]$colStatus.Add($resp)
			
		}

	}
	
	End 
	{
	
        Return $colStatus
	
	}

}

function Get-HPOVLoginMessage
{

	# .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding(DefaultParameterSetName = "Default")]
	param
	(

		[parameter(Mandatory = $false, ParameterSetName = "Default")]
		[Alias('Appliance')]
		[Array]$ApplianceConnection = ${Global:ConnectedSessions}

    )

	Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		ForEach ($_Connection in $ApplianceConnection) 
		{

			Try 
			{
	
				$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

			$c++

		}

		$_ColStatus = New-Object System.Collections.ArrayList

    }
     
    Process 
	{

		ForEach ($_appliance in $ApplianceConnection)
		{

		    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting current Login Message Configuration from '$($_appliance.Name)'."

			Try
			{

				$_LoginDomainGlobalSettings = Send-HPOVRequest $authnSettingsUri -Hostname $_appliance.Name

				$_LoginMessageObject = New-Object HPOneView.Appliance.LoginMessage

				$_LoginMessageObject.Message                          = $_LoginDomainGlobalSettings.loginMessage.message
				$_LoginMessageObject.Acknowledgment                   = $_LoginDomainGlobalSettings.loginMessage.acknowledgment
				$_LoginMessageObject.ApplianceConnection.ConnectionId = $_LoginDomainGlobalSettings.ApplianceConnection.ConnectionId
				$_LoginMessageObject.ApplianceConnection.Name         = $_LoginDomainGlobalSettings.ApplianceConnection.Name

				[void]$_ColStatus.Add($_LoginMessageObject)

			}

			Catch
			{

				$_ColStatus

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}

	}
	
	End 
	{
	
        Return $_ColStatus
	
	}

}

function Set-HPOVLoginMessage
{

	# .ExternalHelp HPOneView.200.psm1-help.xml

	[CmdletBinding(DefaultParameterSetName = "Default")]
	param
	(
	
		[parameter(Position = 0, Mandatory, ValueFromPipeline = $false, ParameterSetName = "Default")]
		[ValidateNotNullOrEmpty()]
		[String]$Message,

		[parameter(Position = 1, Mandatory = $False, ValueFromPipeline = $false, ParameterSetName = "Default")]
		[Bool]$Acknowledgment = $False,

		[parameter(Mandatory = $false, ParameterSetName = "Default")]
		[Alias('Appliance')]
		[Object]$ApplianceConnection = ${Global:ConnectedSessions}

    )

	Begin 
	{

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		$c = 0

		if ($ApplianceConnection -is [Array])
		{

			$_tmpApplianceConnection = $ApplianceConnection.Clone()

			ForEach ($_Connection in $_tmpApplianceConnection) 
			{

				Try 
				{
	
					$ApplianceConnection[$c] = Test-HPOVAuth $_Connection

				}

				Catch [HPOneview.Appliance.AuthSessionException] 
				{

					$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError $_Connection -Message $_.Exception.Message -InnerException $_.Exception
					$PSCmdlet.ThrowTerminatingError($errorRecord)

				}

				Catch 
				{

					$PSCmdlet.ThrowTerminatingError($_)

				}

				$c++

			}

		}

		$_ColStatus = New-Object System.Collections.ArrayList

    }
     
    Process 
	{

		ForEach ($_appliance in $ApplianceConnection)
		{

		    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Getting current Login Message Configuration from '$($_appliance.Name)'."

			Try
			{

				$_LoginDomainGlobalSettings = Send-HPOVRequest $authnSettingsUri -Hostname $_appliance.Name

				$_LoginDomainGlobalSettings.loginMessage.message        = $Message
				$_LoginDomainGlobalSettings.loginMessage.acknowledgment = [bool]$Acknowledgment

				Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Updating Login Message Configuration."

				$_NewLoginDomainGlobalSettings = Send-HPOVRequest $authnSettingsUri PUT $_LoginDomainGlobalSettings -Hostname $_appliance.Name

				$_LoginMessageObject = New-Object HPOneView.Appliance.LoginMessage

				$_LoginMessageObject.Message                          = $_NewLoginDomainGlobalSettings.loginMessage.message
				$_LoginMessageObject.Acknowledgment                   = $_NewLoginDomainGlobalSettings.loginMessage.acknowledgment
				$_LoginMessageObject.ApplianceConnection.ConnectionId = $_NewLoginDomainGlobalSettings.ApplianceConnection.ConnectionId
				$_LoginMessageObject.ApplianceConnection.Name         = $_NewLoginDomainGlobalSettings.ApplianceConnection.Name

				[void]$_ColStatus.Add($_LoginMessageObject)

			}

			Catch
			{
				
				$_ColStatus

				$PSCmdlet.ThrowTerminatingError($_)

			}
			
		}

	}
	
	End 
	{
	
        Return $_ColStatus
	
	}

}


#Function Get-HPOVRemoteSyslog {}
#Function Set-HPOVRemoteSyslog {}
########################################################
# HP Support CMDLETs

function Enable-HPOVDebug 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml
    
    [CmdletBinding(DefaultParameterSetName = "default")]
    param
	(

        [Parameter(Position=0, Mandatory = $true, ParameterSetName = "default",HelpMessage = "Provide the debug Scope.")]
        [ValidateNotNullOrEmpty()]
        [String]$Scope,

        [Parameter(Position = 1, Mandatory = $true, ParameterSetName = "default",HelpMessage = "Provide the component Logger Name.")]
        [ValidateNotNullOrEmpty()]
        [String]$LoggerName,

        [Parameter(Position = 2, Mandatory = $true, ParameterSetName = "default",HelpMessage = "Specify the verbose log level (ERROR, WARN, DEBUG or TRACE are allowed).")]
        [ValidateNotNullOrEmpty()]
        [ValidateSet('ERROR','WARN','DEBUG','TRACE', IgnoreCase = $False)]
        [String]$Level,

		[parameter(Mandatory = $true, ParameterSetName = "default", ValueFromPipelineByPropertyName)]
		[ValidateNotNullorEmpty()]
		[object]$ApplianceConnection = $null

    )

	Begin 
	{

		[console]::WriteLine()
        Write-Warning "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
        Write-Warning "!!! FOR HP SUPPORT USE ONLY. DO NOT USE UNLESS OTHERWISE INSTRUCTED TO BY HP SUPPORT !!!"
        Write-Warning "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
        [console]::WriteLine() 

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if (-not($ApplianceConnection -is [HPOneView.Appliance.Connection]) -and (-not($ApplianceConnection -is [System.String])))
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException InvalidApplianceConnectionDataType InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter is not type [HPOneView.Appliance.Connection] or [System.String].  Please correct this value and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif  ($ApplianceConnection.Count -gt 1)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException MultipleApplianceConnections InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter contains multiple Appliance Connections.  This CMDLET only supports 1 Appliance Connection in the ApplianceConnect parameter value.  Please correct this and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		else
		{

			Try 
			{
	
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError 'ApplianceConnection' -TargetType $ApplianceConnection.GetType().Name -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}

		$colStatus = New-Object System.Collections.ArrayList

    }

    Process 
	{

		$_debug = NewObject -ApplianceDebug

        $_debug.scope      = $Scope
        $_debug.loggerName = $LoggerName
        $_debug.level      = $Level

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Setting '$Level' at '$Scope`:$LoggerName'"

		Try
		{

			$resp = Send-HPOVRequest $script:applianceDebugLogSetting POST $_debug -Hostname $ApplianceConnection

		}

		Catch
		{

			"Unable to set '{0}:{1}' to '{2}' logging level. Error '{3}'" -f $Scope,$LoggerName,$Level,$_.Exception.Message

			$PSCmdlet.ThrowTerminatingError($_)

		}

		$_Status = "'{0}:{1}' successfully set to '{2}' on Appliance {3}" -f $Scope,$LoggerName,$Level,$ApplianceConnection.Name

		[void]$colStatus.Add($_Status)

    }

    End 
	{

		$colStatus

		Write-Warning "Remember to set '$Scope`:$LoggerName' back to 'INFO' with 'Disable-HPOVDebug $Scope $LoggerName'"

    }

}

function Disable-HPOVDebug 
{

    # .ExternalHelp HPOneView.200.psm1-help.xml

    [CmdletBinding(DefaultParameterSetName = "default")]
    param
	(

        [Parameter(Position=0, Mandatory = $true, ParameterSetName = "default",HelpMessage = "Provide the debug Scope.")]
        [ValidateNotNullOrEmpty()]
        [String]$Scope,

        [Parameter(Position = 1, Mandatory = $true, ParameterSetName = "default",HelpMessage = "Provide the component Logger Name.")]
        [ValidateNotNullOrEmpty()]
        [String]$LoggerName,

		[parameter(Mandatory = $true, ParameterSetName = "default", ValueFromPipelineByPropertyName)]
		[ValidateNotNullorEmpty()]
		[object]$ApplianceConnection = $null

    )

	Begin 
	{

		[console]::WriteLine()
        Write-Warning "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
        Write-Warning "!!! FOR HP SUPPORT USE ONLY. DO NOT USE UNLESS OTHERWISE INSTRUCTED TO BY HP SUPPORT !!!"
        Write-Warning "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
        [console]::WriteLine() 

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Bound PS Parameters: $($PSBoundParameters | out-string)"

		$Caller = (Get-PSCallStack)[1].Command

        Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Called from: $Caller"

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Verify auth"

		if (-not($ApplianceConnection -is [HPOneView.Appliance.Connection]) -and (-not($ApplianceConnection -is [System.String])))
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException InvalidApplianceConnectionDataType InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter is not type [HPOneView.Appliance.Connection] or [System.String].  Please correct this value and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		elseif  ($ApplianceConnection.Count -gt 1)
		{

			$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException MultipleApplianceConnections InvalidArgument 'ApplianceConnection' -Message 'The specified ApplianceConnection parameter contains multiple Appliance Connections.  This CMDLET only supports 1 Appliance Connection in the ApplianceConnect parameter value.  Please correct this and try again.'
			$PSCmdlet.ThrowTerminatingError($errorRecord)

		}

		else
		{

			Try 
			{
	
				$ApplianceConnection = Test-HPOVAuth $ApplianceConnection

			}

			Catch [HPOneview.Appliance.AuthSessionException] 
			{

				$errorRecord = New-ErrorRecord HPOneview.Appliance.AuthSessionException NoApplianceConnections AuthenticationError 'ApplianceConnection' -TargetType $ApplianceConnection.GetType().Name -Message $_.Exception.Message -InnerException $_.Exception
				$PSCmdlet.ThrowTerminatingError($errorRecord)

			}

			Catch 
			{

				$PSCmdlet.ThrowTerminatingError($_)

			}

		}

		$colStatus = New-Object System.Collections.ArrayList

    }

    Process 
	{

		$_debug = NewObject -ApplianceDebug

        $_debug.scope      = $Scope
        $_debug.loggerName = $LoggerName
        $_debug.level      = 'INFO'

		Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Setting '$Level' at '$Scope`:$LoggerName'"

		Try
		{

			$resp = Send-HPOVRequest $script:applianceDebugLogSetting POST $_debug -Hostname $ApplianceConnection

		}

		Catch
		{

			"Unable to set '{0}:{1}' to '{2}' logging level. Error '{3}'" -f $Scope,$LoggerName,$Level,$_.Exception.Message

			$PSCmdlet.ThrowTerminatingError($_)

		}

		$_Status = "'{0}:{1}' successfully set to '{2}' on Appliance {3}" -f $Scope,$LoggerName,$Level,$ApplianceConnection.Name

		[void]$colStatus.Add($_Status)

    }

    End 
	{

		$colStatus

		Write-Warning "Remember to set '$Scope`:$LoggerName' back to 'INFO' with 'Disable-HPOVDebug $Scope $LoggerName'"

    }

}

########################################################
# PowerShell Filters

filter ColorPattern( [string]$Pattern, [hashtable]$Color) 
{

	$split = $_ -split $Pattern

	$found = [regex]::Matches( $_, $Pattern, 'IgnoreCase' )

	for( $i = 0; $i -lt $split.Count; ++$i ) 
	{

		[ConsoleColor]$displayColor = $Color.keys | % { if ($_ -ieq $found[$i]) { $color[$_]} }
		Write-Host $split[$i] -NoNewline
		Write-Host $found[$i] -NoNewline -ForegroundColor $displayColor

	}

	[console]::WriteLine()

}

#######################################################
#  CMDLET Aliases
set-alias New-HPOVEnclosure Add-HPOVEnclosure
set-alias New-HPOVServer Add-HPOVServer 
set-alias Wait-HPOVTaskAccepted Wait-HPOVTaskStart
set-alias Get-HPOVServerHardwareTypes Get-HPOVServerHardwareType
set-alias New-HPOVStorageSystem Add-HPOVStorageSystem
set-alias New-HPOVSanManager Add-HPOVSanManager
set-alias New-HPOVStoragePool Add-HPOVStoragePool
set-alias Set-HPOVRole Set-HPOVUserRole
set-alias Get-HPOVSppFile Get-HPOVBaseline
set-alias Add-HPOVSppFile Add-HPOVBaseline
set-alias New-HPOVLdap New-HPOVLdapDirectory
set-alias Remove-HPOVLdap Remove-HPOVLdapDirectory
set-alias Get-HPOVProfile Get-HPOVServerProfile
set-alias New-HPOVProfile New-HPOVServerProfile
set-alias Get-HPOVProfileAssign New-HPOVServerProfileAssign
set-alias Copy-HPOVProfile Copy-HPOVServerProfile
set-alias Remove-HPOVProfile Remove-HPOVServerProfile 
set-alias Get-HPOVProfileConnectionList Get-HPOVServerProfileConnectionList
set-alias New-HPOVProfileConnection New-HPOVServerProfileConnection
set-alias New-HPOVProfileAttachVolume New-HPOVServerProfileAttachVolume
set-alias sr Send-HPOVRequest

#######################################################
#  Export the public functions from this module
#  Generic suport functions:
Export-ModuleMember -Function Send-HPOVRequest -Alias sr
Export-ModuleMember -Function Connect-HPOVMgmt
Export-ModuleMember -Function Disconnect-HPOVMgmt
Export-ModuleMember -Function Ping-HPOVAddress
Export-ModuleMember -Function New-HPOVResource
Export-ModuleMember -Function Set-HPOVResource
Export-ModuleMember -Function Remove-HPOVResource
Export-ModuleMember -Function Wait-HPOVApplianceStart
Export-ModuleMember -Function Enable-HPOVDebug
Export-ModuleMember -Function Disable-HPOVDebug
Export-ModuleMember -Function Get-HPOVRemoteSyslog
Export-ModuleMember -Function Set-HPOVRemoteSyslog
Export-ModuleMember -Function Enable-HPOVMSDSC
Export-ModuleMember -Function Disable-HPOVMSDSC

#Appliance Configuration:
Export-ModuleMember -Function Get-HPOVApplianceCertificateStatus
Export-ModuleMember -Function Get-HPOVApplianceDateTime
Export-ModuleMember -Function New-HPOVApplianceSelfSignedCertificate
Export-ModuleMember -Function New-HPOVApplianceCsr
Export-ModuleMember -Function Install-HPOVApplianceCertificate
Export-ModuleMember -Function Get-HPOVVersion
Export-ModuleMember -Function Get-HPOVHealthStatus
Export-ModuleMember -Function Get-HPOVXApiVersion
Export-ModuleMember -Function Get-HPOVEulaStatus
Export-ModuleMember -Function Set-HPOVEulaStatus
Export-ModuleMember -Function Get-HPOVApplianceNetworkConfig
Export-ModuleMember -Function Set-HPOVApplianceNetworkConfig
Export-ModuleMember -Function Get-HPOVSnmpReadCommunity 
Export-ModuleMember -Function Set-HPOVSnmpReadCommunity 
Export-ModuleMember -Function Get-HPOVApplianceGlobalSetting
Export-ModuleMember -Function Set-HPOVApplianceGlobalSetting
Export-ModuleMember -Function Get-HPOVBaseline -Alias Get-HPOVSppFile
Export-ModuleMember -Function Add-HPOVBaseline -Alias Add-HPOVSppFile
Export-ModuleMember -Function New-HPOVCustomBaseline
Export-ModuleMember -Function Restore-HPOVCustomBaseline
Export-ModuleMember -Function Remove-HPOVBaseline
Export-ModuleMember -Function New-HPOVSupportDump
Export-ModuleMember -Function New-HPOVBackup
Export-ModuleMember -Function New-HPOVRestore
Export-ModuleMember -Function Get-HPOVScmbCertificates
Export-ModuleMember -Function Install-HPOVUpdate
Export-ModuleMember -Function Get-HPOVPendingUpdate
Export-ModuleMember -Function Remove-HPOVPendingUpdate
#Export-ModuleMember -Function Show-HPOVSSLCertificate // TODO
Export-ModuleMember -Function Import-HPOVSSLCertificate
Export-ModuleMember -Function Restart-HPOVAppliance
Export-ModuleMember -Function Stop-HPOVAppliance

#Server hardware and enclosures:
Export-ModuleMember -Function Get-HPOVServer
Export-ModuleMember -Function Add-HPOVServer -alias New-HPOVServer
Export-ModuleMember -Function Set-HPOVServerPower
Export-ModuleMember -Function Remove-HPOVServer
Export-ModuleMember -Function Update-HPOVServer
Export-ModuleMember -Function Get-HPOVEnclosure
Export-ModuleMember -Function Update-HPOVEnclosure
Export-ModuleMember -Function Get-HPOVLogicalEnclosure 
Export-ModuleMember -Function Update-HPOVLogicalEnclosure 
Export-ModuleMember -Function Add-HPOVEnclosure -Alias New-HPOVEnclosure
Export-ModuleMember -Function Get-HPOVLogicalEnclosure
Export-ModuleMember -Function Remove-HPOVEnclosure
Export-ModuleMember -Function Get-HPOVEnclosureGroup
Export-ModuleMember -Function New-HPOVEnclosureGroup
Export-ModuleMember -Function Remove-HPOVEnclosureGroup
Export-ModuleMember -Function Get-HPOVServerHardwareType -Alias Get-HPOVServerHardwareTypes
Export-ModuleMember -Function Show-HPOVFirmwareReport
Export-ModuleMember -Function Invoke-HPOVVcmMigration
Export-ModuleMember -Function Get-HPOVIloSso

#Storage Systems
Export-ModuleMember -Function Get-HPOVStorageSystem
Export-ModuleMember -Function Update-HPOVStorageSystem
Export-ModuleMember -Function Add-HPOVStorageSystem -Alias New-HPOVStorageSystem
Export-ModuleMember -Function Remove-HPOVStorageSystem
Export-ModuleMember -Function Get-HPOVStoragePool
Export-ModuleMember -Function Add-HPOVStoragePool -Alias New-HPOVStoragePool
Export-ModuleMember -Function Remove-HPOVStoragePool
Export-ModuleMember -Function Get-HPOVStorageVolumeTemplate
Export-ModuleMember -Function New-HPOVStorageVolumeTemplate
Export-ModuleMember -Function Remove-HPOVStorageVolumeTemplate
Export-ModuleMember -Function Get-HPOVStorageVolumeTemplatePolicy
Export-ModuleMember -Function Set-HPOVStorageVolumeTemplatePolicy
Export-ModuleMember -Function Get-HPOVStorageVolume
Export-ModuleMember -Function New-HPOVStorageVolume
Export-ModuleMember -Function Add-HPOVStorageVolume
Export-ModuleMember -Function Set-HPOVStorageVolume
Export-ModuleMember -Function Remove-HPOVStorageVolume
Export-ModuleMember -Function Get-HPOVStorageVolumeSnapshot
Export-ModuleMember -Function New-HPOVStorageVolumeSnapShot
Export-ModuleMember -Function Remove-HPOVStorageVolumeSnapShot
Export-ModuleMember -Function ConvertTo-HPOVStorageVolume
Export-ModuleMember -Function Get-HPOVSanManager
Export-ModuleMember -Function Add-HPOVSanManager -alias New-HPOVSanManager
Export-ModuleMember -Function Set-HPOVSanManager
Export-ModuleMember -Function Update-HPOVSanManager
Export-ModuleMember -Function Remove-HPOVSanManager
Export-ModuleMember -Function Get-HPOVManagedSan
Export-ModuleMember -Function Set-HPOVManagedSan

#Unmanaged Devices
Export-ModuleMember -Function Get-HPOVUnmanagedDevice
Export-ModuleMember -Function New-HPOVUnmanagedDevice 
Export-ModuleMember -Function Remove-HPOVUnmanagedDevice 

#Power Devices (iPDUs):
Export-ModuleMember -Function Get-HPOVPowerDevice
Export-ModuleMember -Function Add-HPOVPowerDevice 
Export-ModuleMember -Function Remove-HPOVPowerDevice
Export-ModuleMember -Function Get-HPOVPowerPotentialDeviceConnection
        
#Networking and Connections:
Export-ModuleMember -Function New-HPOVNetwork
Export-ModuleMember -Function Get-HPOVNetwork
Export-ModuleMember -Function Set-HPOVNetwork
Export-ModuleMember -Function Remove-HPOVNetwork
Export-ModuleMember -Function New-HPOVNetworkSet
Export-ModuleMember -Function Get-HPOVNetworkSet
Export-ModuleMember -Function Set-HPOVNetworkSet
Export-ModuleMember -Function Remove-HPOVNetworkSet
Export-ModuleMember -Function Get-HPOVInterconnect
Export-ModuleMember -Function Get-HPOVInterconnectType
Export-ModuleMember -Function Get-HPOVLogicalInterconnect
Export-ModuleMember -Function Update-HPOVLogicalInterconnect
Export-ModuleMember -Function Install-HPOVLogicalInterconnectFirmware
Export-ModuleMember -Function Show-HPOVLogicalInterconnectMacTable
Export-ModuleMember -Function Show-HPOVPortStatistics
Export-ModuleMember -Function Get-HPOVLogicalInterconnectGroup
Export-ModuleMember -Function New-HPOVLogicalInterconnectGroup
Export-ModuleMember -Function Remove-HPOVLogicalInterconnectGroup
Export-ModuleMember -Function New-HPOVQosConfig
Export-ModuleMember -Function New-HPOVQosTrafficClass
Export-ModuleMember -Function Get-HPOVUplinkSet
Export-ModuleMember -Function New-HPOVUplinkSet
Export-ModuleMember -Function Get-HPOVAddressPool
Export-ModuleMember -Function Get-HPOVAddressPoolRange
Export-ModuleMember -Function New-HPOVAddressRange
Export-ModuleMember -Function New-HPOVSnmpTrapDestination
Export-ModuleMember -Function New-HPOVSnmpConfiguration
        
#Server Profiles:
Export-ModuleMember -Function Get-HPOVServerProfile -Alias Get-HPOVProfile
Export-ModuleMember -Function New-HPOVServerProfile -Alias New-HPOVProfile
Export-ModuleMember -Function New-HPOVServerProfileAssign -Alias Get-HPOVProfileAssign
Export-ModuleMember -Function Copy-HPOVServerProfile -Alias Copy-HPOVProfile
Export-ModuleMember -Function Remove-HPOVServerProfile -Alias Remove-HPOVProfile
Export-ModuleMember -Function Update-HPOVServerProfile
Export-ModuleMember -Function Get-HPOVServerProfileConnectionList -Alias Get-HPOVProfileConnectionList
Export-ModuleMember -Function Get-HPOVAvailableServerConnections
Export-ModuleMember -Function New-HPOVServerProfileConnection -Alias New-HPOVProfileConnection
Export-ModuleMember -Function New-HPOVServerProfileAttachVolume -Alias New-HPOVProfileAttachVolume
Export-ModuleMember -Function New-HPOVServerProfileTemplate 
Export-ModuleMember -Function Get-HPOVServerProfileTemplate
Export-ModuleMember -Function Join-HPOVServerProfileToTemplate
Export-ModuleMember -Function ConvertTo-HPOVServerProfileTemplate
Export-ModuleMember -Function New-HPOVServerProfileLogicalDisk 
    
#Index:
Export-ModuleMember -Function Search-HPOVIndex
Export-ModuleMember -Function Search-HPOVAssociations

#Tasks:
Export-ModuleMember -Function Get-HPOVTask
Export-ModuleMember -Function Wait-HPOVTaskStart -alias Wait-HPOVTaskAccepted
Export-ModuleMember -Function Wait-HPOVTaskComplete

#Security:
Export-ModuleMember -Function Get-HPOVUser
Export-ModuleMember -Function New-HPOVUser
Export-ModuleMember -Function Set-HPOVUser
Export-ModuleMember -Function Set-HPOVUserPassword
Export-ModuleMember -Function Remove-HPOVUser
Export-ModuleMember -Function Show-HPOVUserSession
Export-ModuleMember -Function Get-HPOVRole
Export-ModuleMember -Function Set-HPOVUserRole -alias Set-HPOVRole
Export-ModuleMember -Function Set-HPOVInitialPassword
Export-ModuleMember -Function Get-HPOVLdap
Export-ModuleMember -Function Get-HPOVLdapDirectory
Export-ModuleMember -Function New-HPOVLdapDirectory -Alias New-HPOVLdap
Export-ModuleMember -Function Set-HPOVLdapDefaultDirectory 
Export-ModuleMember -Function Enable-HPOVLdapLocalLogin
Export-ModuleMember -Function Disable-HPOVLdapLocalLogin
Export-ModuleMember -Function New-HPOVLdapServer
Export-ModuleMember -Function Set-HPOVLdapGroupRole
Export-ModuleMember -Function Remove-HPOVLdapDirectory -alias Remove-HPOVLdap
#Export-ModuleMember -Function Show-HPOVLdapGroups // TODO
Export-ModuleMember -Function Get-HPOVLdapGroup
Export-ModuleMember -Function New-HPOVLdapGroup
Export-ModuleMember -Function Set-HPOVLdapGroup
Export-ModuleMember -Function Remove-HPOVLdapGroup
Export-ModuleMember -Function Get-HPOVAuditLog
Export-ModuleMember -Function Get-HPOVLoginMessage
Export-ModuleMember -Function Set-HPOVLoginMessage

#Alerts:
Export-ModuleMember -Function Get-HPOVAlert
Export-ModuleMember -Function Set-HPOVAlert
Export-ModuleMember -Function Set-HPOVAlertAssignTOuter
Export-ModuleMember -Function Clear-HPOVAlert
Export-ModuleMember -Function Set-HPOVSmtpConfig
Export-ModuleMember -Function Add-HPOVSmtpAlertEmailFilter

#Licenses
Export-ModuleMember -Function Get-HPOVLicense
Export-ModuleMember -Function New-HPOVLicense
Export-ModuleMember -Function Remove-HPOVLicense

#######################################################
#  Import-Module Processing
#
#Create HPOneView HKCU key
If (-not(Test-Path "HKCU:\Software\Hewlett-Packard\HPOneView")) { New-Item "HKCU:\Software\Hewlett-Packard\HPOneView" -force | Out-Null }


#######################################################
# Get Library Prompt Setting
#

#Check to see if Global Policy is set first.
$regkeyGlobal   = "HKLM:\Software\Hewlett-Packard\HPOneView"
$regkeyUser     = "HKCU:\Software\Hewlett-Packard\HPOneView" 

$UserUseMSDSC   = [bool](Get-ItemProperty -LiteralPath $regkeyUser -ea silentlycontinue).'UseMSDSC'

Write-Verbose "$regkeyUser exists: $(Test-Path $regkeyUser)" -verbose:$script:ModuleVerbose
Write-Verbose "UseMSDSC Enabled: $($UserUseMSDSC)" -verbose:$script:ModuleVerbose

#Override Write-Host for MSDSC
if ((Test-Path $regkeyUser) -and ($UserUseMSDSC)) {
	
	function Write-Host 
	{
		
		[CmdletBinding()]
	    Param
		(

	        [Parameter(Mandatory = $false, Position = 0)]
	        [Object]$Object,

			[Parameter(Mandatory = $false, Position = 1)]
	        [Object]$Object2,

			[Parameter(Mandatory = $false, Position = 2)]
	        [Object]$Object3,

	        [Switch]$NoNewLine,

	        [ConsoleColor]$ForegroundColor,

	        [ConsoleColor]$BackgroundColor
	
	    )
	
	    #Override default Write-Host...
	    Write-Verbose $Object -verbose:$script:ModuleVerbose

	}

	Function Get-Host 
	{

		[CmdletBinding()]
	    Param()

		Return [PSCustomObject]$Width = @{ UI = @{ RawUI = @{ MaxWindowSize = @{ width = 120 } } } }

	}

}

# Import-Module Text
write-host ""
write-host ("         Welcome to the HP OneView POSH Library, v{0}" -f $script:ModuleVersion.ToString())
write-host "         -----------------------------------------------------"
write-host ""
write-host " To get a list of available CMDLETs in this library, type :  " -NoNewline
write-host "Get-Command -module HPOneView.200" -foregroundcolor yellow
write-host " To get help for a specific command, type:                   " -NoNewLine
write-host "get-help " -NoNewLine -foregroundcolor yellow
Write-Host "[verb]" -NoNewLine -foregroundcolor red
Write-Host "-HPOV" -NoNewLine -foregroundcolor yellow
Write-Host "[noun]" -foregroundcolor red
write-host " To get extended help for a specific command, type:          " -NoNewLine
write-host "get-help " -NoNewLine -foregroundcolor yellow
Write-Host "[verb]" -NoNewLine -foregroundcolor red
Write-Host "-HPOV" -NoNewLine -foregroundcolor yellow
Write-Host "[noun]" -NoNewLine -foregroundcolor red
Write-Host " -full" -foregroundcolor yellow
write-host " To update the offline help for this module, type:           " -NoNewLine
write-host "Update-Help -module HPOneView.200" -foregroundcolor yellow
Write-Host ""
Write-Host " Module sample scripts are located at: " -NoNewLine
write-host "$(split-path -parent $MyInvocation.MyCommand.Path)\Samples" -ForegroundColor yellow
write-host ""
write-host " If you need further help, please consult one of the following:" -ForegroundColor Green
write-host ""
write-host "  • Get-Help about_HPOneView.200"
write-host "  • Get-Help about_Appliance_Connections"
Write-host "  • Online documentation at https://github.com/HewlettPackard/POSH-HPOneView/wiki"
Write-host "  • Online Issues Tracker at https://github.com/HewlettPackard/POSH-HPOneView/issues"
write-host ""
write-host " (C) Copyright 2013-2015 Hewlett Packard Enterprise Development LP "
if ((Get-Host).UI.RawUI.MaxWindowSize.width -lt 150) 
{
    write-host ""
    write-host " Note: Set your PowerShell console width to 150 to properly view report output. (Current Max Width: $((Get-Host).UI.RawUI.MaxWindowSize.width))" -ForegroundColor Green
}
write-host ""

#######################################################
#  Remove-Module Processing
#

$ExecutionContext.SessionState.Module.OnRemove = {

    Write-Verbose "[$($MyInvocation.InvocationName.ToString().ToUpper())] Cleaning up"

}